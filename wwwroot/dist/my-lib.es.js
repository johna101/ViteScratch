var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
const GLOBALS_WHITE_LISTED = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt";
const isGloballyWhitelisted = /* @__PURE__ */ makeMap(GLOBALS_WHITE_LISTED);
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
function normalizeStyle(value) {
  if (isArray$2(value)) {
    const res = {};
    for (let i = 0; i < value.length; i++) {
      const item = value[i];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value)) {
    return value;
  } else if (isObject$1(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:(.+)/;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      const normalized = normalizeClass(value[i]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$1(value)) {
    for (const name in value) {
      if (value[name]) {
        res += name + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString$1(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
function looseCompareArrays(a, b) {
  if (a.length !== b.length)
    return false;
  let equal = true;
  for (let i = 0; equal && i < a.length; i++) {
    equal = looseEqual(a[i], b[i]);
  }
  return equal;
}
function looseEqual(a, b) {
  if (a === b)
    return true;
  let aValidType = isDate(a);
  let bValidType = isDate(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? a.getTime() === b.getTime() : false;
  }
  aValidType = isSymbol$1(a);
  bValidType = isSymbol$1(b);
  if (aValidType || bValidType) {
    return a === b;
  }
  aValidType = isArray$2(a);
  bValidType = isArray$2(b);
  if (aValidType || bValidType) {
    return aValidType && bValidType ? looseCompareArrays(a, b) : false;
  }
  aValidType = isObject$1(a);
  bValidType = isObject$1(b);
  if (aValidType || bValidType) {
    if (!aValidType || !bValidType) {
      return false;
    }
    const aKeysCount = Object.keys(a).length;
    const bKeysCount = Object.keys(b).length;
    if (aKeysCount !== bKeysCount) {
      return false;
    }
    for (const key in a) {
      const aHasKey = a.hasOwnProperty(key);
      const bHasKey = b.hasOwnProperty(key);
      if (aHasKey && !bHasKey || !aHasKey && bHasKey || !looseEqual(a[key], b[key])) {
        return false;
      }
    }
  }
  return String(a) === String(b);
}
function looseIndexOf(arr, val) {
  return arr.findIndex((item) => looseEqual(item, val));
}
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$2(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$1(val) && !isArray$2(val) && !isPlainObject(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend = Object.assign;
const remove = (arr, el) => {
  const i = arr.indexOf(el);
  if (i > -1) {
    arr.splice(i, 1);
  }
};
const hasOwnProperty$9 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$9.call(val, key);
const isArray$2 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isDate = (val) => toTypeString(val) === "[object Date]";
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol$1 = (val) => typeof val === "symbol";
const isObject$1 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$1(val) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString$1 = Object.prototype.toString;
const toTypeString = (value) => objectToString$1.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted");
const cacheStringFunction = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i = 0; i < fns.length; i++) {
    fns[i](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const toNumber$1 = (val) => {
  const n = parseFloat(val);
  return isNaN(n) ? val : n;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.active = true;
    this.effects = [];
    this.cleanups = [];
    if (!detached && activeEffectScope) {
      this.parent = activeEffectScope;
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  run(fn2) {
    if (this.active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn2();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this.active) {
      let i, l;
      for (i = 0, l = this.effects.length; i < l; i++) {
        this.effects[i].stop();
      }
      for (i = 0, l = this.cleanups.length; i < l; i++) {
        this.cleanups[i]();
      }
      if (this.scopes) {
        for (i = 0, l = this.scopes.length; i < l; i++) {
          this.scopes[i].stop(true);
        }
      }
      if (this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect2, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect2);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn2) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn2);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect2) => {
  const { deps } = effect2;
  if (deps.length) {
    let ptr = 0;
    for (let i = 0; i < deps.length; i++) {
      const dep = deps[i];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect2);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn2, scheduler = null, scope) {
    this.fn = fn2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect2) {
  const { deps } = effect2;
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect2);
    }
    deps.length = 0;
  }
}
function effect(fn2, options) {
  if (fn2.effect) {
    fn2 = fn2.effect.fn;
  }
  const _effect = new ReactiveEffect(fn2);
  if (options) {
    extend(_effect, options);
    if (options.scope)
      recordEffectScope(_effect, options.scope);
  }
  if (!options || !options.lazy) {
    _effect.run();
  }
  const runner = _effect.run.bind(_effect);
  runner.effect = _effect;
  return runner;
}
function stop(runner) {
  runner.effect.stop();
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$2(target)) {
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newValue) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$2(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$2(dep) ? dep : [...dep];
  for (const effect2 of effects) {
    if (effect2.computed) {
      triggerEffect(effect2);
    }
  }
  for (const effect2 of effects) {
    if (!effect2.computed) {
      triggerEffect(effect2);
    }
  }
}
function triggerEffect(effect2, debuggerEventExtraInfo) {
  if (effect2 !== activeEffect || effect2.allowRecurse) {
    if (effect2.scheduler) {
      effect2.scheduler();
    } else {
      effect2.run();
    }
  }
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(/* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1));
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const shallowReadonlyGet = /* @__PURE__ */ createGetter(true, true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i = 0, l = this.length; i < l; i++) {
        track(arr, "get", i + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$2(target);
    if (!isReadonly2 && targetIsArray && hasOwn(arrayInstrumentations, key)) {
      return Reflect.get(arrayInstrumentations, key, receiver);
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$1(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow && !isReadonly(value)) {
      if (!isShallow(value)) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
      }
      if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$2(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set,
  deleteProperty,
  has,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const shallowReadonlyHandlers = /* @__PURE__ */ extend({}, readonlyHandlers, {
  get: shallowReadonlyGet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get$1$1(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has$1(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$1(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get$1$1(this, key);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has: has$1,
    add,
    set: set$1,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get$1$1(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has$1.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const shallowReadonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, true)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function shallowReadonly(target) {
  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$1(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  if (ref2.dep) {
    {
      triggerEffects(ref2.dep);
    }
  }
}
function isRef(r) {
  return !!(r && r.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    newVal = this.__v_isShallow ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = this.__v_isShallow ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function triggerRef(ref2) {
  triggerRefValue(ref2);
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
class CustomRefImpl {
  constructor(factory) {
    this.dep = void 0;
    this.__v_isRef = true;
    const { get: get2, set: set2 } = factory(() => trackRefValue(this), () => triggerRefValue(this));
    this._get = get2;
    this._set = set2;
  }
  get value() {
    return this._get();
  }
  set value(newVal) {
    this._set(newVal);
  }
}
function customRef(factory) {
  return new CustomRefImpl(factory);
}
function toRefs(object) {
  const ret = isArray$2(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
const stack = [];
function warn(msg, ...args) {
  pauseTracking();
  const instance = stack.length ? stack[stack.length - 1].component : null;
  const appWarnHandler = instance && instance.appContext.config.warnHandler;
  const trace = getComponentTrace();
  if (appWarnHandler) {
    callWithErrorHandling(appWarnHandler, instance, 11, [
      msg + args.join(""),
      instance && instance.proxy,
      trace.map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`).join("\n"),
      trace
    ]);
  } else {
    const warnArgs = [`[Vue warn]: ${msg}`, ...args];
    if (trace.length && true) {
      warnArgs.push(`
`, ...formatTrace(trace));
    }
    console.warn(...warnArgs);
  }
  resetTracking();
}
function getComponentTrace() {
  let currentVNode = stack[stack.length - 1];
  if (!currentVNode) {
    return [];
  }
  const normalizedStack = [];
  while (currentVNode) {
    const last = normalizedStack[0];
    if (last && last.vnode === currentVNode) {
      last.recurseCount++;
    } else {
      normalizedStack.push({
        vnode: currentVNode,
        recurseCount: 0
      });
    }
    const parentInstance = currentVNode.component && currentVNode.component.parent;
    currentVNode = parentInstance && parentInstance.vnode;
  }
  return normalizedStack;
}
function formatTrace(trace) {
  const logs = [];
  trace.forEach((entry, i) => {
    logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
  });
  return logs;
}
function formatTraceEntry({ vnode, recurseCount }) {
  const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
  const isRoot = vnode.component ? vnode.component.parent == null : false;
  const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;
  const close2 = `>` + postfix;
  return vnode.props ? [open, ...formatProps(vnode.props), close2] : [open + close2];
}
function formatProps(props) {
  const res = [];
  const keys2 = Object.keys(props);
  keys2.slice(0, 3).forEach((key) => {
    res.push(...formatProp(key, props[key]));
  });
  if (keys2.length > 3) {
    res.push(` ...`);
  }
  return res;
}
function formatProp(key, value, raw) {
  if (isString$1(value)) {
    value = JSON.stringify(value);
    return raw ? value : [`${key}=${value}`];
  } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
    return raw ? value : [`${key}=${value}`];
  } else if (isRef(value)) {
    value = formatProp(key, toRaw(value.value), true);
    return raw ? value : [`${key}=Ref<`, value, `>`];
  } else if (isFunction$1(value)) {
    return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
  } else {
    value = toRaw(value);
    return raw ? value : [`${key}=`, value];
  }
}
function callWithErrorHandling(fn2, instance, type, args) {
  let res;
  try {
    res = args ? fn2(...args) : fn2();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn2, instance, type, args) {
  if (isFunction$1(fn2)) {
    const res = callWithErrorHandling(fn2, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i = 0; i < fn2.length; i++) {
    values.push(callWithAsyncErrorHandling(fn2[i], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i = 0; i < errorCapturedHooks.length; i++) {
          if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPreFlushCbs = [];
let activePreFlushCbs = null;
let preFlushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
let currentPreFlushParentJob = null;
function nextTick(fn2) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if ((!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) && job !== currentPreFlushParentJob) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i = queue.indexOf(job);
  if (i > flushIndex) {
    queue.splice(i, 1);
  }
}
function queueCb(cb, activeQueue, pendingQueue, index2) {
  if (!isArray$2(cb)) {
    if (!activeQueue || !activeQueue.includes(cb, cb.allowRecurse ? index2 + 1 : index2)) {
      pendingQueue.push(cb);
    }
  } else {
    pendingQueue.push(...cb);
  }
  queueFlush();
}
function queuePreFlushCb(cb) {
  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex);
}
function queuePostFlushCb(cb) {
  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex);
}
function flushPreFlushCbs(seen, parentJob = null) {
  if (pendingPreFlushCbs.length) {
    currentPreFlushParentJob = parentJob;
    activePreFlushCbs = [...new Set(pendingPreFlushCbs)];
    pendingPreFlushCbs.length = 0;
    for (preFlushIndex = 0; preFlushIndex < activePreFlushCbs.length; preFlushIndex++) {
      activePreFlushCbs[preFlushIndex]();
    }
    activePreFlushCbs = null;
    preFlushIndex = 0;
    currentPreFlushParentJob = null;
    flushPreFlushCbs(seen, parentJob);
  }
}
function flushPostFlushCbs(seen) {
  flushPreFlushCbs();
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
function flushJobs(seen) {
  isFlushPending = false;
  isFlushing = true;
  flushPreFlushCbs(seen);
  queue.sort((a, b) => getId(a) - getId(b));
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPreFlushCbs.length || pendingPostFlushCbs.length) {
      flushJobs(seen);
    }
  }
}
let devtools;
let buffer = [];
function setDevtoolsHook(hook, target) {
  var _a2, _b;
  devtools = hook;
  if (devtools) {
    devtools.enabled = true;
    buffer.forEach(({ event, args }) => devtools.emit(event, ...args));
    buffer = [];
  } else if (typeof window !== "undefined" && window.HTMLElement && !((_b = (_a2 = window.navigator) === null || _a2 === void 0 ? void 0 : _a2.userAgent) === null || _b === void 0 ? void 0 : _b.includes("jsdom"))) {
    const replay = target.__VUE_DEVTOOLS_HOOK_REPLAY__ = target.__VUE_DEVTOOLS_HOOK_REPLAY__ || [];
    replay.push((newHook) => {
      setDevtoolsHook(newHook, target);
    });
    setTimeout(() => {
      if (!devtools) {
        target.__VUE_DEVTOOLS_HOOK_REPLAY__ = null;
        buffer = [];
      }
    }, 3e3);
  } else {
    buffer = [];
  }
}
function emit$1(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
    if (trim) {
      args = rawArgs.map((a) => a.trim());
    }
    if (number) {
      args = rawArgs.map(toNumber$1);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, null);
    return null;
  }
  if (isArray$2(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend(normalized, raw);
  }
  cache.set(comp, normalized);
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
const withScopeId = (_id) => withCtx;
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn2;
  if (fn2._n) {
    return fn2;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    const res = fn2(...args);
    setCurrentRenderingInstance(prevInstance);
    if (renderFnWithContext._d) {
      setBlockTracking(1);
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit, render: render2, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render2.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render3 = Component;
      if (false)
        ;
      result = normalizeVNode(render3.length > 1 ? render3(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit
      } : { attrs, slots, emit }) : render3(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root2 = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys2 = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root2;
    if (keys2.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys2.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root2 = cloneVNode(root2, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root2 = cloneVNode(root2);
    root2.dirs = root2.dirs ? root2.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root2.transition = vnode.transition;
  }
  {
    result = root2;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
function filterSingleRoot(children) {
  let singleRoot;
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (isVNode(child)) {
      if (child.type !== Comment || child.children === "v-if") {
        if (singleRoot) {
          return;
        } else {
          singleRoot = child;
        }
      }
    } else {
      return;
    }
  }
  return singleRoot;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i = 0; i < dynamicProps.length; i++) {
        const key = dynamicProps[i];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i = 0; i < nextKeys.length; i++) {
    const key = nextKeys[i];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
const SuspenseImpl = {
  name: "Suspense",
  __isSuspense: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
    if (n1 == null) {
      mountSuspense(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals);
    } else {
      patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, rendererInternals);
    }
  },
  hydrate: hydrateSuspense,
  create: createSuspenseBoundary,
  normalize: normalizeSuspenseChildren
};
const Suspense = SuspenseImpl;
function triggerEvent$1(vnode, name) {
  const eventListener = vnode.props && vnode.props[name];
  if (isFunction$1(eventListener)) {
    eventListener();
  }
}
function mountSuspense(vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals) {
  const { p: patch, o: { createElement } } = rendererInternals;
  const hiddenContainer = createElement("div");
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals);
  patch(null, suspense.pendingBranch = vnode.ssContent, hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds);
  if (suspense.deps > 0) {
    triggerEvent$1(vnode, "onPending");
    triggerEvent$1(vnode, "onFallback");
    patch(null, vnode.ssFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds);
    setActiveBranch(suspense, vnode.ssFallback);
  } else {
    suspense.resolve();
  }
}
function patchSuspense(n1, n2, container, anchor, parentComponent, isSVG, slotScopeIds, optimized, { p: patch, um: unmount, o: { createElement } }) {
  const suspense = n2.suspense = n1.suspense;
  suspense.vnode = n2;
  n2.el = n1.el;
  const newBranch = n2.ssContent;
  const newFallback = n2.ssFallback;
  const { activeBranch, pendingBranch, isInFallback, isHydrating } = suspense;
  if (pendingBranch) {
    suspense.pendingBranch = newBranch;
    if (isSameVNodeType(newBranch, pendingBranch)) {
      patch(pendingBranch, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else if (isInFallback) {
        patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
        setActiveBranch(suspense, newFallback);
      }
    } else {
      suspense.pendingId++;
      if (isHydrating) {
        suspense.isHydrating = false;
        suspense.activeBranch = pendingBranch;
      } else {
        unmount(pendingBranch, parentComponent, suspense);
      }
      suspense.deps = 0;
      suspense.effects.length = 0;
      suspense.hiddenContainer = createElement("div");
      if (isInFallback) {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        } else {
          patch(activeBranch, newFallback, container, anchor, parentComponent, null, isSVG, slotScopeIds, optimized);
          setActiveBranch(suspense, newFallback);
        }
      } else if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
        patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        suspense.resolve(true);
      } else {
        patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
        if (suspense.deps <= 0) {
          suspense.resolve();
        }
      }
    }
  } else {
    if (activeBranch && isSameVNodeType(newBranch, activeBranch)) {
      patch(activeBranch, newBranch, container, anchor, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      setActiveBranch(suspense, newBranch);
    } else {
      triggerEvent$1(n2, "onPending");
      suspense.pendingBranch = newBranch;
      suspense.pendingId++;
      patch(null, newBranch, suspense.hiddenContainer, null, parentComponent, suspense, isSVG, slotScopeIds, optimized);
      if (suspense.deps <= 0) {
        suspense.resolve();
      } else {
        const { timeout, pendingId } = suspense;
        if (timeout > 0) {
          setTimeout(() => {
            if (suspense.pendingId === pendingId) {
              suspense.fallback(newFallback);
            }
          }, timeout);
        } else if (timeout === 0) {
          suspense.fallback(newFallback);
        }
      }
    }
  }
}
function createSuspenseBoundary(vnode, parent, parentComponent, container, hiddenContainer, anchor, isSVG, slotScopeIds, optimized, rendererInternals, isHydrating = false) {
  const { p: patch, m: move, um: unmount, n: next, o: { parentNode, remove: remove2 } } = rendererInternals;
  const timeout = toNumber$1(vnode.props && vnode.props.timeout);
  const suspense = {
    vnode,
    parent,
    parentComponent,
    isSVG,
    container,
    hiddenContainer,
    anchor,
    deps: 0,
    pendingId: 0,
    timeout: typeof timeout === "number" ? timeout : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: true,
    isHydrating,
    isUnmounted: false,
    effects: [],
    resolve(resume = false) {
      const { vnode: vnode2, activeBranch, pendingBranch, pendingId, effects, parentComponent: parentComponent2, container: container2 } = suspense;
      if (suspense.isHydrating) {
        suspense.isHydrating = false;
      } else if (!resume) {
        const delayEnter = activeBranch && pendingBranch.transition && pendingBranch.transition.mode === "out-in";
        if (delayEnter) {
          activeBranch.transition.afterLeave = () => {
            if (pendingId === suspense.pendingId) {
              move(pendingBranch, container2, anchor2, 0);
            }
          };
        }
        let { anchor: anchor2 } = suspense;
        if (activeBranch) {
          anchor2 = next(activeBranch);
          unmount(activeBranch, parentComponent2, suspense, true);
        }
        if (!delayEnter) {
          move(pendingBranch, container2, anchor2, 0);
        }
      }
      setActiveBranch(suspense, pendingBranch);
      suspense.pendingBranch = null;
      suspense.isInFallback = false;
      let parent2 = suspense.parent;
      let hasUnresolvedAncestor = false;
      while (parent2) {
        if (parent2.pendingBranch) {
          parent2.effects.push(...effects);
          hasUnresolvedAncestor = true;
          break;
        }
        parent2 = parent2.parent;
      }
      if (!hasUnresolvedAncestor) {
        queuePostFlushCb(effects);
      }
      suspense.effects = [];
      triggerEvent$1(vnode2, "onResolve");
    },
    fallback(fallbackVNode) {
      if (!suspense.pendingBranch) {
        return;
      }
      const { vnode: vnode2, activeBranch, parentComponent: parentComponent2, container: container2, isSVG: isSVG2 } = suspense;
      triggerEvent$1(vnode2, "onFallback");
      const anchor2 = next(activeBranch);
      const mountFallback = () => {
        if (!suspense.isInFallback) {
          return;
        }
        patch(null, fallbackVNode, container2, anchor2, parentComponent2, null, isSVG2, slotScopeIds, optimized);
        setActiveBranch(suspense, fallbackVNode);
      };
      const delayEnter = fallbackVNode.transition && fallbackVNode.transition.mode === "out-in";
      if (delayEnter) {
        activeBranch.transition.afterLeave = mountFallback;
      }
      suspense.isInFallback = true;
      unmount(activeBranch, parentComponent2, null, true);
      if (!delayEnter) {
        mountFallback();
      }
    },
    move(container2, anchor2, type) {
      suspense.activeBranch && move(suspense.activeBranch, container2, anchor2, type);
      suspense.container = container2;
    },
    next() {
      return suspense.activeBranch && next(suspense.activeBranch);
    },
    registerDep(instance, setupRenderEffect) {
      const isInPendingSuspense = !!suspense.pendingBranch;
      if (isInPendingSuspense) {
        suspense.deps++;
      }
      const hydratedEl = instance.vnode.el;
      instance.asyncDep.catch((err) => {
        handleError(err, instance, 0);
      }).then((asyncSetupResult) => {
        if (instance.isUnmounted || suspense.isUnmounted || suspense.pendingId !== instance.suspenseId) {
          return;
        }
        instance.asyncResolved = true;
        const { vnode: vnode2 } = instance;
        handleSetupResult(instance, asyncSetupResult, false);
        if (hydratedEl) {
          vnode2.el = hydratedEl;
        }
        const placeholder = !hydratedEl && instance.subTree.el;
        setupRenderEffect(instance, vnode2, parentNode(hydratedEl || instance.subTree.el), hydratedEl ? null : next(instance.subTree), suspense, isSVG, optimized);
        if (placeholder) {
          remove2(placeholder);
        }
        updateHOCHostEl(instance, vnode2.el);
        if (isInPendingSuspense && --suspense.deps === 0) {
          suspense.resolve();
        }
      });
    },
    unmount(parentSuspense, doRemove) {
      suspense.isUnmounted = true;
      if (suspense.activeBranch) {
        unmount(suspense.activeBranch, parentComponent, parentSuspense, doRemove);
      }
      if (suspense.pendingBranch) {
        unmount(suspense.pendingBranch, parentComponent, parentSuspense, doRemove);
      }
    }
  };
  return suspense;
}
function hydrateSuspense(node, vnode, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, rendererInternals, hydrateNode) {
  const suspense = vnode.suspense = createSuspenseBoundary(vnode, parentSuspense, parentComponent, node.parentNode, document.createElement("div"), null, isSVG, slotScopeIds, optimized, rendererInternals, true);
  const result = hydrateNode(node, suspense.pendingBranch = vnode.ssContent, parentComponent, suspense, slotScopeIds, optimized);
  if (suspense.deps === 0) {
    suspense.resolve();
  }
  return result;
}
function normalizeSuspenseChildren(vnode) {
  const { shapeFlag, children } = vnode;
  const isSlotChildren = shapeFlag & 32;
  vnode.ssContent = normalizeSuspenseSlot(isSlotChildren ? children.default : children);
  vnode.ssFallback = isSlotChildren ? normalizeSuspenseSlot(children.fallback) : createVNode(Comment);
}
function normalizeSuspenseSlot(s) {
  let block;
  if (isFunction$1(s)) {
    const trackBlock = isBlockTreeEnabled && s._c;
    if (trackBlock) {
      s._d = false;
      openBlock();
    }
    s = s();
    if (trackBlock) {
      s._d = true;
      block = currentBlock;
      closeBlock();
    }
  }
  if (isArray$2(s)) {
    const singleChild = filterSingleRoot(s);
    s = singleChild;
  }
  s = normalizeVNode(s);
  if (block && !s.dynamicChildren) {
    s.dynamicChildren = block.filter((c) => c !== s);
  }
  return s;
}
function queueEffectWithSuspense(fn2, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$2(fn2)) {
      suspense.effects.push(...fn2);
    } else {
      suspense.effects.push(fn2);
    }
  } else {
    queuePostFlushCb(fn2);
  }
}
function setActiveBranch(suspense, branch) {
  suspense.activeBranch = branch;
  const { vnode, parentComponent } = suspense;
  const el = vnode.el = branch.el;
  if (parentComponent && parentComponent.subTree === vnode) {
    parentComponent.vnode.el = el;
    updateHOCHostEl(parentComponent, el);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function watchEffect(effect2, options) {
  return doWatch(effect2, null, options);
}
function watchPostEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "post" });
}
function watchSyncEffect(effect2, options) {
  return doWatch(effect2, null, { flush: "sync" });
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = currentInstance;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$2(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
    getter = () => source.map((s) => {
      if (isRef(s)) {
        return s.value;
      } else if (isReactive(s)) {
        return traverse(s);
      } else if (isFunction$1(s)) {
        return callWithErrorHandling(s, instance, 2);
      } else
        ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn2) => {
    cleanup = effect2.onStop = () => {
      callWithErrorHandling(fn2, instance, 4);
    };
  };
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    return NOOP;
  }
  let oldValue = isMultiSource ? [] : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect2.active) {
      return;
    }
    if (cb) {
      const newValue = effect2.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect2.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    scheduler = () => queuePreFlushCb(job);
  }
  const effect2 = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect2.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect2.run.bind(effect2), instance && instance.suspense);
  } else {
    effect2.run();
  }
  return () => {
    effect2.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect2);
    }
  };
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i = 0; i < segments.length && cur; i++) {
      cur = cur[segments[i]];
    }
    return cur;
  };
}
function traverse(value, seen) {
  if (!isObject$1(value) || value["__v_skip"]) {
    return value;
  }
  seen = seen || /* @__PURE__ */ new Set();
  if (seen.has(value)) {
    return value;
  }
  seen.add(value);
  if (isRef(value)) {
    traverse(value.value, seen);
  } else if (isArray$2(value)) {
    for (let i = 0; i < value.length; i++) {
      traverse(value[i], seen);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen);
    });
  } else if (isPlainObject(value)) {
    for (const key in value) {
      traverse(value[key], seen);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c of children) {
          if (c.type !== Comment) {
            child = c;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            instance.update();
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el._leaveCb = () => {
              earlyRemove();
              el._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$2(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el._leaveCb) {
        el._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el]);
    },
    enter(el) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el]);
        } else {
          callHook2(afterHook, [el]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el, done]);
      } else {
        done();
      }
    },
    leave(el, remove2) {
      const key2 = String(vnode.key);
      if (el._enterCb) {
        el._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el]);
      let called = false;
      const done = el._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el]);
        } else {
          callHook2(onAfterLeave, [el]);
        }
        el._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i = 0; i < children.length; i++) {
    let child = children[i];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i = 0; i < ret.length; i++) {
      ret[i].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent(options) {
  return isFunction$1(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i) => !!i.type.__asyncLoader;
function defineAsyncComponent(source) {
  if (isFunction$1(source)) {
    source = { loader: source };
  }
  const {
    loader,
    loadingComponent,
    errorComponent,
    delay = 200,
    timeout,
    suspensible = true,
    onError: userOnError
  } = source;
  let pendingRequest = null;
  let resolvedComp;
  let retries = 0;
  const retry = () => {
    retries++;
    pendingRequest = null;
    return load();
  };
  const load = () => {
    let thisRequest;
    return pendingRequest || (thisRequest = pendingRequest = loader().catch((err) => {
      err = err instanceof Error ? err : new Error(String(err));
      if (userOnError) {
        return new Promise((resolve2, reject) => {
          const userRetry = () => resolve2(retry());
          const userFail = () => reject(err);
          userOnError(err, userRetry, userFail, retries + 1);
        });
      } else {
        throw err;
      }
    }).then((comp) => {
      if (thisRequest !== pendingRequest && pendingRequest) {
        return pendingRequest;
      }
      if (comp && (comp.__esModule || comp[Symbol.toStringTag] === "Module")) {
        comp = comp.default;
      }
      resolvedComp = comp;
      return comp;
    }));
  };
  return defineComponent({
    name: "AsyncComponentWrapper",
    __asyncLoader: load,
    get __asyncResolved() {
      return resolvedComp;
    },
    setup() {
      const instance = currentInstance;
      if (resolvedComp) {
        return () => createInnerComp(resolvedComp, instance);
      }
      const onError = (err) => {
        pendingRequest = null;
        handleError(err, instance, 13, !errorComponent);
      };
      if (suspensible && instance.suspense || isInSSRComponentSetup) {
        return load().then((comp) => {
          return () => createInnerComp(comp, instance);
        }).catch((err) => {
          onError(err);
          return () => errorComponent ? createVNode(errorComponent, {
            error: err
          }) : null;
        });
      }
      const loaded = ref(false);
      const error = ref();
      const delayed = ref(!!delay);
      if (delay) {
        setTimeout(() => {
          delayed.value = false;
        }, delay);
      }
      if (timeout != null) {
        setTimeout(() => {
          if (!loaded.value && !error.value) {
            const err = new Error(`Async component timed out after ${timeout}ms.`);
            onError(err);
            error.value = err;
          }
        }, timeout);
      }
      load().then(() => {
        loaded.value = true;
        if (instance.parent && isKeepAlive(instance.parent.vnode)) {
          queueJob(instance.parent.update);
        }
      }).catch((err) => {
        onError(err);
        error.value = err;
      });
      return () => {
        if (loaded.value && resolvedComp) {
          return createInnerComp(resolvedComp, instance);
        } else if (error.value && errorComponent) {
          return createVNode(errorComponent, {
            error: error.value
          });
        } else if (loadingComponent && !delayed.value) {
          return createVNode(loadingComponent);
        }
      };
    }
  });
}
function createInnerComp(comp, { vnode: { ref: ref2, props, children, shapeFlag }, parent }) {
  const vnode = createVNode(comp, props, children);
  vnode.ref = ref2;
  return vnode;
}
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
const KeepAliveImpl = {
  name: `KeepAlive`,
  __isKeepAlive: true,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const sharedContext = instance.ctx;
    if (!sharedContext.renderer) {
      return () => {
        const children = slots.default && slots.default();
        return children && children.length === 1 ? children[0] : children;
      };
    }
    const cache = /* @__PURE__ */ new Map();
    const keys2 = /* @__PURE__ */ new Set();
    let current = null;
    const parentSuspense = instance.suspense;
    const { renderer: { p: patch, m: move, um: _unmount, o: { createElement } } } = sharedContext;
    const storageContainer = createElement("div");
    sharedContext.activate = (vnode, container, anchor, isSVG, optimized) => {
      const instance2 = vnode.component;
      move(vnode, container, anchor, 0, parentSuspense);
      patch(instance2.vnode, vnode, container, anchor, instance2, parentSuspense, isSVG, vnode.slotScopeIds, optimized);
      queuePostRenderEffect(() => {
        instance2.isDeactivated = false;
        if (instance2.a) {
          invokeArrayFns(instance2.a);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeMounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
      }, parentSuspense);
    };
    sharedContext.deactivate = (vnode) => {
      const instance2 = vnode.component;
      move(vnode, storageContainer, null, 1, parentSuspense);
      queuePostRenderEffect(() => {
        if (instance2.da) {
          invokeArrayFns(instance2.da);
        }
        const vnodeHook = vnode.props && vnode.props.onVnodeUnmounted;
        if (vnodeHook) {
          invokeVNodeHook(vnodeHook, instance2.parent, vnode);
        }
        instance2.isDeactivated = true;
      }, parentSuspense);
    };
    function unmount(vnode) {
      resetShapeFlag(vnode);
      _unmount(vnode, instance, parentSuspense, true);
    }
    function pruneCache(filter) {
      cache.forEach((vnode, key) => {
        const name = getComponentName(vnode.type);
        if (name && (!filter || !filter(name))) {
          pruneCacheEntry(key);
        }
      });
    }
    function pruneCacheEntry(key) {
      const cached = cache.get(key);
      if (!current || cached.type !== current.type) {
        unmount(cached);
      } else if (current) {
        resetShapeFlag(current);
      }
      cache.delete(key);
      keys2.delete(key);
    }
    watch(() => [props.include, props.exclude], ([include, exclude]) => {
      include && pruneCache((name) => matches(include, name));
      exclude && pruneCache((name) => !matches(exclude, name));
    }, { flush: "post", deep: true });
    let pendingCacheKey = null;
    const cacheSubtree = () => {
      if (pendingCacheKey != null) {
        cache.set(pendingCacheKey, getInnerChild(instance.subTree));
      }
    };
    onMounted(cacheSubtree);
    onUpdated(cacheSubtree);
    onBeforeUnmount(() => {
      cache.forEach((cached) => {
        const { subTree, suspense } = instance;
        const vnode = getInnerChild(subTree);
        if (cached.type === vnode.type) {
          resetShapeFlag(vnode);
          const da = vnode.component.da;
          da && queuePostRenderEffect(da, suspense);
          return;
        }
        unmount(cached);
      });
    });
    return () => {
      pendingCacheKey = null;
      if (!slots.default) {
        return null;
      }
      const children = slots.default();
      const rawVNode = children[0];
      if (children.length > 1) {
        current = null;
        return children;
      } else if (!isVNode(rawVNode) || !(rawVNode.shapeFlag & 4) && !(rawVNode.shapeFlag & 128)) {
        current = null;
        return rawVNode;
      }
      let vnode = getInnerChild(rawVNode);
      const comp = vnode.type;
      const name = getComponentName(isAsyncWrapper(vnode) ? vnode.type.__asyncResolved || {} : comp);
      const { include, exclude, max } = props;
      if (include && (!name || !matches(include, name)) || exclude && name && matches(exclude, name)) {
        current = vnode;
        return rawVNode;
      }
      const key = vnode.key == null ? comp : vnode.key;
      const cachedVNode = cache.get(key);
      if (vnode.el) {
        vnode = cloneVNode(vnode);
        if (rawVNode.shapeFlag & 128) {
          rawVNode.ssContent = vnode;
        }
      }
      pendingCacheKey = key;
      if (cachedVNode) {
        vnode.el = cachedVNode.el;
        vnode.component = cachedVNode.component;
        if (vnode.transition) {
          setTransitionHooks(vnode, vnode.transition);
        }
        vnode.shapeFlag |= 512;
        keys2.delete(key);
        keys2.add(key);
      } else {
        keys2.add(key);
        if (max && keys2.size > parseInt(max, 10)) {
          pruneCacheEntry(keys2.values().next().value);
        }
      }
      vnode.shapeFlag |= 256;
      current = vnode;
      return isSuspense(rawVNode.type) ? rawVNode : vnode;
    };
  }
};
const KeepAlive = KeepAliveImpl;
function matches(pattern, name) {
  if (isArray$2(pattern)) {
    return pattern.some((p2) => matches(p2, name));
  } else if (isString$1(pattern)) {
    return pattern.split(",").includes(name);
  } else if (pattern.test) {
    return pattern.test(name);
  }
  return false;
}
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function resetShapeFlag(vnode) {
  let shapeFlag = vnode.shapeFlag;
  if (shapeFlag & 256) {
    shapeFlag -= 256;
  }
  if (shapeFlag & 512) {
    shapeFlag -= 512;
  }
  vnode.shapeFlag = shapeFlag;
}
function getInnerChild(vnode) {
  return vnode.shapeFlag & 128 ? vnode.ssContent : vnode;
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, hook, target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i = 0; i < directives.length; i++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
    if (isFunction$1(dir)) {
      dir = {
        mounted: dir,
        updated: dir
      };
    }
    if (dir.deep) {
      traverse(value);
    }
    bindings.push({
      dir,
      instance,
      value,
      oldValue: void 0,
      arg,
      modifiers
    });
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i = 0; i < bindings.length; i++) {
    const binding = bindings[i];
    if (oldBindings) {
      binding.oldValue = oldBindings[i].value;
    }
    let hook = binding.dir[name];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name) {
  return resolveAsset(DIRECTIVES, name);
}
function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false);
      if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize(camelize(name)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name) || resolve(instance.appContext[type], name);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name) {
  return registry && (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray$2(source) || isString$1(source)) {
    ret = new Array(source.length);
    for (let i = 0, l = source.length; i < l; i++) {
      ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i = 0; i < source; i++) {
      ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
    }
  } else if (isObject$1(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i) => renderItem(item, i, void 0, cached && cached[i]));
    } else {
      const keys2 = Object.keys(source);
      ret = new Array(keys2.length);
      for (let i = 0, l = keys2.length; i < l; i++) {
        const key = keys2[i];
        ret[i] = renderItem(source[key], key, i, cached && cached[i]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i = 0; i < dynamicSlots.length; i++) {
    const slot = dynamicSlots[i];
    if (isArray$2(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    return createVNode("slot", name === "default" ? null : { name }, fallback && fallback());
  }
  let slot = slots[name];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, { key: props.key || `_${name}` }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj) {
  const ret = {};
  for (const key in obj) {
    ret[toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i) => {
  if (!i)
    return null;
  if (isStatefulComponent(i))
    return getExposeProxy(i) || i.proxy;
  return getPublicInstance(i.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
  $: (i) => i,
  $el: (i) => i.vnode.el,
  $data: (i) => i.data,
  $props: (i) => i.props,
  $attrs: (i) => i.attrs,
  $slots: (i) => i.slots,
  $refs: (i) => i.refs,
  $parent: (i) => getPublicInstance(i.parent),
  $root: (i) => getPublicInstance(i.root),
  $emit: (i) => i.emit,
  $options: (i) => resolveMergedOptions(i),
  $forceUpdate: (i) => i.f || (i.f = () => queueJob(i.update)),
  $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
  $watch: (i) => instanceWatch.bind(i)
});
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n = accessCache[key];
      if (n !== void 0) {
        switch (n) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || setupState !== EMPTY_OBJ && hasOwn(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
const RuntimeCompiledPublicInstanceProxyHandlers = /* @__PURE__ */ extend({}, PublicInstanceProxyHandlers, {
  get(target, key) {
    if (key === Symbol.unscopables) {
      return;
    }
    return PublicInstanceProxyHandlers.get(target, key, target);
  },
  has(_, key) {
    const has2 = key[0] !== "_" && !isGloballyWhitelisted(key);
    return has2;
  }
});
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted,
    beforeUpdate,
    updated,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted,
    render: render2,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$1(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c.value,
        set: (v) => c.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$2(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$2(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render2 && instance.render === NOOP) {
    instance.render = render2;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$2(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$1(opt)) {
      if ("default" in opt) {
        injected = inject(opt.from || key, opt.default, true);
      } else {
        injected = inject(opt.from || key);
      }
    } else {
      injected = inject(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$2(hook) ? hook.map((h2) => h2.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$1(raw)) {
    if (isArray$2(raw)) {
      raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base2 = instance.type;
  const { mixins, extends: extendsOptions } = base2;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base2);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base2;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m) => mergeOptions(resolved, m, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base2, optionMergeStrategies);
  }
  cache.set(base2, resolved);
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m) => mergeOptions(to, m, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend(isFunction$1(to) ? to.call(this, this) : to, isFunction$1(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$2(raw)) {
    const res = {};
    for (let i = 0; i < raw.length; i++) {
      res[raw[i]] = raw[i];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend(extend(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i = 0; i < propsToUpdate.length; i++) {
        let key = propsToUpdate[i];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i = 0; i < needCastKeys.length; i++) {
      const key = needCastKeys[i];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys2] = normalizePropsOptions(raw2, appContext, true);
      extend(normalized, props);
      if (keys2)
        needCastKeys.push(...keys2);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    cache.set(comp, EMPTY_ARR);
    return EMPTY_ARR;
  }
  if (isArray$2(raw)) {
    for (let i = 0; i < raw.length; i++) {
      const normalizedKey = camelize(raw[i]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : opt;
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  cache.set(comp, res);
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match = ctor && ctor.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ctor === null ? "null" : "";
}
function isSameType(a, b) {
  return getType(a) === getType(b);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$2(expectedTypes)) {
    return expectedTypes.findIndex((t) => isSameType(t, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid = 0;
function createAppAPI(render2, hydrate2) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$1(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app = context.app = {
      _uid: uid++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin, ...options) {
        if (installedPlugins.has(plugin))
          ;
        else if (plugin && isFunction$1(plugin.install)) {
          installedPlugins.add(plugin);
          plugin.install(app, ...options);
        } else if (isFunction$1(plugin)) {
          installedPlugins.add(plugin);
          plugin(app, ...options);
        } else
          ;
        return app;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app;
      },
      component(name, component) {
        if (!component) {
          return context.components[name];
        }
        context.components[name] = component;
        return app;
      },
      directive(name, directive) {
        if (!directive) {
          return context.directives[name];
        }
        context.directives[name] = directive;
        return app;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate2) {
            hydrate2(vnode, rootContainer);
          } else {
            render2(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app._container = rootContainer;
          rootContainer.__vue_app__ = app;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render2(null, app._container);
          delete app._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app;
      }
    };
    return app;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$2(rawRef)) {
    rawRef.forEach((r, i) => setRef(r, oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$2(existing) && remove(existing, refValue);
          } else {
            if (!isArray$2(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
let hasMismatch = false;
const isSVGContainer = (container) => /svg/.test(container.namespaceURI) && container.tagName !== "foreignObject";
const isComment = (node) => node.nodeType === 8;
function createHydrationFunctions(rendererInternals) {
  const { mt: mountComponent, p: patch, o: { patchProp: patchProp2, createText, nextSibling, parentNode, remove: remove2, insert, createComment } } = rendererInternals;
  const hydrate2 = (vnode, container) => {
    if (!container.hasChildNodes()) {
      patch(null, vnode, container);
      flushPostFlushCbs();
      container._vnode = vnode;
      return;
    }
    hasMismatch = false;
    hydrateNode(container.firstChild, vnode, null, null, null);
    flushPostFlushCbs();
    container._vnode = vnode;
    if (hasMismatch && true) {
      console.error(`Hydration completed but contains mismatches.`);
    }
  };
  const hydrateNode = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized = false) => {
    const isFragmentStart = isComment(node) && node.data === "[";
    const onMismatch = () => handleMismatch(node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragmentStart);
    const { type, ref: ref2, shapeFlag, patchFlag } = vnode;
    const domType = node.nodeType;
    vnode.el = node;
    if (patchFlag === -2) {
      optimized = false;
      vnode.dynamicChildren = null;
    }
    let nextNode = null;
    switch (type) {
      case Text:
        if (domType !== 3) {
          if (vnode.children === "") {
            insert(vnode.el = createText(""), parentNode(node), node);
            nextNode = node;
          } else {
            nextNode = onMismatch();
          }
        } else {
          if (node.data !== vnode.children) {
            hasMismatch = true;
            node.data = vnode.children;
          }
          nextNode = nextSibling(node);
        }
        break;
      case Comment:
        if (domType !== 8 || isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = nextSibling(node);
        }
        break;
      case Static:
        if (domType !== 1 && domType !== 3) {
          nextNode = onMismatch();
        } else {
          nextNode = node;
          const needToAdoptContent = !vnode.children.length;
          for (let i = 0; i < vnode.staticCount; i++) {
            if (needToAdoptContent)
              vnode.children += nextNode.nodeType === 1 ? nextNode.outerHTML : nextNode.data;
            if (i === vnode.staticCount - 1) {
              vnode.anchor = nextNode;
            }
            nextNode = nextSibling(nextNode);
          }
          return nextNode;
        }
        break;
      case Fragment:
        if (!isFragmentStart) {
          nextNode = onMismatch();
        } else {
          nextNode = hydrateFragment(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
        }
        break;
      default:
        if (shapeFlag & 1) {
          if (domType !== 1 || vnode.type.toLowerCase() !== node.tagName.toLowerCase()) {
            nextNode = onMismatch();
          } else {
            nextNode = hydrateElement(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
          }
        } else if (shapeFlag & 6) {
          vnode.slotScopeIds = slotScopeIds;
          const container = parentNode(node);
          mountComponent(vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), optimized);
          nextNode = isFragmentStart ? locateClosingAsyncAnchor(node) : nextSibling(node);
          if (nextNode && isComment(nextNode) && nextNode.data === "teleport end") {
            nextNode = nextSibling(nextNode);
          }
          if (isAsyncWrapper(vnode)) {
            let subTree;
            if (isFragmentStart) {
              subTree = createVNode(Fragment);
              subTree.anchor = nextNode ? nextNode.previousSibling : container.lastChild;
            } else {
              subTree = node.nodeType === 3 ? createTextVNode("") : createVNode("div");
            }
            subTree.el = node;
            vnode.component.subTree = subTree;
          }
        } else if (shapeFlag & 64) {
          if (domType !== 8) {
            nextNode = onMismatch();
          } else {
            nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, rendererInternals, hydrateChildren);
          }
        } else if (shapeFlag & 128) {
          nextNode = vnode.type.hydrate(node, vnode, parentComponent, parentSuspense, isSVGContainer(parentNode(node)), slotScopeIds, optimized, rendererInternals, hydrateNode);
        } else
          ;
    }
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode);
    }
    return nextNode;
  };
  const hydrateElement = (el, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!vnode.dynamicChildren;
    const { type, props, patchFlag, shapeFlag, dirs } = vnode;
    const forcePatchValue = type === "input" && dirs || type === "option";
    if (forcePatchValue || patchFlag !== -1) {
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        if (forcePatchValue || !optimized || patchFlag & (16 | 32)) {
          for (const key in props) {
            if (forcePatchValue && key.endsWith("value") || isOn(key) && !isReservedProp(key)) {
              patchProp2(el, key, null, props[key], false, void 0, parentComponent);
            }
          }
        } else if (props.onClick) {
          patchProp2(el, "onClick", null, props.onClick, false, void 0, parentComponent);
        }
      }
      let vnodeHooks;
      if (vnodeHooks = props && props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHooks, parentComponent, vnode);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      if ((vnodeHooks = props && props.onVnodeMounted) || dirs) {
        queueEffectWithSuspense(() => {
          vnodeHooks && invokeVNodeHook(vnodeHooks, parentComponent, vnode);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
      if (shapeFlag & 16 && !(props && (props.innerHTML || props.textContent))) {
        let next = hydrateChildren(el.firstChild, vnode, el, parentComponent, parentSuspense, slotScopeIds, optimized);
        while (next) {
          hasMismatch = true;
          const cur = next;
          next = next.nextSibling;
          remove2(cur);
        }
      } else if (shapeFlag & 8) {
        if (el.textContent !== vnode.children) {
          hasMismatch = true;
          el.textContent = vnode.children;
        }
      }
    }
    return el.nextSibling;
  };
  const hydrateChildren = (node, parentVNode, container, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    optimized = optimized || !!parentVNode.dynamicChildren;
    const children = parentVNode.children;
    const l = children.length;
    for (let i = 0; i < l; i++) {
      const vnode = optimized ? children[i] : children[i] = normalizeVNode(children[i]);
      if (node) {
        node = hydrateNode(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized);
      } else if (vnode.type === Text && !vnode.children) {
        continue;
      } else {
        hasMismatch = true;
        patch(null, vnode, container, null, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
      }
    }
    return node;
  };
  const hydrateFragment = (node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized) => {
    const { slotScopeIds: fragmentSlotScopeIds } = vnode;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    const container = parentNode(node);
    const next = hydrateChildren(nextSibling(node), vnode, container, parentComponent, parentSuspense, slotScopeIds, optimized);
    if (next && isComment(next) && next.data === "]") {
      return nextSibling(vnode.anchor = next);
    } else {
      hasMismatch = true;
      insert(vnode.anchor = createComment(`]`), container, next);
      return next;
    }
  };
  const handleMismatch = (node, vnode, parentComponent, parentSuspense, slotScopeIds, isFragment) => {
    hasMismatch = true;
    vnode.el = null;
    if (isFragment) {
      const end = locateClosingAsyncAnchor(node);
      while (true) {
        const next2 = nextSibling(node);
        if (next2 && next2 !== end) {
          remove2(next2);
        } else {
          break;
        }
      }
    }
    const next = nextSibling(node);
    const container = parentNode(node);
    remove2(node);
    patch(null, vnode, container, next, parentComponent, parentSuspense, isSVGContainer(container), slotScopeIds);
    return next;
  };
  const locateClosingAsyncAnchor = (node) => {
    let match = 0;
    while (node) {
      node = nextSibling(node);
      if (node && isComment(node)) {
        if (node.data === "[")
          match++;
        if (node.data === "]") {
          if (match === 0) {
            return nextSibling(node);
          } else {
            match--;
          }
        }
      }
    }
    return node;
  };
  return [hydrate2, hydrateNode];
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function createHydrationRenderer(options) {
  return baseCreateRenderer(options, createHydrationFunctions);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, cloneNode: hostCloneNode, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostInsert(el, container, nextSibling);
      el = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el, anchor }) => {
    let next;
    while (el && el !== anchor) {
      next = hostNextSibling(el);
      hostRemove(el);
      el = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el;
    let vnodeHook;
    const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
    if (vnode.el && hostCloneNode !== void 0 && patchFlag === -1) {
      el = vnode.el = hostCloneNode(vnode.el);
    } else {
      el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(vnode.children, el, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(el, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el);
    }
    hostInsert(el, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el, scopeId);
    }
    if (slotScopeIds) {
      for (let i = 0; i < slotScopeIds.length; i++) {
        hostSetScopeId(el, slotScopeIds[i]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i = start; i < children.length; i++) {
      const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i = 0; i < propsToUpdate.length; i++) {
            const key = propsToUpdate[i];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i = 0; i < newChildren.length; i++) {
      const oldVNode = oldChildren[i];
      const newVNode = newChildren[i];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el, props } = initialVNode;
        const { bm, m, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(() => !instance.isUnmounted && hydrateSubTree());
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m) {
          queuePostRenderEffect(m, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(prevTree, nextTree, hostParentNode(prevTree.el), getNextHostNode(prevTree), instance, parentSuspense, isSVG);
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u) {
          queuePostRenderEffect(u, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect2 = instance.effect = new ReactiveEffect(componentUpdateFn, () => queueJob(update), instance.scope);
    const update = instance.update = () => effect2.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs(void 0, instance.update);
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i;
    for (i = 0; i < commonLength; i++) {
      const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      patch(c1[i], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e2 = l2 - 1;
    while (i <= e1 && i <= e2) {
      const n1 = c1[i];
      const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i++;
    }
    while (i <= e1 && i <= e2) {
      const n1 = c1[e1];
      const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e2--;
    }
    if (i > e1) {
      if (i <= e2) {
        const nextPos = e2 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i <= e2) {
          patch(null, c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i++;
        }
      }
    } else if (i > e2) {
      while (i <= e1) {
        unmount(c1[i], parentComponent, parentSuspense, true);
        i++;
      }
    } else {
      const s1 = i;
      const s2 = i;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i = s2; i <= e2; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e2 - s2 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i = 0; i < toBePatched; i++)
        newIndexToOldIndexMap[i] = 0;
      for (i = s1; i <= e1; i++) {
        const prevChild = c1[i];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s2; j <= e2; j++) {
            if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s2] = i + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i = toBePatched - 1; i >= 0; i--) {
        const nextIndex = s2 + i;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el, container, anchor);
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el);
        hostInsert(el, container, anchor);
        queuePostRenderEffect(() => transition.enter(el), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el, container, anchor);
        const performLeave = () => {
          leave(el, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i = start; i < children.length; i++) {
      unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render2 = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate2;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate2, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render: render2,
    hydrate: hydrate2,
    createApp: createAppAPI(render2, hydrate2)
  };
}
function toggleRecurse({ effect: effect2, update }, allowed) {
  effect2.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$2(ch1) && isArray$2(ch2)) {
    for (let i = 0; i < ch1.length; i++) {
      const c1 = ch1[i];
      let c2 = ch2[i];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i] = cloneIfMounted(ch2[i]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = u + v >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p2[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$1(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i = 0; i < children.length; i++) {
        move(children[i], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
function transformVNodeArgs(transformer) {
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$1(ref2) || isRef(ref2) || isFunction$1(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$1(style)) {
      if (isProxy(style) && !isArray$2(style)) {
        style = extend({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$2(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createStaticVNode(content, numberOfNodes) {
  const vnode = createVNode(Static, null, content);
  vnode.staticCount = numberOfNodes;
  return vnode;
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$2(child)) {
    return createVNode(Fragment, null, child.slice());
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$2(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i = 0; i < args.length; i++) {
    const toMerge = args[i];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid$1 = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid$1++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit$1.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e) => {
          handleError(e, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$1(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile$1;
let installWithProxy;
function registerRuntimeCompiler(_compile) {
  compile$1 = _compile;
  installWithProxy = (i) => {
    if (i.render._rc) {
      i.withProxy = new Proxy(i.ctx, RuntimeCompiledPublicInstanceProxyHandlers);
    }
  };
}
const isRuntimeOnly = () => !compile$1;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile$1 && !Component.render) {
      const template = Component.template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend(extend({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile$1(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
    if (installWithProxy) {
      installWithProxy(instance);
    }
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      }
    }));
  }
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function formatComponentName(instance, Component, isRoot = false) {
  let name = getComponentName(Component);
  if (!name && Component.__file) {
    const match = Component.__file.match(/([^/\\]+)\.\w+$/);
    if (match) {
      name = match[1];
    }
  }
  if (!name && instance && instance.parent) {
    const inferFromRegistry = (registry) => {
      for (const key in registry) {
        if (registry[key] === Component) {
          return key;
        }
      }
    };
    name = inferFromRegistry(instance.components || instance.parent.type.components) || inferFromRegistry(instance.appContext.components);
  }
  return name ? classify(name) : isRoot ? `App` : `Anonymous`;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function defineProps() {
  return null;
}
function defineEmits() {
  return null;
}
function defineExpose(exposed) {
}
function withDefaults(props, defaults) {
  return null;
}
function useSlots() {
  return getContext().slots;
}
function useAttrs$1() {
  return getContext().attrs;
}
function getContext() {
  const i = getCurrentInstance();
  return i.setupContext || (i.setupContext = createSetupContext(i));
}
function mergeDefaults(raw, defaults) {
  const props = isArray$2(raw) ? raw.reduce((normalized, p2) => (normalized[p2] = {}, normalized), {}) : raw;
  for (const key in defaults) {
    const opt = props[key];
    if (opt) {
      if (isArray$2(opt) || isFunction$1(opt)) {
        props[key] = { type: opt, default: defaults[key] };
      } else {
        opt.default = defaults[key];
      }
    } else if (opt === null) {
      props[key] = { default: defaults[key] };
    } else
      ;
  }
  return props;
}
function createPropsRestProxy(props, excludedKeys) {
  const ret = {};
  for (const key in props) {
    if (!excludedKeys.includes(key)) {
      Object.defineProperty(ret, key, {
        enumerable: true,
        get: () => props[key]
      });
    }
  }
  return ret;
}
function withAsyncContext(getAwaitable) {
  const ctx = getCurrentInstance();
  let awaitable = getAwaitable();
  unsetCurrentInstance();
  if (isPromise(awaitable)) {
    awaitable = awaitable.catch((e) => {
      setCurrentInstance(ctx);
      throw e;
    });
  }
  return [awaitable, () => setCurrentInstance(ctx)];
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject(ssrContextKey);
    if (!ctx) {
      warn(`Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.`);
    }
    return ctx;
  }
};
function initCustomFormatter() {
  {
    return;
  }
}
function withMemo(memo, render2, cache, index2) {
  const cached = cache[index2];
  if (cached && isMemoSame(cached, memo)) {
    return cached;
  }
  const ret = render2();
  ret.memo = memo.slice();
  return cache[index2] = ret;
}
function isMemoSame(cached, memo) {
  const prev = cached.memo;
  if (prev.length != memo.length) {
    return false;
  }
  for (let i = 0; i < prev.length; i++) {
    if (hasChanged(prev[i], memo[i])) {
      return false;
    }
  }
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(cached);
  }
  return true;
}
const version = "3.2.37";
const _ssrUtils = {
  createComponentInstance,
  setupComponent,
  renderComponentRoot,
  setCurrentRenderingInstance,
  isVNode,
  normalizeVNode
};
const ssrUtils = _ssrUtils;
const resolveFilter = null;
const compatUtils = null;
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag2, isSVG, is, props) => {
    const el = isSVG ? doc.createElementNS(svgNS, tag2) : doc.createElement(tag2, is ? { is } : void 0);
    if (tag2 === "select" && props && props.multiple != null) {
      el.setAttribute("multiple", props.multiple);
    }
    return el;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el, text) => {
    el.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el, id) {
    el.setAttribute(id, "");
  },
  cloneNode(el) {
    const cloned = el.cloneNode(true);
    if (`_value` in el) {
      cloned._value = el._value;
    }
    return cloned;
  },
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el, value, isSVG) {
  const transitionClasses = el._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el.removeAttribute("class");
  } else if (isSVG) {
    el.setAttribute("class", value);
  } else {
    el.className = value;
  }
}
function patchStyle(el, prev, next) {
  const style = el.style;
  const isCssString = isString$1(next);
  if (next && !isCssString) {
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
    if (prev && !isString$1(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el.removeAttribute("style");
    }
    if ("_vod" in el) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name, val) {
  if (isArray$2(val)) {
    val.forEach((v) => setStyle(style, name, v));
  } else {
    if (val == null)
      val = "";
    if (name.startsWith("--")) {
      style.setProperty(name, val);
    } else {
      const prefixed = autoPrefix(style, name);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name = camelize(rawName);
  if (name !== "filter" && name in style) {
    return prefixCache[rawName] = name;
  }
  name = capitalize(name);
  for (let i = 0; i < prefixes.length; i++) {
    const prefixed = prefixes[i] + name;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el.removeAttribute(key);
    } else {
      el.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el.tagName !== "PROGRESS" && !el.tagName.includes("-")) {
    el._value = value;
    const newValue = value == null ? "" : value;
    if (el.value !== newValue || el.tagName === "OPTION") {
      el.value = newValue;
    }
    if (value == null) {
      el.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el[key] = value;
  } catch (e) {
  }
  needRemove && el.removeAttribute(key);
}
const [_getNow, skipTimestampCheck] = /* @__PURE__ */ (() => {
  let _getNow2 = Date.now;
  let skipTimestampCheck2 = false;
  if (typeof window !== "undefined") {
    if (Date.now() > document.createEvent("Event").timeStamp) {
      _getNow2 = performance.now.bind(performance);
    }
    const ffMatch = navigator.userAgent.match(/firefox\/(\d+)/i);
    skipTimestampCheck2 = !!(ffMatch && Number(ffMatch[1]) <= 53);
  }
  return [_getNow2, skipTimestampCheck2];
})();
let cachedNow = 0;
const p$1 = /* @__PURE__ */ Promise.resolve();
const reset = () => {
  cachedNow = 0;
};
const getNow = () => cachedNow || (p$1.then(reset), cachedNow = _getNow());
function addEventListener(el, event, handler, options) {
  el.addEventListener(event, handler, options);
}
function removeEventListener(el, event, handler, options) {
  el.removeEventListener(event, handler, options);
}
function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
  const invokers = el._vei || (el._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el, name, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el, name, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name) {
  let options;
  if (optionsModifierRE.test(name)) {
    options = {};
    let m;
    while (m = name.match(optionsModifierRE)) {
      name = name.slice(0, name.length - m[0].length);
      options[m[0].toLowerCase()] = true;
    }
  }
  return [hyphenate(name.slice(2)), options];
}
function createInvoker(initialValue, instance) {
  const invoker = (e) => {
    const timeStamp = e.timeStamp || _getNow();
    if (skipTimestampCheck || timeStamp >= invoker.attached - 1) {
      callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5, [e]);
    }
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e, value) {
  if (isArray$2(value)) {
    const originalStop = e.stopImmediatePropagation;
    e.stopImmediatePropagation = () => {
      originalStop.call(e);
      e._stopped = true;
    };
    return value.map((fn2) => (e2) => !e2._stopped && fn2 && fn2(e2));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el, prevValue, nextValue);
  } else if (isOn(key)) {
    if (!isModelListener(key)) {
      patchEvent(el, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
    patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el._trueValue = nextValue;
    } else if (key === "false-value") {
      el._falseValue = nextValue;
    }
    patchAttr(el, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el && nativeOnRE.test(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$1(value)) {
    return false;
  }
  return key in el;
}
function defineCustomElement(options, hydrate2) {
  const Comp = defineComponent(options);
  class VueCustomElement extends VueElement {
    constructor(initialProps) {
      super(Comp, initialProps, hydrate2);
    }
  }
  VueCustomElement.def = Comp;
  return VueCustomElement;
}
const defineSSRCustomElement = (options) => {
  return defineCustomElement(options, hydrate);
};
const BaseClass = typeof HTMLElement !== "undefined" ? HTMLElement : class {
};
class VueElement extends BaseClass {
  constructor(_def, _props = {}, hydrate2) {
    super();
    this._def = _def;
    this._props = _props;
    this._instance = null;
    this._connected = false;
    this._resolved = false;
    this._numberProps = null;
    if (this.shadowRoot && hydrate2) {
      hydrate2(this._createVNode(), this.shadowRoot);
    } else {
      this.attachShadow({ mode: "open" });
    }
  }
  connectedCallback() {
    this._connected = true;
    if (!this._instance) {
      this._resolveDef();
    }
  }
  disconnectedCallback() {
    this._connected = false;
    nextTick(() => {
      if (!this._connected) {
        render(null, this.shadowRoot);
        this._instance = null;
      }
    });
  }
  _resolveDef() {
    if (this._resolved) {
      return;
    }
    this._resolved = true;
    for (let i = 0; i < this.attributes.length; i++) {
      this._setAttr(this.attributes[i].name);
    }
    new MutationObserver((mutations) => {
      for (const m of mutations) {
        this._setAttr(m.attributeName);
      }
    }).observe(this, { attributes: true });
    const resolve2 = (def2) => {
      const { props, styles } = def2;
      const hasOptions = !isArray$2(props);
      const rawKeys = props ? hasOptions ? Object.keys(props) : props : [];
      let numberProps;
      if (hasOptions) {
        for (const key in this._props) {
          const opt = props[key];
          if (opt === Number || opt && opt.type === Number) {
            this._props[key] = toNumber$1(this._props[key]);
            (numberProps || (numberProps = /* @__PURE__ */ Object.create(null)))[key] = true;
          }
        }
      }
      this._numberProps = numberProps;
      for (const key of Object.keys(this)) {
        if (key[0] !== "_") {
          this._setProp(key, this[key], true, false);
        }
      }
      for (const key of rawKeys.map(camelize)) {
        Object.defineProperty(this, key, {
          get() {
            return this._getProp(key);
          },
          set(val) {
            this._setProp(key, val);
          }
        });
      }
      this._applyStyles(styles);
      this._update();
    };
    const asyncDef = this._def.__asyncLoader;
    if (asyncDef) {
      asyncDef().then(resolve2);
    } else {
      resolve2(this._def);
    }
  }
  _setAttr(key) {
    let value = this.getAttribute(key);
    if (this._numberProps && this._numberProps[key]) {
      value = toNumber$1(value);
    }
    this._setProp(camelize(key), value, false);
  }
  _getProp(key) {
    return this._props[key];
  }
  _setProp(key, val, shouldReflect = true, shouldUpdate = true) {
    if (val !== this._props[key]) {
      this._props[key] = val;
      if (shouldUpdate && this._instance) {
        this._update();
      }
      if (shouldReflect) {
        if (val === true) {
          this.setAttribute(hyphenate(key), "");
        } else if (typeof val === "string" || typeof val === "number") {
          this.setAttribute(hyphenate(key), val + "");
        } else if (!val) {
          this.removeAttribute(hyphenate(key));
        }
      }
    }
  }
  _update() {
    render(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const vnode = createVNode(this._def, extend({}, this._props));
    if (!this._instance) {
      vnode.ce = (instance) => {
        this._instance = instance;
        instance.isCE = true;
        instance.emit = (event, ...args) => {
          this.dispatchEvent(new CustomEvent(event, {
            detail: args
          }));
        };
        let parent = this;
        while (parent = parent && (parent.parentNode || parent.host)) {
          if (parent instanceof VueElement) {
            instance.parent = parent._instance;
            break;
          }
        }
      };
    }
    return vnode;
  }
  _applyStyles(styles) {
    if (styles) {
      styles.forEach((css) => {
        const s = document.createElement("style");
        s.textContent = css;
        this.shadowRoot.appendChild(s);
      });
    }
  }
}
function useCssModule(name = "$style") {
  {
    const instance = getCurrentInstance();
    if (!instance) {
      return EMPTY_OBJ;
    }
    const modules = instance.type.__cssModules;
    if (!modules) {
      return EMPTY_OBJ;
    }
    const mod = modules[name];
    if (!mod) {
      return EMPTY_OBJ;
    }
    return mod;
  }
}
function useCssVars(getter) {
  const instance = getCurrentInstance();
  if (!instance) {
    return;
  }
  const setVars = () => setVarsOnVNode(instance.subTree, getter(instance.proxy));
  watchPostEffect(setVars);
  onMounted(() => {
    const ob = new MutationObserver(setVars);
    ob.observe(instance.subTree.el.parentNode, { childList: true });
    onUnmounted(() => ob.disconnect());
  });
}
function setVarsOnVNode(vnode, vars) {
  if (vnode.shapeFlag & 128) {
    const suspense = vnode.suspense;
    vnode = suspense.activeBranch;
    if (suspense.pendingBranch && !suspense.isHydrating) {
      suspense.effects.push(() => {
        setVarsOnVNode(suspense.activeBranch, vars);
      });
    }
  }
  while (vnode.component) {
    vnode = vnode.component.subTree;
  }
  if (vnode.shapeFlag & 1 && vnode.el) {
    setVarsOnNode(vnode.el, vars);
  } else if (vnode.type === Fragment) {
    vnode.children.forEach((c) => setVarsOnVNode(c, vars));
  } else if (vnode.type === Static) {
    let { el, anchor } = vnode;
    while (el) {
      setVarsOnNode(el, vars);
      if (el === anchor)
        break;
      el = el.nextSibling;
    }
  }
}
function setVarsOnNode(el, vars) {
  if (el.nodeType === 1) {
    const style = el.style;
    for (const key in vars) {
      style.setProperty(`--${key}`, vars[key]);
    }
  }
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$2(hook)) {
    hook.forEach((h2) => h2(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name = "v", type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el, isAppear, done) => {
    removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el, done) => {
    el._isLeaving = false;
    removeTransitionClass(el, leaveFromClass);
    removeTransitionClass(el, leaveToClass);
    removeTransitionClass(el, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el, isAppear, done);
      callHook(hook, [el, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend(baseProps, {
    onBeforeEnter(el) {
      callHook(onBeforeEnter, [el]);
      addTransitionClass(el, enterFromClass);
      addTransitionClass(el, enterActiveClass);
    },
    onBeforeAppear(el) {
      callHook(onBeforeAppear, [el]);
      addTransitionClass(el, appearFromClass);
      addTransitionClass(el, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el, done) {
      el._isLeaving = true;
      const resolve2 = () => finishLeave(el, done);
      addTransitionClass(el, leaveFromClass);
      forceReflow();
      addTransitionClass(el, leaveActiveClass);
      nextFrame(() => {
        if (!el._isLeaving) {
          return;
        }
        removeTransitionClass(el, leaveFromClass);
        addTransitionClass(el, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el, resolve2]);
    },
    onEnterCancelled(el) {
      finishEnter(el, false);
      callHook(onEnterCancelled, [el]);
    },
    onAppearCancelled(el) {
      finishEnter(el, true);
      callHook(onAppearCancelled, [el]);
    },
    onLeaveCancelled(el) {
      finishLeave(el);
      callHook(onLeaveCancelled, [el]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$1(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n = NumberOf(duration);
    return [n, n];
  }
}
function NumberOf(val) {
  const res = toNumber$1(val);
  return res;
}
function addTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
  (el._vtc || (el._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el, cls) {
  cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
  const { _vtc } = el;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el, expectedType, explicitTimeout, resolve2) {
  const id = el._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e) => {
    if (e.target === el && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el, expectedType) {
  const styles = window.getComputedStyle(el);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(TRANSITION + "Delay");
  const transitionDurations = getStyleProperties(TRANSITION + "Duration");
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(ANIMATION + "Delay");
  const animationDurations = getStyleProperties(ANIMATION + "Duration");
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(styles[TRANSITION + "Property"]);
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
}
function toMs(s) {
  return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c) => {
        const el = c.el;
        const style = el.style;
        addTransitionClass(el, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el._moveCb = (e) => {
          if (e && e.target !== el) {
            return;
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener("transitionend", cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        };
        el.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag2 = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        }
      }
      if (prevChildren) {
        for (let i = 0; i < prevChildren.length; i++) {
          const child = prevChildren[i];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag2, null, children);
    };
  }
};
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c) {
  const el = c.el;
  if (el._moveCb) {
    el._moveCb();
  }
  if (el._enterCb) {
    el._enterCb();
  }
}
function recordPosition(c) {
  newPositionMap.set(c, c.el.getBoundingClientRect());
}
function applyTranslation(c) {
  const oldPos = positionMap.get(c);
  const newPos = newPositionMap.get(c);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s = c.el.style;
    s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
    s.transitionDuration = "0s";
    return c;
  }
}
function hasCSSTransform(el, root2, moveClass) {
  const clone = el.cloneNode();
  if (el._vtc) {
    el._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
    });
  }
  moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
  clone.style.display = "none";
  const container = root2.nodeType === 1 ? root2 : root2.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn2 = vnode.props["onUpdate:modelValue"] || false;
  return isArray$2(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
};
function onCompositionStart(e) {
  e.target.composing = true;
}
function onCompositionEnd(e) {
  const target = e.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el, { modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el, lazy ? "change" : "input", (e) => {
      if (e.target.composing)
        return;
      let domValue = el.value;
      if (trim) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = toNumber$1(domValue);
      }
      el._assign(domValue);
    });
    if (trim) {
      addEventListener(el, "change", () => {
        el.value = el.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el, "compositionstart", onCompositionStart);
      addEventListener(el, "compositionend", onCompositionEnd);
      addEventListener(el, "change", onCompositionEnd);
    }
  },
  mounted(el, { value }) {
    el.value = value == null ? "" : value;
  },
  beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (el.composing)
      return;
    if (document.activeElement === el && el.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim && el.value.trim() === value) {
        return;
      }
      if ((number || el.type === "number") && toNumber$1(el.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el.value !== newValue) {
      el.value = newValue;
    }
  }
};
const vModelCheckbox = {
  deep: true,
  created(el, _, vnode) {
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      const modelValue = el._modelValue;
      const elementValue = getValue$1(el);
      const checked = el.checked;
      const assign = el._assign;
      if (isArray$2(modelValue)) {
        const index2 = looseIndexOf(modelValue, elementValue);
        const found = index2 !== -1;
        if (checked && !found) {
          assign(modelValue.concat(elementValue));
        } else if (!checked && found) {
          const filtered = [...modelValue];
          filtered.splice(index2, 1);
          assign(filtered);
        }
      } else if (isSet(modelValue)) {
        const cloned = new Set(modelValue);
        if (checked) {
          cloned.add(elementValue);
        } else {
          cloned.delete(elementValue);
        }
        assign(cloned);
      } else {
        assign(getCheckboxValue(el, checked));
      }
    });
  },
  mounted: setChecked,
  beforeUpdate(el, binding, vnode) {
    el._assign = getModelAssigner(vnode);
    setChecked(el, binding, vnode);
  }
};
function setChecked(el, { value, oldValue }, vnode) {
  el._modelValue = value;
  if (isArray$2(value)) {
    el.checked = looseIndexOf(value, vnode.props.value) > -1;
  } else if (isSet(value)) {
    el.checked = value.has(vnode.props.value);
  } else if (value !== oldValue) {
    el.checked = looseEqual(value, getCheckboxValue(el, true));
  }
}
const vModelRadio = {
  created(el, { value }, vnode) {
    el.checked = looseEqual(value, vnode.props.value);
    el._assign = getModelAssigner(vnode);
    addEventListener(el, "change", () => {
      el._assign(getValue$1(el));
    });
  },
  beforeUpdate(el, { value, oldValue }, vnode) {
    el._assign = getModelAssigner(vnode);
    if (value !== oldValue) {
      el.checked = looseEqual(value, vnode.props.value);
    }
  }
};
const vModelSelect = {
  deep: true,
  created(el, { value, modifiers: { number } }, vnode) {
    const isSetModel = isSet(value);
    addEventListener(el, "change", () => {
      const selectedVal = Array.prototype.filter.call(el.options, (o) => o.selected).map((o) => number ? toNumber$1(getValue$1(o)) : getValue$1(o));
      el._assign(el.multiple ? isSetModel ? new Set(selectedVal) : selectedVal : selectedVal[0]);
    });
    el._assign = getModelAssigner(vnode);
  },
  mounted(el, { value }) {
    setSelected(el, value);
  },
  beforeUpdate(el, _binding, vnode) {
    el._assign = getModelAssigner(vnode);
  },
  updated(el, { value }) {
    setSelected(el, value);
  }
};
function setSelected(el, value) {
  const isMultiple = el.multiple;
  if (isMultiple && !isArray$2(value) && !isSet(value)) {
    return;
  }
  for (let i = 0, l = el.options.length; i < l; i++) {
    const option = el.options[i];
    const optionValue = getValue$1(option);
    if (isMultiple) {
      if (isArray$2(value)) {
        option.selected = looseIndexOf(value, optionValue) > -1;
      } else {
        option.selected = value.has(optionValue);
      }
    } else {
      if (looseEqual(getValue$1(option), value)) {
        if (el.selectedIndex !== i)
          el.selectedIndex = i;
        return;
      }
    }
  }
  if (!isMultiple && el.selectedIndex !== -1) {
    el.selectedIndex = -1;
  }
}
function getValue$1(el) {
  return "_value" in el ? el._value : el.value;
}
function getCheckboxValue(el, checked) {
  const key = checked ? "_trueValue" : "_falseValue";
  return key in el ? el[key] : checked;
}
const vModelDynamic = {
  created(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "created");
  },
  mounted(el, binding, vnode) {
    callModelHook(el, binding, vnode, null, "mounted");
  },
  beforeUpdate(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "beforeUpdate");
  },
  updated(el, binding, vnode, prevVNode) {
    callModelHook(el, binding, vnode, prevVNode, "updated");
  }
};
function resolveDynamicModel(tagName, type) {
  switch (tagName) {
    case "SELECT":
      return vModelSelect;
    case "TEXTAREA":
      return vModelText;
    default:
      switch (type) {
        case "checkbox":
          return vModelCheckbox;
        case "radio":
          return vModelRadio;
        default:
          return vModelText;
      }
  }
}
function callModelHook(el, binding, vnode, prevVNode, hook) {
  const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);
  const fn2 = modelToUse[hook];
  fn2 && fn2(el, binding, vnode, prevVNode);
}
function initVModelForSSR() {
  vModelText.getSSRProps = ({ value }) => ({ value });
  vModelRadio.getSSRProps = ({ value }, vnode) => {
    if (vnode.props && looseEqual(vnode.props.value, value)) {
      return { checked: true };
    }
  };
  vModelCheckbox.getSSRProps = ({ value }, vnode) => {
    if (isArray$2(value)) {
      if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {
        return { checked: true };
      }
    } else if (isSet(value)) {
      if (vnode.props && value.has(vnode.props.value)) {
        return { checked: true };
      }
    } else if (value) {
      return { checked: true };
    }
  };
  vModelDynamic.getSSRProps = (binding, vnode) => {
    if (typeof vnode.type !== "string") {
      return;
    }
    const modelToUse = resolveDynamicModel(vnode.type.toUpperCase(), vnode.props && vnode.props.type);
    if (modelToUse.getSSRProps) {
      return modelToUse.getSSRProps(binding, vnode);
    }
  };
}
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e) => e.stopPropagation(),
  prevent: (e) => e.preventDefault(),
  self: (e) => e.target !== e.currentTarget,
  ctrl: (e) => !e.ctrlKey,
  shift: (e) => !e.shiftKey,
  alt: (e) => !e.altKey,
  meta: (e) => !e.metaKey,
  left: (e) => "button" in e && e.button !== 0,
  middle: (e) => "button" in e && e.button !== 1,
  right: (e) => "button" in e && e.button !== 2,
  exact: (e, modifiers) => systemModifiers.some((m) => e[`${m}Key`] && !modifiers.includes(m))
};
const withModifiers = (fn2, modifiers) => {
  return (event, ...args) => {
    for (let i = 0; i < modifiers.length; i++) {
      const guard = modifierGuards[modifiers[i]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn2(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn2, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k) => k === eventKey || keyNames[k] === eventKey)) {
      return fn2(event);
    }
  };
};
const vShow = {
  beforeMount(el, { value }, { transition }) {
    el._vod = el.style.display === "none" ? "" : el.style.display;
    if (transition && value) {
      transition.beforeEnter(el);
    } else {
      setDisplay(el, value);
    }
  },
  mounted(el, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el);
    }
  },
  updated(el, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el);
        setDisplay(el, true);
        transition.enter(el);
      } else {
        transition.leave(el, () => {
          setDisplay(el, false);
        });
      }
    } else {
      setDisplay(el, value);
    }
  },
  beforeUnmount(el, { value }) {
    setDisplay(el, value);
  }
};
function setDisplay(el, value) {
  el.style.display = value ? el._vod : "none";
}
function initVShowForSSR() {
  vShow.getSSRProps = ({ value }) => {
    if (!value) {
      return { style: { display: "none" } };
    }
  };
}
const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
let renderer;
let enabledHydration = false;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
function ensureHydrationRenderer() {
  renderer = enabledHydration ? renderer : createHydrationRenderer(rendererOptions);
  enabledHydration = true;
  return renderer;
}
const render = (...args) => {
  ensureRenderer().render(...args);
};
const hydrate = (...args) => {
  ensureHydrationRenderer().hydrate(...args);
};
const createApp = (...args) => {
  const app = ensureRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app;
};
const createSSRApp = (...args) => {
  const app = ensureHydrationRenderer().createApp(...args);
  const { mount } = app;
  app.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (container) {
      return mount(container, true, container instanceof SVGElement);
    }
  };
  return app;
};
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
let ssrDirectiveInitialized = false;
const initDirectivesForSSR = () => {
  if (!ssrDirectiveInitialized) {
    ssrDirectiveInitialized = true;
    initVModelForSSR();
    initVShowForSSR();
  }
};
const compile = () => {
};
var vue_runtime_esmBundler = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compile,
  EffectScope,
  ReactiveEffect,
  customRef,
  effect,
  effectScope,
  getCurrentScope,
  isProxy,
  isReactive,
  isReadonly,
  isRef,
  isShallow,
  markRaw,
  onScopeDispose,
  proxyRefs,
  reactive,
  readonly,
  ref,
  shallowReactive,
  shallowReadonly,
  shallowRef,
  stop,
  toRaw,
  toRef,
  toRefs,
  triggerRef,
  unref,
  camelize,
  capitalize,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  toDisplayString,
  toHandlerKey,
  BaseTransition,
  Comment,
  Fragment,
  KeepAlive,
  Static,
  Suspense,
  Teleport,
  Text,
  callWithAsyncErrorHandling,
  callWithErrorHandling,
  cloneVNode,
  compatUtils,
  computed,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createElementVNode: createBaseVNode,
  createHydrationRenderer,
  createPropsRestProxy,
  createRenderer,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineAsyncComponent,
  defineComponent,
  defineEmits,
  defineExpose,
  defineProps,
  get devtools() {
    return devtools;
  },
  getCurrentInstance,
  getTransitionRawChildren,
  guardReactiveProps,
  h,
  handleError,
  initCustomFormatter,
  inject,
  isMemoSame,
  isRuntimeOnly,
  isVNode,
  mergeDefaults,
  mergeProps,
  nextTick,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onDeactivated,
  onErrorCaptured,
  onMounted,
  onRenderTracked,
  onRenderTriggered,
  onServerPrefetch,
  onUnmounted,
  onUpdated,
  openBlock,
  popScopeId,
  provide,
  pushScopeId,
  queuePostFlushCb,
  registerRuntimeCompiler,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  resolveFilter,
  resolveTransitionHooks,
  setBlockTracking,
  setDevtoolsHook,
  setTransitionHooks,
  ssrContextKey,
  ssrUtils,
  toHandlers,
  transformVNodeArgs,
  useAttrs: useAttrs$1,
  useSSRContext,
  useSlots,
  useTransitionState,
  version,
  warn,
  watch,
  watchEffect,
  watchPostEffect,
  watchSyncEffect,
  withAsyncContext,
  withCtx,
  withDefaults,
  withDirectives,
  withMemo,
  withScopeId,
  Transition,
  TransitionGroup,
  VueElement,
  createApp,
  createSSRApp,
  defineCustomElement,
  defineSSRCustomElement,
  hydrate,
  initDirectivesForSSR,
  render,
  useCssModule,
  useCssVars,
  vModelCheckbox,
  vModelDynamic,
  vModelRadio,
  vModelSelect,
  vModelText,
  vShow,
  withKeys,
  withModifiers
}, Symbol.toStringTag, { value: "Module" }));
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$b = Object.prototype;
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag2 = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag2;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
function arrayMap(array, iteratee) {
  var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var isArray = Array.isArray;
var isArray$1 = isArray;
var INFINITY$1 = 1 / 0;
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$1(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index2 = string.length;
  while (index2-- && reWhitespace.test(string.charAt(index2))) {
  }
  return index2;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag2 = baseGetTag(value);
  return tag2 == funcTag$1 || tag2 == genTag || tag2 == asyncTag || tag2 == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$1 = getNative(root$1, "WeakMap");
var WeakMap$2 = WeakMap$1;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
var objectProto$8 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
  return value === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var Buffer2 = moduleExports$1 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var freeProcess = moduleExports && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule && freeModule.require && freeModule.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$4.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$3.call(data, key) ? data[key] : void 0;
}
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$2.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length = path.length;
  while (object != null && index2 < length) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length ? object : void 0;
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array, values) {
  var index2 = -1, length = values.length, offset = array.length;
  while (++index2 < length) {
    array[offset + index2] = values[index2];
  }
  return array;
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayFilter(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$2);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$2 && getTag(new Map$2()) != mapTag$1 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag$1 || WeakMap$2 && getTag(new WeakMap$2()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$1;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$1;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var Uint8Array2 = root$1.Uint8Array;
var Uint8Array$1 = Uint8Array2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length = array == null ? 0 : array.length;
  while (++index2 < length) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$3 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$1 ? new SetCache() : void 0;
  stack2.set(array, other);
  stack2.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result = false;
      break;
    }
  }
  stack2["delete"](array);
  stack2["delete"](other);
  return result;
}
function mapToArray(map) {
  var index2 = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set2) {
  var index2 = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1, COMPARE_UNORDERED_FLAG = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag2, bitmask, customizer, equalFunc, stack2) {
  switch (tag2) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;
      stack2.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$1 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack2.get(object);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack2.set(object, other);
  stack2.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack2["delete"](object);
  stack2["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
}
function baseIsEqual(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
}
var now = function() {
  return root$1.Date.now();
};
var now$1 = now;
var FUNC_ERROR_TEXT = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now$1();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$1());
  }
  function debounced() {
    var time = now$1(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
function fromPairs(pairs) {
  var index2 = -1, length = pairs == null ? 0 : pairs.length, result = {};
  while (++index2 < length) {
    var pair = pairs[index2];
    result[pair[0]] = pair[1];
  }
  return result;
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
function isNil(value) {
  return value == null;
}
const triggerEvent = function(elm, name, ...opts) {
  let eventName;
  if (name.includes("mouse") || name.includes("click")) {
    eventName = "MouseEvents";
  } else if (name.includes("key")) {
    eventName = "KeyboardEvent";
  } else {
    eventName = "HTMLEvents";
  }
  const evt = document.createEvent(eventName);
  evt.initEvent(name, ...opts);
  elm.dispatchEvent(evt);
  return elm;
};
const on$1 = (element, event, handler, useCapture = false) => {
  if (element && event && handler) {
    element == null ? void 0 : element.addEventListener(event, handler, useCapture);
  }
};
const off = (element, event, handler, useCapture = false) => {
  if (element && event && handler) {
    element == null ? void 0 : element.removeEventListener(event, handler, useCapture);
  }
};
const once = (el, event, fn2) => {
  const listener = function(...args) {
    if (fn2) {
      fn2.apply(this, args);
    }
    off(el, event, listener);
  };
  on$1(el, event, listener);
};
const composeEventHandlers = (theirsHandler, oursHandler, { checkForDefaultPrevented = true } = {}) => {
  const handleEvent = (event) => {
    const shouldPrevent = theirsHandler == null ? void 0 : theirsHandler(event);
    if (checkForDefaultPrevented === false || !shouldPrevent) {
      return oursHandler == null ? void 0 : oursHandler(event);
    }
  };
  return handleEvent;
};
function tryOnScopeDispose(fn2) {
  if (getCurrentScope()) {
    onScopeDispose(fn2);
    return true;
  }
  return false;
}
var _a;
const isClient = typeof window !== "undefined";
const isBoolean = (val) => typeof val === "boolean";
const isNumber = (val) => typeof val === "number";
const isString = (val) => typeof val === "string";
const noop = () => {
};
isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function createFilterWrapper(filter, fn2) {
  function wrapper(...args) {
    filter(() => fn2.apply(this, args), { fn: fn2, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function pausableFilter(extendFilter = bypassFilter) {
  const isActive = ref(true);
  function pause() {
    isActive.value = false;
  }
  function resume() {
    isActive.value = true;
  }
  const eventFilter = (...args) => {
    if (isActive.value)
      extendFilter(...args);
  };
  return { isActive, pause, resume, eventFilter };
}
function tryOnBeforeMount(fn2, sync = true) {
  if (getCurrentInstance())
    onBeforeMount(fn2);
  else if (sync)
    fn2();
  else
    nextTick(fn2);
}
function tryOnMounted(fn2, sync = true) {
  if (getCurrentInstance())
    onMounted(fn2);
  else if (sync)
    fn2();
  else
    nextTick(fn2);
}
function useTimeoutFn(cb, interval, options = {}) {
  const {
    immediate = true
  } = options;
  const isPending = ref(false);
  let timer = null;
  function clear2() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function stop2() {
    isPending.value = false;
    clear2();
  }
  function start(...args) {
    clear2();
    isPending.value = true;
    timer = setTimeout(() => {
      isPending.value = false;
      timer = null;
      cb(...args);
    }, unref(interval));
  }
  if (immediate) {
    isPending.value = true;
    if (isClient)
      start();
  }
  tryOnScopeDispose(stop2);
  return {
    isPending,
    start,
    stop: stop2
  };
}
function useToggle(initialValue = false, options = {}) {
  const {
    truthyValue = true,
    falsyValue = false
  } = options;
  const valueIsRef = isRef(initialValue);
  const innerValue = ref(initialValue);
  function toggle(value) {
    if (arguments.length) {
      innerValue.value = value;
      return innerValue.value;
    } else {
      innerValue.value = innerValue.value === unref(truthyValue) ? unref(falsyValue) : unref(truthyValue);
      return innerValue.value;
    }
  }
  if (valueIsRef)
    return toggle;
  else
    return [innerValue, toggle];
}
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __objRest$5 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchWithFilter(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter = bypassFilter
  } = _a2, watchOptions = __objRest$5(_a2, [
    "eventFilter"
  ]);
  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);
}
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var __objRest$1 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function watchPausable(source, cb, options = {}) {
  const _a2 = options, {
    eventFilter: filter
  } = _a2, watchOptions = __objRest$1(_a2, [
    "eventFilter"
  ]);
  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);
  const stop2 = watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {
    eventFilter
  }));
  return { stop: stop2, pause, resume, isActive };
}
function unrefElement(elRef) {
  var _a2;
  const plain = unref(elRef);
  return (_a2 = plain == null ? void 0 : plain.$el) != null ? _a2 : plain;
}
const defaultWindow = isClient ? window : void 0;
function useEventListener(...args) {
  let target;
  let event;
  let listener;
  let options;
  if (isString(args[0])) {
    [event, listener, options] = args;
    target = defaultWindow;
  } else {
    [target, event, listener, options] = args;
  }
  if (!target)
    return noop;
  let cleanup = noop;
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (!el)
      return;
    el.addEventListener(event, listener, options);
    cleanup = () => {
      el.removeEventListener(event, listener, options);
      cleanup = noop;
    };
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    stopWatch();
    cleanup();
  };
  tryOnScopeDispose(stop2);
  return stop2;
}
function onClickOutside(target, handler, options = {}) {
  const { window: window2 = defaultWindow, ignore, capture = true } = options;
  if (!window2)
    return;
  const shouldListen = ref(true);
  let fallback;
  const listener = (event) => {
    window2.clearTimeout(fallback);
    const el = unrefElement(target);
    const composedPath = event.composedPath();
    if (!el || el === event.target || composedPath.includes(el) || !shouldListen.value)
      return;
    if (ignore && ignore.length > 0) {
      if (ignore.some((target2) => {
        const el2 = unrefElement(target2);
        return el2 && (event.target === el2 || composedPath.includes(el2));
      }))
        return;
    }
    handler(event);
  };
  const cleanup = [
    useEventListener(window2, "click", listener, { passive: true, capture }),
    useEventListener(window2, "pointerdown", (e) => {
      const el = unrefElement(target);
      shouldListen.value = !!el && !e.composedPath().includes(el);
    }, { passive: true }),
    useEventListener(window2, "pointerup", (e) => {
      fallback = window2.setTimeout(() => listener(e), 50);
    }, { passive: true })
  ];
  const stop2 = () => cleanup.forEach((fn2) => fn2());
  return stop2;
}
function useMediaQuery(query, options = {}) {
  const { window: window2 = defaultWindow } = options;
  const isSupported = Boolean(window2 && "matchMedia" in window2);
  let mediaQuery;
  const matches2 = ref(false);
  const update = () => {
    if (!isSupported)
      return;
    if (!mediaQuery)
      mediaQuery = window2.matchMedia(query);
    matches2.value = mediaQuery.matches;
  };
  tryOnBeforeMount(() => {
    update();
    if (!mediaQuery)
      return;
    if ("addEventListener" in mediaQuery)
      mediaQuery.addEventListener("change", update);
    else
      mediaQuery.addListener(update);
    tryOnScopeDispose(() => {
      if ("removeEventListener" in mediaQuery)
        mediaQuery.removeEventListener("change", update);
      else
        mediaQuery.removeListener(update);
    });
  });
  return matches2;
}
const _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
const globalKey = "__vueuse_ssr_handlers__";
_global[globalKey] = _global[globalKey] || {};
const handlers = _global[globalKey];
function getSSRHandler(key, fallback) {
  return handlers[key] || fallback;
}
function guessSerializerType(rawInit) {
  return rawInit == null ? "any" : rawInit instanceof Set ? "set" : rawInit instanceof Map ? "map" : rawInit instanceof Date ? "date" : typeof rawInit === "boolean" ? "boolean" : typeof rawInit === "string" ? "string" : typeof rawInit === "object" ? "object" : Array.isArray(rawInit) ? "object" : !Number.isNaN(rawInit) ? "number" : "any";
}
const StorageSerializers = {
  boolean: {
    read: (v) => v === "true",
    write: (v) => String(v)
  },
  object: {
    read: (v) => JSON.parse(v),
    write: (v) => JSON.stringify(v)
  },
  number: {
    read: (v) => Number.parseFloat(v),
    write: (v) => String(v)
  },
  any: {
    read: (v) => v,
    write: (v) => String(v)
  },
  string: {
    read: (v) => v,
    write: (v) => String(v)
  },
  map: {
    read: (v) => new Map(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v.entries()))
  },
  set: {
    read: (v) => new Set(JSON.parse(v)),
    write: (v) => JSON.stringify(Array.from(v))
  },
  date: {
    read: (v) => new Date(v),
    write: (v) => v.toISOString()
  }
};
function useStorage(key, initialValue, storage, options = {}) {
  var _a2;
  const {
    flush = "pre",
    deep = true,
    listenToStorageChanges = true,
    writeDefaults = true,
    shallow,
    window: window2 = defaultWindow,
    eventFilter,
    onError = (e) => {
      console.error(e);
    }
  } = options;
  const data = (shallow ? shallowRef : ref)(initialValue);
  if (!storage) {
    try {
      storage = getSSRHandler("getDefaultStorage", () => {
        var _a22;
        return (_a22 = defaultWindow) == null ? void 0 : _a22.localStorage;
      })();
    } catch (e) {
      onError(e);
    }
  }
  if (!storage)
    return data;
  const rawInit = unref(initialValue);
  const type = guessSerializerType(rawInit);
  const serializer = (_a2 = options.serializer) != null ? _a2 : StorageSerializers[type];
  const { pause: pauseWatch, resume: resumeWatch } = watchPausable(data, () => write(data.value), { flush, deep, eventFilter });
  if (window2 && listenToStorageChanges)
    useEventListener(window2, "storage", update);
  update();
  return data;
  function write(v) {
    try {
      if (v == null)
        storage.removeItem(key);
      else
        storage.setItem(key, serializer.write(v));
    } catch (e) {
      onError(e);
    }
  }
  function read(event) {
    if (event && event.key !== key)
      return;
    pauseWatch();
    try {
      const rawValue = event ? event.newValue : storage.getItem(key);
      if (rawValue == null) {
        if (writeDefaults && rawInit !== null)
          storage.setItem(key, serializer.write(rawInit));
        return rawInit;
      } else if (typeof rawValue !== "string") {
        return rawValue;
      } else {
        return serializer.read(rawValue);
      }
    } catch (e) {
      onError(e);
    } finally {
      resumeWatch();
    }
  }
  function update(event) {
    if (event && event.key !== key)
      return;
    data.value = read(event);
  }
}
function usePreferredDark(options) {
  return useMediaQuery("(prefers-color-scheme: dark)", options);
}
var __defProp$f = Object.defineProperty;
var __getOwnPropSymbols$h = Object.getOwnPropertySymbols;
var __hasOwnProp$h = Object.prototype.hasOwnProperty;
var __propIsEnum$h = Object.prototype.propertyIsEnumerable;
var __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$f = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$h.call(b, prop))
      __defNormalProp$f(a, prop, b[prop]);
  if (__getOwnPropSymbols$h)
    for (var prop of __getOwnPropSymbols$h(b)) {
      if (__propIsEnum$h.call(b, prop))
        __defNormalProp$f(a, prop, b[prop]);
    }
  return a;
};
function useColorMode(options = {}) {
  const {
    selector = "html",
    attribute = "class",
    window: window2 = defaultWindow,
    storage,
    storageKey = "vueuse-color-scheme",
    listenToStorageChanges = true,
    storageRef
  } = options;
  const modes = __spreadValues$f({
    auto: "",
    light: "light",
    dark: "dark"
  }, options.modes || {});
  const preferredDark = usePreferredDark({ window: window2 });
  const preferredMode = computed(() => preferredDark.value ? "dark" : "light");
  const store = storageRef || (storageKey == null ? ref("auto") : useStorage(storageKey, "auto", storage, { window: window2, listenToStorageChanges }));
  const state = computed({
    get() {
      return store.value === "auto" ? preferredMode.value : store.value;
    },
    set(v) {
      store.value = v;
    }
  });
  const updateHTMLAttrs = getSSRHandler("updateHTMLAttrs", (selector2, attribute2, value) => {
    const el = window2 == null ? void 0 : window2.document.querySelector(selector2);
    if (!el)
      return;
    if (attribute2 === "class") {
      const current = value.split(/\s/g);
      Object.values(modes).flatMap((i) => (i || "").split(/\s/g)).filter(Boolean).forEach((v) => {
        if (current.includes(v))
          el.classList.add(v);
        else
          el.classList.remove(v);
      });
    } else {
      el.setAttribute(attribute2, value);
    }
  });
  function defaultOnChanged(mode) {
    var _a2;
    updateHTMLAttrs(selector, attribute, (_a2 = modes[mode]) != null ? _a2 : mode);
  }
  function onChanged(mode) {
    if (options.onChanged)
      options.onChanged(mode, defaultOnChanged);
    else
      defaultOnChanged(mode);
  }
  watch(state, onChanged, { flush: "post", immediate: true });
  tryOnMounted(() => onChanged(state.value));
  return state;
}
var __defProp$e = Object.defineProperty;
var __defProps$7 = Object.defineProperties;
var __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$g = Object.getOwnPropertySymbols;
var __hasOwnProp$g = Object.prototype.hasOwnProperty;
var __propIsEnum$g = Object.prototype.propertyIsEnumerable;
var __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$e = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$g.call(b, prop))
      __defNormalProp$e(a, prop, b[prop]);
  if (__getOwnPropSymbols$g)
    for (var prop of __getOwnPropSymbols$g(b)) {
      if (__propIsEnum$g.call(b, prop))
        __defNormalProp$e(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));
function useDark(options = {}) {
  const {
    valueDark = "dark",
    valueLight = "",
    window: window2 = defaultWindow
  } = options;
  const mode = useColorMode(__spreadProps$7(__spreadValues$e({}, options), {
    onChanged: (mode2, defaultHandler) => {
      var _a2;
      if (options.onChanged)
        (_a2 = options.onChanged) == null ? void 0 : _a2.call(options, mode2 === "dark");
      else
        defaultHandler(mode2);
    },
    modes: {
      dark: valueDark,
      light: valueLight
    }
  }));
  const preferredDark = usePreferredDark({ window: window2 });
  const isDark2 = computed({
    get() {
      return mode.value === "dark";
    },
    set(v) {
      if (v === preferredDark.value)
        mode.value = "auto";
      else
        mode.value = v ? "dark" : "light";
    }
  });
  return isDark2;
}
var __getOwnPropSymbols$c = Object.getOwnPropertySymbols;
var __hasOwnProp$c = Object.prototype.hasOwnProperty;
var __propIsEnum$c = Object.prototype.propertyIsEnumerable;
var __objRest$2 = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$c.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$c)
    for (var prop of __getOwnPropSymbols$c(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum$c.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function useResizeObserver(target, callback, options = {}) {
  const _a2 = options, { window: window2 = defaultWindow } = _a2, observerOptions = __objRest$2(_a2, ["window"]);
  let observer;
  const isSupported = window2 && "ResizeObserver" in window2;
  const cleanup = () => {
    if (observer) {
      observer.disconnect();
      observer = void 0;
    }
  };
  const stopWatch = watch(() => unrefElement(target), (el) => {
    cleanup();
    if (isSupported && window2 && el) {
      observer = new ResizeObserver(callback);
      observer.observe(el, observerOptions);
    }
  }, { immediate: true, flush: "post" });
  const stop2 = () => {
    cleanup();
    stopWatch();
  };
  tryOnScopeDispose(stop2);
  return {
    isSupported,
    stop: stop2
  };
}
var SwipeDirection;
(function(SwipeDirection2) {
  SwipeDirection2["UP"] = "UP";
  SwipeDirection2["RIGHT"] = "RIGHT";
  SwipeDirection2["DOWN"] = "DOWN";
  SwipeDirection2["LEFT"] = "LEFT";
  SwipeDirection2["NONE"] = "NONE";
})(SwipeDirection || (SwipeDirection = {}));
const resizeHandler = function(entries) {
  for (const entry of entries) {
    const listeners = entry.target.__resizeListeners__ || [];
    if (listeners.length) {
      listeners.forEach((fn2) => {
        fn2();
      });
    }
  }
};
const addResizeListener = function(element, fn2) {
  if (!isClient || !element)
    return;
  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new ResizeObserver(resizeHandler);
    element.__ro__.observe(element);
  }
  element.__resizeListeners__.push(fn2);
};
const removeResizeListener = function(element, fn2) {
  var _a2;
  if (!element || !element.__resizeListeners__)
    return;
  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn2), 1);
  if (!element.__resizeListeners__.length) {
    (_a2 = element.__ro__) == null ? void 0 : _a2.disconnect();
  }
};
const isUndefined = (val) => val === void 0;
const isEmpty = (val) => !val && val !== 0 || isArray$2(val) && val.length === 0 || isObject$1(val) && !Object.keys(val).length;
const isElement = (e) => {
  if (typeof Element === "undefined")
    return false;
  return e instanceof Element;
};
const keysOf = (arr) => Object.keys(arr);
class ElementPlusError extends Error {
  constructor(m) {
    super(m);
    this.name = "ElementPlusError";
  }
}
function throwError(scope, m) {
  throw new ElementPlusError(`[${scope}] ${m}`);
}
function debugWarn(scope, message2) {
}
const classNameToArray = (cls = "") => cls.split(" ").filter((item) => !!item.trim());
const hasClass = (el, cls) => {
  if (!el || !cls)
    return false;
  if (cls.includes(" "))
    throw new Error("className should not contain space.");
  return el.classList.contains(cls);
};
const addClass = (el, cls) => {
  if (!el || !cls.trim())
    return;
  el.classList.add(...classNameToArray(cls));
};
const removeClass = (el, cls) => {
  if (!el || !cls.trim())
    return;
  el.classList.remove(...classNameToArray(cls));
};
function addUnit(value, defaultUnit = "px") {
  if (!value)
    return "";
  if (isString$1(value)) {
    return value;
  } else if (isNumber(value)) {
    return `${value}${defaultUnit}`;
  }
}
/*! Element Plus Icons Vue v2.0.5 */
var export_helper_default = (sfc, props) => {
  let target = sfc.__vccOpts || sfc;
  for (let [key, val] of props)
    target[key] = val;
  return target;
};
var _sfc_main6 = {
  name: "ArrowDown"
}, _hoisted_16 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_26 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M831.872 340.864 512 652.672 192.128 340.864a30.592 30.592 0 0 0-42.752 0 29.12 29.12 0 0 0 0 41.6L489.664 714.24a32 32 0 0 0 44.672 0l340.288-331.712a29.12 29.12 0 0 0 0-41.728 30.592 30.592 0 0 0-42.752 0z"
}, null, -1), _hoisted_36 = [
  _hoisted_26
];
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_16, _hoisted_36);
}
var arrow_down_default = /* @__PURE__ */ export_helper_default(_sfc_main6, [["render", _sfc_render6], ["__file", "arrow-down.vue"]]);
var _sfc_main8 = {
  name: "ArrowLeft"
}, _hoisted_18 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_28 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M609.408 149.376 277.76 489.6a32 32 0 0 0 0 44.672l331.648 340.352a29.12 29.12 0 0 0 41.728 0 30.592 30.592 0 0 0 0-42.752L339.264 511.936l311.872-319.872a30.592 30.592 0 0 0 0-42.688 29.12 29.12 0 0 0-41.728 0z"
}, null, -1), _hoisted_38 = [
  _hoisted_28
];
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_18, _hoisted_38);
}
var arrow_left_default = /* @__PURE__ */ export_helper_default(_sfc_main8, [["render", _sfc_render8], ["__file", "arrow-left.vue"]]);
var _sfc_main10 = {
  name: "ArrowRight"
}, _hoisted_110 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_210 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M340.864 149.312a30.592 30.592 0 0 0 0 42.752L652.736 512 340.864 831.872a30.592 30.592 0 0 0 0 42.752 29.12 29.12 0 0 0 41.728 0L714.24 534.336a32 32 0 0 0 0-44.672L382.592 149.376a29.12 29.12 0 0 0-41.728 0z"
}, null, -1), _hoisted_310 = [
  _hoisted_210
];
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_110, _hoisted_310);
}
var arrow_right_default = /* @__PURE__ */ export_helper_default(_sfc_main10, [["render", _sfc_render10], ["__file", "arrow-right.vue"]]);
var _sfc_main12 = {
  name: "ArrowUp"
}, _hoisted_112 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_212 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "m488.832 344.32-339.84 356.672a32 32 0 0 0 0 44.16l.384.384a29.44 29.44 0 0 0 42.688 0l320-335.872 319.872 335.872a29.44 29.44 0 0 0 42.688 0l.384-.384a32 32 0 0 0 0-44.16L535.168 344.32a32 32 0 0 0-46.336 0z"
}, null, -1), _hoisted_312 = [
  _hoisted_212
];
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_112, _hoisted_312);
}
var arrow_up_default = /* @__PURE__ */ export_helper_default(_sfc_main12, [["render", _sfc_render12], ["__file", "arrow-up.vue"]]);
var _sfc_main29 = {
  name: "Calendar"
}, _hoisted_129 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_229 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M128 384v512h768V192H768v32a32 32 0 1 1-64 0v-32H320v32a32 32 0 0 1-64 0v-32H128v128h768v64H128zm192-256h384V96a32 32 0 1 1 64 0v32h160a32 32 0 0 1 32 32v768a32 32 0 0 1-32 32H96a32 32 0 0 1-32-32V160a32 32 0 0 1 32-32h160V96a32 32 0 0 1 64 0v32zm-32 384h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 0 1 0 64h-64a32 32 0 0 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm192-192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64zm0 192h64a32 32 0 1 1 0 64h-64a32 32 0 1 1 0-64z"
}, null, -1), _hoisted_328 = [
  _hoisted_229
];
function _sfc_render29(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_129, _hoisted_328);
}
var calendar_default = /* @__PURE__ */ export_helper_default(_sfc_main29, [["render", _sfc_render29], ["__file", "calendar.vue"]]);
var _sfc_main48 = {
  name: "CircleCheck"
}, _hoisted_148 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_248 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1), _hoisted_347 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M745.344 361.344a32 32 0 0 1 45.312 45.312l-288 288a32 32 0 0 1-45.312 0l-160-160a32 32 0 1 1 45.312-45.312L480 626.752l265.344-265.408z"
}, null, -1), _hoisted_414 = [
  _hoisted_248,
  _hoisted_347
];
function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_148, _hoisted_414);
}
var circle_check_default = /* @__PURE__ */ export_helper_default(_sfc_main48, [["render", _sfc_render48], ["__file", "circle-check.vue"]]);
var _sfc_main49 = {
  name: "CircleCloseFilled"
}, _hoisted_149 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_249 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 393.664L407.936 353.6a38.4 38.4 0 1 0-54.336 54.336L457.664 512 353.6 616.064a38.4 38.4 0 1 0 54.336 54.336L512 566.336 616.064 670.4a38.4 38.4 0 1 0 54.336-54.336L566.336 512 670.4 407.936a38.4 38.4 0 1 0-54.336-54.336L512 457.664z"
}, null, -1), _hoisted_348 = [
  _hoisted_249
];
function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_149, _hoisted_348);
}
var circle_close_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main49, [["render", _sfc_render49], ["__file", "circle-close-filled.vue"]]);
var _sfc_main50 = {
  name: "CircleClose"
}, _hoisted_150 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_250 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "m466.752 512-90.496-90.496a32 32 0 0 1 45.248-45.248L512 466.752l90.496-90.496a32 32 0 1 1 45.248 45.248L557.248 512l90.496 90.496a32 32 0 1 1-45.248 45.248L512 557.248l-90.496 90.496a32 32 0 0 1-45.248-45.248L466.752 512z"
}, null, -1), _hoisted_349 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1), _hoisted_415 = [
  _hoisted_250,
  _hoisted_349
];
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_150, _hoisted_415);
}
var circle_close_default = /* @__PURE__ */ export_helper_default(_sfc_main50, [["render", _sfc_render50], ["__file", "circle-close.vue"]]);
var _sfc_main53 = {
  name: "Clock"
}, _hoisted_153 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_253 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"
}, null, -1), _hoisted_352 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 256a32 32 0 0 1 32 32v256a32 32 0 0 1-64 0V288a32 32 0 0 1 32-32z"
}, null, -1), _hoisted_417 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M480 512h256q32 0 32 32t-32 32H480q-32 0-32-32t32-32z"
}, null, -1), _hoisted_55 = [
  _hoisted_253,
  _hoisted_352,
  _hoisted_417
];
function _sfc_render53(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_153, _hoisted_55);
}
var clock_default = /* @__PURE__ */ export_helper_default(_sfc_main53, [["render", _sfc_render53], ["__file", "clock.vue"]]);
var _sfc_main55 = {
  name: "Close"
}, _hoisted_155 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_255 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M764.288 214.592 512 466.88 259.712 214.592a31.936 31.936 0 0 0-45.12 45.12L466.752 512 214.528 764.224a31.936 31.936 0 1 0 45.12 45.184L512 557.184l252.288 252.288a31.936 31.936 0 0 0 45.12-45.12L557.12 512.064l252.288-252.352a31.936 31.936 0 1 0-45.12-45.184z"
}, null, -1), _hoisted_354 = [
  _hoisted_255
];
function _sfc_render55(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_155, _hoisted_354);
}
var close_default = /* @__PURE__ */ export_helper_default(_sfc_main55, [["render", _sfc_render55], ["__file", "close.vue"]]);
var _sfc_main71 = {
  name: "DArrowLeft"
}, _hoisted_171 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_271 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M529.408 149.376a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L259.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L197.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224zm256 0a29.12 29.12 0 0 1 41.728 0 30.592 30.592 0 0 1 0 42.688L515.264 511.936l311.872 319.936a30.592 30.592 0 0 1-.512 43.264 29.12 29.12 0 0 1-41.216-.512L453.76 534.272a32 32 0 0 1 0-44.672l331.648-340.224z"
}, null, -1), _hoisted_370 = [
  _hoisted_271
];
function _sfc_render71(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_171, _hoisted_370);
}
var d_arrow_left_default = /* @__PURE__ */ export_helper_default(_sfc_main71, [["render", _sfc_render71], ["__file", "d-arrow-left.vue"]]);
var _sfc_main72 = {
  name: "DArrowRight"
}, _hoisted_172 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_272 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M452.864 149.312a29.12 29.12 0 0 1 41.728.064L826.24 489.664a32 32 0 0 1 0 44.672L494.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L764.736 512 452.864 192a30.592 30.592 0 0 1 0-42.688zm-256 0a29.12 29.12 0 0 1 41.728.064L570.24 489.664a32 32 0 0 1 0 44.672L238.592 874.624a29.12 29.12 0 0 1-41.728 0 30.592 30.592 0 0 1 0-42.752L508.736 512 196.864 192a30.592 30.592 0 0 1 0-42.688z"
}, null, -1), _hoisted_371 = [
  _hoisted_272
];
function _sfc_render72(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_172, _hoisted_371);
}
var d_arrow_right_default = /* @__PURE__ */ export_helper_default(_sfc_main72, [["render", _sfc_render72], ["__file", "d-arrow-right.vue"]]);
var _sfc_main89 = {
  name: "Document"
}, _hoisted_189 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_289 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M832 384H576V128H192v768h640V384zm-26.496-64L640 154.496V320h165.504zM160 64h480l256 256v608a32 32 0 0 1-32 32H160a32 32 0 0 1-32-32V96a32 32 0 0 1 32-32zm160 448h384v64H320v-64zm0-192h160v64H320v-64zm0 384h384v64H320v-64z"
}, null, -1), _hoisted_388 = [
  _hoisted_289
];
function _sfc_render89(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_189, _hoisted_388);
}
var document_default = /* @__PURE__ */ export_helper_default(_sfc_main89, [["render", _sfc_render89], ["__file", "document.vue"]]);
var _sfc_main130 = {
  name: "Hide"
}, _hoisted_1130 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2130 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M876.8 156.8c0-9.6-3.2-16-9.6-22.4-6.4-6.4-12.8-9.6-22.4-9.6-9.6 0-16 3.2-22.4 9.6L736 220.8c-64-32-137.6-51.2-224-60.8-160 16-288 73.6-377.6 176C44.8 438.4 0 496 0 512s48 73.6 134.4 176c22.4 25.6 44.8 48 73.6 67.2l-86.4 89.6c-6.4 6.4-9.6 12.8-9.6 22.4 0 9.6 3.2 16 9.6 22.4 6.4 6.4 12.8 9.6 22.4 9.6 9.6 0 16-3.2 22.4-9.6l704-710.4c3.2-6.4 6.4-12.8 6.4-22.4Zm-646.4 528c-76.8-70.4-128-128-153.6-172.8 28.8-48 80-105.6 153.6-172.8C304 272 400 230.4 512 224c64 3.2 124.8 19.2 176 44.8l-54.4 54.4C598.4 300.8 560 288 512 288c-64 0-115.2 22.4-160 64s-64 96-64 160c0 48 12.8 89.6 35.2 124.8L256 707.2c-9.6-6.4-19.2-16-25.6-22.4Zm140.8-96c-12.8-22.4-19.2-48-19.2-76.8 0-44.8 16-83.2 48-112 32-28.8 67.2-48 112-48 28.8 0 54.4 6.4 73.6 19.2L371.2 588.8ZM889.599 336c-12.8-16-28.8-28.8-41.6-41.6l-48 48c73.6 67.2 124.8 124.8 150.4 169.6-28.8 48-80 105.6-153.6 172.8-73.6 67.2-172.8 108.8-284.8 115.2-51.2-3.2-99.2-12.8-140.8-28.8l-48 48c57.6 22.4 118.4 38.4 188.8 44.8 160-16 288-73.6 377.6-176C979.199 585.6 1024 528 1024 512s-48.001-73.6-134.401-176Z",
  fill: "currentColor"
}, null, -1), _hoisted_3129 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M511.998 672c-12.8 0-25.6-3.2-38.4-6.4l-51.2 51.2c28.8 12.8 57.6 19.2 89.6 19.2 64 0 115.2-22.4 160-64 41.6-41.6 64-96 64-160 0-32-6.4-64-19.2-89.6l-51.2 51.2c3.2 12.8 6.4 25.6 6.4 38.4 0 44.8-16 83.2-48 112-32 28.8-67.2 48-112 48Z",
  fill: "currentColor"
}, null, -1), _hoisted_436 = [
  _hoisted_2130,
  _hoisted_3129
];
function _sfc_render130(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1130, _hoisted_436);
}
var hide_default = /* @__PURE__ */ export_helper_default(_sfc_main130, [["render", _sfc_render130], ["__file", "hide.vue"]]);
var _sfc_main140 = {
  name: "InfoFilled"
}, _hoisted_1140 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2140 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896.064A448 448 0 0 1 512 64zm67.2 275.072c33.28 0 60.288-23.104 60.288-57.344s-27.072-57.344-60.288-57.344c-33.28 0-60.16 23.104-60.16 57.344s26.88 57.344 60.16 57.344zM590.912 699.2c0-6.848 2.368-24.64 1.024-34.752l-52.608 60.544c-10.88 11.456-24.512 19.392-30.912 17.28a12.992 12.992 0 0 1-8.256-14.72l87.68-276.992c7.168-35.136-12.544-67.2-54.336-71.296-44.096 0-108.992 44.736-148.48 101.504 0 6.784-1.28 23.68.064 33.792l52.544-60.608c10.88-11.328 23.552-19.328 29.952-17.152a12.8 12.8 0 0 1 7.808 16.128L388.48 728.576c-10.048 32.256 8.96 63.872 55.04 71.04 67.84 0 107.904-43.648 147.456-100.416z"
}, null, -1), _hoisted_3139 = [
  _hoisted_2140
];
function _sfc_render140(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1140, _hoisted_3139);
}
var info_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main140, [["render", _sfc_render140], ["__file", "info-filled.vue"]]);
var _sfc_main147 = {
  name: "Loading"
}, _hoisted_1147 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2147 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V96a32 32 0 0 1 32-32zm0 640a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V736a32 32 0 0 1 32-32zm448-192a32 32 0 0 1-32 32H736a32 32 0 1 1 0-64h192a32 32 0 0 1 32 32zm-640 0a32 32 0 0 1-32 32H96a32 32 0 0 1 0-64h192a32 32 0 0 1 32 32zM195.2 195.2a32 32 0 0 1 45.248 0L376.32 331.008a32 32 0 0 1-45.248 45.248L195.2 240.448a32 32 0 0 1 0-45.248zm452.544 452.544a32 32 0 0 1 45.248 0L828.8 783.552a32 32 0 0 1-45.248 45.248L647.744 692.992a32 32 0 0 1 0-45.248zM828.8 195.264a32 32 0 0 1 0 45.184L692.992 376.32a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0zm-452.544 452.48a32 32 0 0 1 0 45.248L240.448 828.8a32 32 0 0 1-45.248-45.248l135.808-135.808a32 32 0 0 1 45.248 0z"
}, null, -1), _hoisted_3146 = [
  _hoisted_2147
];
function _sfc_render147(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1147, _hoisted_3146);
}
var loading_default = /* @__PURE__ */ export_helper_default(_sfc_main147, [["render", _sfc_render147], ["__file", "loading.vue"]]);
var _sfc_main150 = {
  name: "Location"
}, _hoisted_1150 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2150 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M800 416a288 288 0 1 0-576 0c0 118.144 94.528 272.128 288 456.576C705.472 688.128 800 534.144 800 416zM512 960C277.312 746.688 160 565.312 160 416a352 352 0 0 1 704 0c0 149.312-117.312 330.688-352 544z"
}, null, -1), _hoisted_3149 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 512a96 96 0 1 0 0-192 96 96 0 0 0 0 192zm0 64a160 160 0 1 1 0-320 160 160 0 0 1 0 320z"
}, null, -1), _hoisted_439 = [
  _hoisted_2150,
  _hoisted_3149
];
function _sfc_render150(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1150, _hoisted_439);
}
var location_default = /* @__PURE__ */ export_helper_default(_sfc_main150, [["render", _sfc_render150], ["__file", "location.vue"]]);
var _sfc_main159 = {
  name: "Menu"
}, _hoisted_1159 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2159 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M160 448a32 32 0 0 1-32-32V160.064a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32V416a32 32 0 0 1-32 32H160zm448 0a32 32 0 0 1-32-32V160.064a32 32 0 0 1 32-32h255.936a32 32 0 0 1 32 32V416a32 32 0 0 1-32 32H608zM160 896a32 32 0 0 1-32-32V608a32 32 0 0 1 32-32h256a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32H160zm448 0a32 32 0 0 1-32-32V608a32 32 0 0 1 32-32h255.936a32 32 0 0 1 32 32v256a32 32 0 0 1-32 32H608z"
}, null, -1), _hoisted_3158 = [
  _hoisted_2159
];
function _sfc_render159(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1159, _hoisted_3158);
}
var menu_default = /* @__PURE__ */ export_helper_default(_sfc_main159, [["render", _sfc_render159], ["__file", "menu.vue"]]);
var _sfc_main171 = {
  name: "More"
}, _hoisted_1171 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2171 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M176 416a112 112 0 1 0 0 224 112 112 0 0 0 0-224m0 64a48 48 0 1 1 0 96 48 48 0 0 1 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96zm336-64a112 112 0 1 1 0 224 112 112 0 0 1 0-224zm0 64a48 48 0 1 0 0 96 48 48 0 0 0 0-96z"
}, null, -1), _hoisted_3170 = [
  _hoisted_2171
];
function _sfc_render171(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1171, _hoisted_3170);
}
var more_default = /* @__PURE__ */ export_helper_default(_sfc_main171, [["render", _sfc_render171], ["__file", "more.vue"]]);
var _sfc_main226 = {
  name: "Setting"
}, _hoisted_1226 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2226 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M600.704 64a32 32 0 0 1 30.464 22.208l35.2 109.376c14.784 7.232 28.928 15.36 42.432 24.512l112.384-24.192a32 32 0 0 1 34.432 15.36L944.32 364.8a32 32 0 0 1-4.032 37.504l-77.12 85.12a357.12 357.12 0 0 1 0 49.024l77.12 85.248a32 32 0 0 1 4.032 37.504l-88.704 153.6a32 32 0 0 1-34.432 15.296L708.8 803.904c-13.44 9.088-27.648 17.28-42.368 24.512l-35.264 109.376A32 32 0 0 1 600.704 960H423.296a32 32 0 0 1-30.464-22.208L357.696 828.48a351.616 351.616 0 0 1-42.56-24.64l-112.32 24.256a32 32 0 0 1-34.432-15.36L79.68 659.2a32 32 0 0 1 4.032-37.504l77.12-85.248a357.12 357.12 0 0 1 0-48.896l-77.12-85.248A32 32 0 0 1 79.68 364.8l88.704-153.6a32 32 0 0 1 34.432-15.296l112.32 24.256c13.568-9.152 27.776-17.408 42.56-24.64l35.2-109.312A32 32 0 0 1 423.232 64H600.64zm-23.424 64H446.72l-36.352 113.088-24.512 11.968a294.113 294.113 0 0 0-34.816 20.096l-22.656 15.36-116.224-25.088-65.28 113.152 79.68 88.192-1.92 27.136a293.12 293.12 0 0 0 0 40.192l1.92 27.136-79.808 88.192 65.344 113.152 116.224-25.024 22.656 15.296a294.113 294.113 0 0 0 34.816 20.096l24.512 11.968L446.72 896h130.688l36.48-113.152 24.448-11.904a288.282 288.282 0 0 0 34.752-20.096l22.592-15.296 116.288 25.024 65.28-113.152-79.744-88.192 1.92-27.136a293.12 293.12 0 0 0 0-40.256l-1.92-27.136 79.808-88.128-65.344-113.152-116.288 24.96-22.592-15.232a287.616 287.616 0 0 0-34.752-20.096l-24.448-11.904L577.344 128zM512 320a192 192 0 1 1 0 384 192 192 0 0 1 0-384zm0 64a128 128 0 1 0 0 256 128 128 0 0 0 0-256z"
}, null, -1), _hoisted_3225 = [
  _hoisted_2226
];
function _sfc_render226(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1226, _hoisted_3225);
}
var setting_default = /* @__PURE__ */ export_helper_default(_sfc_main226, [["render", _sfc_render226], ["__file", "setting.vue"]]);
var _sfc_main243 = {
  name: "SuccessFilled"
}, _hoisted_1243 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2243 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm-55.808 536.384-99.52-99.584a38.4 38.4 0 1 0-54.336 54.336l126.72 126.72a38.272 38.272 0 0 0 54.336 0l262.4-262.464a38.4 38.4 0 1 0-54.272-54.336L456.192 600.384z"
}, null, -1), _hoisted_3242 = [
  _hoisted_2243
];
function _sfc_render243(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1243, _hoisted_3242);
}
var success_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main243, [["render", _sfc_render243], ["__file", "success-filled.vue"]]);
var _sfc_main274 = {
  name: "View"
}, _hoisted_1274 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2274 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 160c320 0 512 352 512 352S832 864 512 864 0 512 0 512s192-352 512-352zm0 64c-225.28 0-384.128 208.064-436.8 288 52.608 79.872 211.456 288 436.8 288 225.28 0 384.128-208.064 436.8-288-52.608-79.872-211.456-288-436.8-288zm0 64a224 224 0 1 1 0 448 224 224 0 0 1 0-448zm0 64a160.192 160.192 0 0 0-160 160c0 88.192 71.744 160 160 160s160-71.808 160-160-71.744-160-160-160z"
}, null, -1), _hoisted_3273 = [
  _hoisted_2274
];
function _sfc_render274(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1274, _hoisted_3273);
}
var view_default = /* @__PURE__ */ export_helper_default(_sfc_main274, [["render", _sfc_render274], ["__file", "view.vue"]]);
var _sfc_main277 = {
  name: "WarningFilled"
}, _hoisted_1277 = {
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg"
}, _hoisted_2277 = /* @__PURE__ */ createBaseVNode("path", {
  fill: "currentColor",
  d: "M512 64a448 448 0 1 1 0 896 448 448 0 0 1 0-896zm0 192a58.432 58.432 0 0 0-58.24 63.744l23.36 256.384a35.072 35.072 0 0 0 69.76 0l23.296-256.384A58.432 58.432 0 0 0 512 256zm0 512a51.2 51.2 0 1 0 0-102.4 51.2 51.2 0 0 0 0 102.4z"
}, null, -1), _hoisted_3276 = [
  _hoisted_2277
];
function _sfc_render277(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1277, _hoisted_3276);
}
var warning_filled_default = /* @__PURE__ */ export_helper_default(_sfc_main277, [["render", _sfc_render277], ["__file", "warning-filled.vue"]]);
const epPropKey = "__epPropKey";
const definePropType = (val) => val;
const isEpProp = (val) => isObject$1(val) && !!val[epPropKey];
const buildProp = (prop, key) => {
  if (!isObject$1(prop) || isEpProp(prop))
    return prop;
  const { values, required, default: defaultValue, type, validator } = prop;
  const _validator = values || validator ? (val) => {
    let valid = false;
    let allowedValues = [];
    if (values) {
      allowedValues = Array.from(values);
      if (hasOwn(prop, "default")) {
        allowedValues.push(defaultValue);
      }
      valid || (valid = allowedValues.includes(val));
    }
    if (validator)
      valid || (valid = validator(val));
    if (!valid && allowedValues.length > 0) {
      const allowValuesText = [...new Set(allowedValues)].map((value) => JSON.stringify(value)).join(", ");
      warn(`Invalid prop: validation failed${key ? ` for prop "${key}"` : ""}. Expected one of [${allowValuesText}], got value ${JSON.stringify(val)}.`);
    }
    return valid;
  } : void 0;
  const epProp = {
    type,
    required: !!required,
    validator: _validator,
    [epPropKey]: true
  };
  if (hasOwn(prop, "default"))
    epProp.default = defaultValue;
  return epProp;
};
const buildProps = (props) => fromPairs(Object.entries(props).map(([key, option]) => [
  key,
  buildProp(option, key)
]));
const iconPropType = definePropType([
  String,
  Object,
  Function
]);
const TypeComponents = {
  Close: close_default,
  SuccessFilled: success_filled_default,
  InfoFilled: info_filled_default,
  WarningFilled: warning_filled_default,
  CircleCloseFilled: circle_close_filled_default
};
const TypeComponentsMap = {
  success: success_filled_default,
  warning: warning_filled_default,
  error: circle_close_filled_default,
  info: info_filled_default
};
const ValidateComponentsMap = {
  validating: loading_default,
  success: circle_check_default,
  error: circle_close_default
};
const withInstall = (main, extra) => {
  main.install = (app) => {
    for (const comp of [main, ...Object.values(extra != null ? extra : {})]) {
      app.component(comp.name, comp);
    }
  };
  if (extra) {
    for (const [key, comp] of Object.entries(extra)) {
      main[key] = comp;
    }
  }
  return main;
};
const withInstallFunction = (fn2, name) => {
  fn2.install = (app) => {
    fn2._context = app._context;
    app.config.globalProperties[name] = fn2;
  };
  return fn2;
};
const withNoopInstall = (component) => {
  component.install = NOOP;
  return component;
};
const EVENT_CODE = {
  tab: "Tab",
  enter: "Enter",
  space: "Space",
  left: "ArrowLeft",
  up: "ArrowUp",
  right: "ArrowRight",
  down: "ArrowDown",
  esc: "Escape",
  delete: "Delete",
  backspace: "Backspace",
  numpadEnter: "NumpadEnter",
  pageUp: "PageUp",
  pageDown: "PageDown",
  home: "Home",
  end: "End"
};
const datePickTypes = [
  "year",
  "month",
  "date",
  "dates",
  "week",
  "datetime",
  "datetimerange",
  "daterange",
  "monthrange"
];
const UPDATE_MODEL_EVENT = "update:modelValue";
const componentSizes = ["", "default", "small", "large"];
const castArray = (arr) => {
  if (!arr && arr !== 0)
    return [];
  return Array.isArray(arr) ? arr : [arr];
};
const isKorean = (text) => /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi.test(text);
const generateId = () => Math.floor(Math.random() * 1e4);
const mutable = (val) => val;
const DEFAULT_EXCLUDE_KEYS = ["class", "style"];
const LISTENER_PREFIX = /^on[A-Z]/;
const useAttrs = (params = {}) => {
  const { excludeListeners = false, excludeKeys } = params;
  const allExcludeKeys = computed(() => {
    return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
  });
  const instance = getCurrentInstance();
  if (!instance) {
    return computed(() => ({}));
  }
  return computed(() => {
    var _a2;
    return fromPairs(Object.entries((_a2 = instance.proxy) == null ? void 0 : _a2.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
  });
};
const buttonGroupContextKey = Symbol("buttonGroupContextKey");
const configProviderContextKey = Symbol();
const formContextKey = Symbol("formContextKey");
const formItemContextKey = Symbol("formItemContextKey");
const scrollbarContextKey = Symbol("scrollbarContextKey");
const POPPER_INJECTION_KEY = Symbol("popper");
const POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
const ROOT_PICKER_INJECTION_KEY = Symbol();
const useProp = (name) => {
  const vm = getCurrentInstance();
  return computed(() => {
    var _a2, _b;
    return (_b = ((_a2 = vm.proxy) == null ? void 0 : _a2.$props)[name]) != null ? _b : void 0;
  });
};
const globalConfig = ref();
function useGlobalConfig(key, defaultValue = void 0) {
  const config = getCurrentInstance() ? inject(configProviderContextKey, globalConfig) : globalConfig;
  if (key) {
    return computed(() => {
      var _a2, _b;
      return (_b = (_a2 = config.value) == null ? void 0 : _a2[key]) != null ? _b : defaultValue;
    });
  } else {
    return config;
  }
}
const provideGlobalConfig = (config, app, global2 = false) => {
  var _a2;
  const inSetup = !!getCurrentInstance();
  const oldConfig = inSetup ? useGlobalConfig() : void 0;
  const provideFn = (_a2 = app == null ? void 0 : app.provide) != null ? _a2 : inSetup ? provide : void 0;
  if (!provideFn) {
    return;
  }
  const context = computed(() => {
    const cfg = unref(config);
    if (!(oldConfig == null ? void 0 : oldConfig.value))
      return cfg;
    return mergeConfig(oldConfig.value, cfg);
  });
  provideFn(configProviderContextKey, context);
  if (global2 || !globalConfig.value) {
    globalConfig.value = context.value;
  }
  return context;
};
const mergeConfig = (a, b) => {
  var _a2;
  const keys2 = [.../* @__PURE__ */ new Set([...keysOf(a), ...keysOf(b)])];
  const obj = {};
  for (const key of keys2) {
    obj[key] = (_a2 = b[key]) != null ? _a2 : a[key];
  }
  return obj;
};
const useSizeProp = buildProp({
  type: String,
  values: componentSizes,
  required: false
});
const useSize = (fallback, ignore = {}) => {
  const emptyRef = ref(void 0);
  const size2 = ignore.prop ? emptyRef : useProp("size");
  const globalConfig2 = ignore.global ? emptyRef : useGlobalConfig("size");
  const form = ignore.form ? { size: void 0 } : inject(formContextKey, void 0);
  const formItem = ignore.formItem ? { size: void 0 } : inject(formItemContextKey, void 0);
  return computed(() => size2.value || unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form == null ? void 0 : form.size) || globalConfig2.value || "");
};
const useDisabled = (fallback) => {
  const disabled = useProp("disabled");
  const form = inject(formContextKey, void 0);
  return computed(() => disabled.value || unref(fallback) || (form == null ? void 0 : form.disabled) || false);
};
const useDeprecated = ({ from, replacement, scope, version: version2, ref: ref2, type = "API" }, condition) => {
  watch(() => unref(condition), (val) => {
  }, {
    immediate: true
  });
};
const defaultIdInjection = {
  prefix: Math.floor(Math.random() * 1e4),
  current: 0
};
const ID_INJECTION_KEY = Symbol("elIdInjection");
const useId = (deterministicId) => {
  const idInjection = inject(ID_INJECTION_KEY, defaultIdInjection);
  const idRef = computed(() => unref(deterministicId) || `el-id-${idInjection.prefix}-${idInjection.current++}`);
  return idRef;
};
const useFormItem = () => {
  const form = inject(formContextKey, void 0);
  const formItem = inject(formItemContextKey, void 0);
  return {
    form,
    formItem
  };
};
const useFormItemInputId = (props, {
  formItemContext,
  disableIdGeneration,
  disableIdManagement
}) => {
  if (!disableIdGeneration) {
    disableIdGeneration = ref(false);
  }
  if (!disableIdManagement) {
    disableIdManagement = ref(false);
  }
  const inputId = ref();
  let idUnwatch = void 0;
  const isLabeledByFormItem = computed(() => {
    var _a2;
    return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a2 = formItemContext.inputIds) == null ? void 0 : _a2.length) <= 1);
  });
  onMounted(() => {
    idUnwatch = watch([toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
      const newId = id != null ? id : !disableIdGeneration2 ? useId().value : void 0;
      if (newId !== inputId.value) {
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
          if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
            formItemContext.addInputId(newId);
          }
        }
        inputId.value = newId;
      }
    }, { immediate: true });
  });
  onUnmounted(() => {
    idUnwatch && idUnwatch();
    if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
      inputId.value && formItemContext.removeInputId(inputId.value);
    }
  });
  return {
    isLabeledByFormItem,
    inputId
  };
};
var English = {
  name: "en",
  el: {
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color."
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    }
  }
};
const buildTranslator = (locale) => (path, option) => translate(path, option, unref(locale));
const translate = (path, option, locale) => get(locale, path, path).replace(/\{(\w+)\}/g, (_, key) => {
  var _a2;
  return `${(_a2 = option == null ? void 0 : option[key]) != null ? _a2 : `{${key}}`}`;
});
const buildLocaleContext = (locale) => {
  const lang = computed(() => unref(locale).name);
  const localeRef = isRef(locale) ? locale : ref(locale);
  return {
    lang,
    locale: localeRef,
    t: buildTranslator(locale)
  };
};
const useLocale = () => {
  const locale = useGlobalConfig("locale");
  return buildLocaleContext(computed(() => locale.value || English));
};
const _prop = buildProp({
  type: definePropType(Boolean),
  default: null
});
const _event = buildProp({
  type: definePropType(Function)
});
const createModelToggleComposable = (name) => {
  const updateEventKey = `update:${name}`;
  const updateEventKeyRaw = `onUpdate:${name}`;
  const useModelToggleEmits2 = [updateEventKey];
  const useModelToggleProps2 = {
    [name]: _prop,
    [updateEventKeyRaw]: _event
  };
  const useModelToggle2 = ({
    indicator,
    toggleReason,
    shouldHideWhenRouteChanges,
    shouldProceed,
    onShow,
    onHide
  }) => {
    const instance = getCurrentInstance();
    const { emit } = instance;
    const props = instance.props;
    const hasUpdateHandler = computed(() => isFunction$1(props[updateEventKeyRaw]));
    const isModelBindingAbsent = computed(() => props[name] === null);
    const doShow = (event) => {
      if (indicator.value === true) {
        return;
      }
      indicator.value = true;
      if (toggleReason) {
        toggleReason.value = event;
      }
      if (isFunction$1(onShow)) {
        onShow(event);
      }
    };
    const doHide = (event) => {
      if (indicator.value === false) {
        return;
      }
      indicator.value = false;
      if (toggleReason) {
        toggleReason.value = event;
      }
      if (isFunction$1(onHide)) {
        onHide(event);
      }
    };
    const show = (event) => {
      if (props.disabled === true || isFunction$1(shouldProceed) && !shouldProceed())
        return;
      const shouldEmit = hasUpdateHandler.value && isClient;
      if (shouldEmit) {
        emit(updateEventKey, true);
      }
      if (isModelBindingAbsent.value || !shouldEmit) {
        doShow(event);
      }
    };
    const hide = (event) => {
      if (props.disabled === true || !isClient)
        return;
      const shouldEmit = hasUpdateHandler.value && isClient;
      if (shouldEmit) {
        emit(updateEventKey, false);
      }
      if (isModelBindingAbsent.value || !shouldEmit) {
        doHide(event);
      }
    };
    const onChange = (val) => {
      if (!isBoolean(val))
        return;
      if (props.disabled && val) {
        if (hasUpdateHandler.value) {
          emit(updateEventKey, false);
        }
      } else if (indicator.value !== val) {
        if (val) {
          doShow();
        } else {
          doHide();
        }
      }
    };
    const toggle = () => {
      if (indicator.value) {
        hide();
      } else {
        show();
      }
    };
    watch(() => props[name], onChange);
    if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
      watch(() => __spreadValues({}, instance.proxy.$route), () => {
        if (shouldHideWhenRouteChanges.value && indicator.value) {
          hide();
        }
      });
    }
    onMounted(() => {
      onChange(props[name]);
    });
    return {
      hide,
      show,
      toggle
    };
  };
  return {
    useModelToggle: useModelToggle2,
    useModelToggleProps: useModelToggleProps2,
    useModelToggleEmits: useModelToggleEmits2
  };
};
function useTimeout() {
  let timeoutHandle;
  const registerTimeout = (fn2, delay) => {
    cancelTimeout();
    timeoutHandle = window.setTimeout(fn2, delay);
  };
  const cancelTimeout = () => window.clearTimeout(timeoutHandle);
  tryOnScopeDispose(() => cancelTimeout());
  return {
    registerTimeout,
    cancelTimeout
  };
}
let registeredEscapeHandlers = [];
const useEscapeKeydown = (handler) => {
  const cachedHandler = (e) => {
    const event = e;
    if (event.key === EVENT_CODE.esc) {
      registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
    }
  };
  onMounted(() => {
    if (registeredEscapeHandlers.length === 0) {
      document.addEventListener("keydown", cachedHandler);
    }
    if (isClient)
      registeredEscapeHandlers.push(handler);
  });
  onBeforeUnmount(() => {
    registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
    if (registeredEscapeHandlers.length === 0) {
      if (isClient)
        document.removeEventListener("keydown", cachedHandler);
    }
  });
};
let cachedContainer;
const POPPER_CONTAINER_ID = `el-popper-container-${generateId()}`;
const POPPER_CONTAINER_SELECTOR = `#${POPPER_CONTAINER_ID}`;
const createContainer = () => {
  const container = document.createElement("div");
  container.id = POPPER_CONTAINER_ID;
  document.body.appendChild(container);
  return container;
};
const usePopperContainer = () => {
  onBeforeMount(() => {
    if (!isClient)
      return;
    if (!cachedContainer || !document.body.querySelector(POPPER_CONTAINER_SELECTOR)) {
      cachedContainer = createContainer();
    }
  });
};
const useDelayedToggleProps = buildProps({
  showAfter: {
    type: Number,
    default: 0
  },
  hideAfter: {
    type: Number,
    default: 200
  }
});
const useDelayedToggle = ({
  showAfter,
  hideAfter,
  open,
  close: close2
}) => {
  const { registerTimeout } = useTimeout();
  const onOpen = (event) => {
    registerTimeout(() => {
      open(event);
    }, unref(showAfter));
  };
  const onClose = (event) => {
    registerTimeout(() => {
      close2(event);
    }, unref(hideAfter));
  };
  return {
    onOpen,
    onClose
  };
};
const FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
const useForwardRef = (forwardRef) => {
  const setForwardRef = (el) => {
    forwardRef.value = el;
  };
  provide(FORWARD_REF_INJECTION_KEY, {
    setForwardRef
  });
};
const useForwardRefDirective = (setForwardRef) => {
  return {
    mounted(el) {
      setForwardRef(el);
    },
    updated(el) {
      setForwardRef(el);
    },
    unmounted() {
      setForwardRef(null);
    }
  };
};
const defaultNamespace = "el";
const statePrefix = "is-";
const _bem = (namespace, block, blockSuffix, element, modifier) => {
  let cls = `${namespace}-${block}`;
  if (blockSuffix) {
    cls += `-${blockSuffix}`;
  }
  if (element) {
    cls += `__${element}`;
  }
  if (modifier) {
    cls += `--${modifier}`;
  }
  return cls;
};
const useNamespace = (block) => {
  const globalConfig2 = useGlobalConfig("namespace");
  const namespace = computed(() => globalConfig2.value || defaultNamespace);
  const b = (blockSuffix = "") => _bem(unref(namespace), block, blockSuffix, "", "");
  const e = (element) => element ? _bem(unref(namespace), block, "", element, "") : "";
  const m = (modifier) => modifier ? _bem(unref(namespace), block, "", "", modifier) : "";
  const be2 = (blockSuffix, element) => blockSuffix && element ? _bem(unref(namespace), block, blockSuffix, element, "") : "";
  const em = (element, modifier) => element && modifier ? _bem(unref(namespace), block, "", element, modifier) : "";
  const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(unref(namespace), block, blockSuffix, "", modifier) : "";
  const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(unref(namespace), block, blockSuffix, element, modifier) : "";
  const is = (name, ...args) => {
    const state = args.length >= 1 ? args[0] : true;
    return name && state ? `${statePrefix}${name}` : "";
  };
  const cssVar = (object) => {
    const styles = {};
    for (const key in object) {
      styles[`--${namespace.value}-${key}`] = object[key];
    }
    return styles;
  };
  const cssVarBlock = (object) => {
    const styles = {};
    for (const key in object) {
      styles[`--${namespace.value}-${block}-${key}`] = object[key];
    }
    return styles;
  };
  const cssVarName = (name) => `--${namespace.value}-${name}`;
  const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
  return {
    namespace,
    b,
    e,
    m,
    be: be2,
    em,
    bm,
    bem,
    is,
    cssVar,
    cssVarName,
    cssVarBlock,
    cssVarBlockName
  };
};
const zIndex = ref(0);
const useZIndex = () => {
  const initialZIndex = useGlobalConfig("zIndex", 2e3);
  const currentZIndex = computed(() => initialZIndex.value + zIndex.value);
  const nextZIndex = () => {
    zIndex.value++;
    return currentZIndex.value;
  };
  return {
    initialZIndex,
    currentZIndex,
    nextZIndex
  };
};
function useCursor(input2) {
  const selectionRef = ref();
  function recordCursor() {
    if (input2.value == void 0)
      return;
    const { selectionStart, selectionEnd, value } = input2.value;
    if (selectionStart == null || selectionEnd == null)
      return;
    const beforeTxt = value.slice(0, Math.max(0, selectionStart));
    const afterTxt = value.slice(Math.max(0, selectionEnd));
    selectionRef.value = {
      selectionStart,
      selectionEnd,
      value,
      beforeTxt,
      afterTxt
    };
  }
  function setCursor() {
    if (input2.value == void 0 || selectionRef.value == void 0)
      return;
    const { value } = input2.value;
    const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
    if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
      return;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else {
      const beforeLastChar = beforeTxt[selectionStart - 1];
      const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    input2.value.setSelectionRange(startPos, startPos);
  }
  return [recordCursor, setCursor];
}
var _export_sfc$1 = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const iconProps = buildProps({
  size: {
    type: definePropType([Number, String])
  },
  color: {
    type: String
  }
});
const __default__$d = {
  name: "ElIcon",
  inheritAttrs: false
};
const _sfc_main$A = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$d), {
  props: iconProps,
  setup(__props) {
    const props = __props;
    const ns2 = useNamespace("icon");
    const style = computed(() => {
      if (!props.size && !props.color)
        return {};
      return {
        fontSize: isUndefined(props.size) ? void 0 : addUnit(props.size),
        "--color": props.color
      };
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("i", mergeProps({
        class: unref(ns2).b(),
        style: unref(style)
      }, _ctx.$attrs), [
        renderSlot(_ctx.$slots, "default")
      ], 16);
    };
  }
}));
var Icon = /* @__PURE__ */ _export_sfc$1(_sfc_main$A, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/icon/src/icon.vue"]]);
const ElIcon = withInstall(Icon);
let hiddenTextarea = void 0;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
`;
const CONTEXT_STYLE = [
  "letter-spacing",
  "line-height",
  "padding-top",
  "padding-bottom",
  "font-family",
  "font-weight",
  "font-size",
  "text-rendering",
  "text-transform",
  "width",
  "text-indent",
  "padding-left",
  "padding-right",
  "border-width",
  "box-sizing"
];
function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue("box-sizing");
  const paddingSize = Number.parseFloat(style.getPropertyValue("padding-bottom")) + Number.parseFloat(style.getPropertyValue("padding-top"));
  const borderSize = Number.parseFloat(style.getPropertyValue("border-bottom-width")) + Number.parseFloat(style.getPropertyValue("border-top-width"));
  const contextStyle = CONTEXT_STYLE.map((name) => `${name}:${style.getPropertyValue(name)}`).join(";");
  return { contextStyle, paddingSize, borderSize, boxSizing };
}
function calcTextareaHeight(targetElement, minRows = 1, maxRows) {
  var _a2;
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    document.body.appendChild(hiddenTextarea);
  }
  const { paddingSize, borderSize, boxSizing, contextStyle } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute("style", `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
  let height = hiddenTextarea.scrollHeight;
  const result = {};
  if (boxSizing === "border-box") {
    height = height + borderSize;
  } else if (boxSizing === "content-box") {
    height = height - paddingSize;
  }
  hiddenTextarea.value = "";
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
  if (isNumber(minRows)) {
    let minHeight = singleRowHeight * minRows;
    if (boxSizing === "border-box") {
      minHeight = minHeight + paddingSize + borderSize;
    }
    height = Math.max(minHeight, height);
    result.minHeight = `${minHeight}px`;
  }
  if (isNumber(maxRows)) {
    let maxHeight = singleRowHeight * maxRows;
    if (boxSizing === "border-box") {
      maxHeight = maxHeight + paddingSize + borderSize;
    }
    height = Math.min(maxHeight, height);
  }
  result.height = `${height}px`;
  (_a2 = hiddenTextarea.parentNode) == null ? void 0 : _a2.removeChild(hiddenTextarea);
  hiddenTextarea = void 0;
  return result;
}
const inputProps = buildProps({
  id: {
    type: String,
    default: void 0
  },
  size: useSizeProp,
  disabled: Boolean,
  modelValue: {
    type: definePropType([
      String,
      Number,
      Object
    ]),
    default: ""
  },
  type: {
    type: String,
    default: "text"
  },
  resize: {
    type: String,
    values: ["none", "both", "horizontal", "vertical"]
  },
  autosize: {
    type: definePropType([Boolean, Object]),
    default: false
  },
  autocomplete: {
    type: String,
    default: "off"
  },
  formatter: {
    type: Function
  },
  parser: {
    type: Function
  },
  placeholder: {
    type: String
  },
  form: {
    type: String,
    default: ""
  },
  readonly: {
    type: Boolean,
    default: false
  },
  clearable: {
    type: Boolean,
    default: false
  },
  showPassword: {
    type: Boolean,
    default: false
  },
  showWordLimit: {
    type: Boolean,
    default: false
  },
  suffixIcon: {
    type: iconPropType,
    default: ""
  },
  prefixIcon: {
    type: iconPropType,
    default: ""
  },
  containerRole: {
    type: String,
    default: void 0
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: [String, Number],
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  inputStyle: {
    type: definePropType([Object, Array, String]),
    default: () => mutable({})
  }
});
const inputEmits = {
  [UPDATE_MODEL_EVENT]: (value) => isString$1(value),
  input: (value) => isString$1(value),
  change: (value) => isString$1(value),
  focus: (evt) => evt instanceof FocusEvent,
  blur: (evt) => evt instanceof FocusEvent,
  clear: () => true,
  mouseleave: (evt) => evt instanceof MouseEvent,
  mouseenter: (evt) => evt instanceof MouseEvent,
  keydown: (evt) => evt instanceof Event,
  compositionstart: (evt) => evt instanceof CompositionEvent,
  compositionupdate: (evt) => evt instanceof CompositionEvent,
  compositionend: (evt) => evt instanceof CompositionEvent
};
const _hoisted_1$i = ["role"];
const _hoisted_2$g = ["id", "type", "disabled", "formatter", "parser", "readonly", "autocomplete", "tabindex", "aria-label", "placeholder"];
const _hoisted_3$9 = ["id", "tabindex", "disabled", "readonly", "autocomplete", "aria-label", "placeholder"];
const __default__$c = {
  name: "ElInput",
  inheritAttrs: false
};
const _sfc_main$z = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$c), {
  props: inputProps,
  emits: inputEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const PENDANT_MAP = {
      suffix: "append",
      prefix: "prepend"
    };
    const instance = getCurrentInstance();
    const rawAttrs = useAttrs$1();
    const slots = useSlots();
    const containerAttrs = computed(() => {
      const comboBoxAttrs = {};
      if (props.containerRole === "combobox") {
        comboBoxAttrs["aria-haspopup"] = rawAttrs["aria-haspopup"];
        comboBoxAttrs["aria-owns"] = rawAttrs["aria-owns"];
        comboBoxAttrs["aria-expanded"] = rawAttrs["aria-expanded"];
      }
      return comboBoxAttrs;
    });
    const attrs = useAttrs({
      excludeKeys: computed(() => {
        return Object.keys(containerAttrs.value);
      })
    });
    const { form, formItem } = useFormItem();
    const { inputId } = useFormItemInputId(props, {
      formItemContext: formItem
    });
    const inputSize = useSize();
    const inputDisabled = useDisabled();
    const nsInput = useNamespace("input");
    const nsTextarea = useNamespace("textarea");
    const input2 = shallowRef();
    const textarea = shallowRef();
    const focused = ref(false);
    const hovering = ref(false);
    const isComposing = ref(false);
    const passwordVisible = ref(false);
    const countStyle = ref();
    const textareaCalcStyle = shallowRef(props.inputStyle);
    const _ref = computed(() => input2.value || textarea.value);
    const needStatusIcon = computed(() => {
      var _a2;
      return (_a2 = form == null ? void 0 : form.statusIcon) != null ? _a2 : false;
    });
    const validateState = computed(() => (formItem == null ? void 0 : formItem.validateState) || "");
    const validateIcon = computed(() => ValidateComponentsMap[validateState.value]);
    const passwordIcon = computed(() => passwordVisible.value ? view_default : hide_default);
    const containerStyle = computed(() => [
      rawAttrs.style,
      props.inputStyle
    ]);
    const textareaStyle = computed(() => [
      props.inputStyle,
      textareaCalcStyle.value,
      { resize: props.resize }
    ]);
    const nativeInputValue = computed(() => isNil(props.modelValue) ? "" : String(props.modelValue));
    const showClear = computed(() => props.clearable && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (focused.value || hovering.value));
    const showPwdVisible = computed(() => props.showPassword && !inputDisabled.value && !props.readonly && !!nativeInputValue.value && (!!nativeInputValue.value || focused.value));
    const isWordLimitVisible = computed(() => props.showWordLimit && !!attrs.value.maxlength && (props.type === "text" || props.type === "textarea") && !inputDisabled.value && !props.readonly && !props.showPassword);
    const textLength = computed(() => Array.from(nativeInputValue.value).length);
    const inputExceed = computed(() => !!isWordLimitVisible.value && textLength.value > Number(attrs.value.maxlength));
    const suffixVisible = computed(() => !!slots.suffix || !!props.suffixIcon || showClear.value || props.showPassword || isWordLimitVisible.value || !!validateState.value && needStatusIcon.value);
    const [recordCursor, setCursor] = useCursor(input2);
    useResizeObserver(textarea, (entries) => {
      if (!isWordLimitVisible.value || props.resize !== "both")
        return;
      const entry = entries[0];
      const { width } = entry.contentRect;
      countStyle.value = {
        right: `calc(100% - ${width + 15 + 6}px)`
      };
    });
    const resizeTextarea = () => {
      const { type, autosize } = props;
      if (!isClient || type !== "textarea")
        return;
      if (autosize) {
        const minRows = isObject$1(autosize) ? autosize.minRows : void 0;
        const maxRows = isObject$1(autosize) ? autosize.maxRows : void 0;
        textareaCalcStyle.value = __spreadValues({}, calcTextareaHeight(textarea.value, minRows, maxRows));
      } else {
        textareaCalcStyle.value = {
          minHeight: calcTextareaHeight(textarea.value).minHeight
        };
      }
    };
    const setNativeInputValue = () => {
      const input22 = _ref.value;
      if (!input22 || input22.value === nativeInputValue.value)
        return;
      input22.value = nativeInputValue.value;
    };
    const calcIconOffset = (place) => {
      const { el } = instance.vnode;
      if (!el)
        return;
      const elList = Array.from(el.querySelectorAll(`.${nsInput.e(place)}`));
      const target = elList.find((item) => item.parentNode === el);
      if (!target)
        return;
      const pendant = PENDANT_MAP[place];
      if (slots[pendant]) {
        target.style.transform = `translateX(${place === "suffix" ? "-" : ""}${el.querySelector(`.${nsInput.be("group", pendant)}`).offsetWidth}px)`;
      } else {
        target.removeAttribute("style");
      }
    };
    const updateIconOffset = () => {
      calcIconOffset("prefix");
      calcIconOffset("suffix");
    };
    const handleInput = async (event) => {
      recordCursor();
      let { value } = event.target;
      if (props.formatter) {
        value = props.parser ? props.parser(value) : value;
        value = props.formatter(value);
      }
      if (isComposing.value)
        return;
      if (value === nativeInputValue.value)
        return;
      emit(UPDATE_MODEL_EVENT, value);
      emit("input", value);
      await nextTick();
      setNativeInputValue();
      setCursor();
    };
    const handleChange = (event) => {
      emit("change", event.target.value);
    };
    const handleCompositionStart = (event) => {
      emit("compositionstart", event);
      isComposing.value = true;
    };
    const handleCompositionUpdate = (event) => {
      var _a2;
      emit("compositionupdate", event);
      const text = (_a2 = event.target) == null ? void 0 : _a2.value;
      const lastCharacter = text[text.length - 1] || "";
      isComposing.value = !isKorean(lastCharacter);
    };
    const handleCompositionEnd = (event) => {
      emit("compositionend", event);
      if (isComposing.value) {
        isComposing.value = false;
        handleInput(event);
      }
    };
    const handlePasswordVisible = () => {
      passwordVisible.value = !passwordVisible.value;
      focus();
    };
    const focus = async () => {
      var _a2;
      await nextTick();
      (_a2 = _ref.value) == null ? void 0 : _a2.focus();
    };
    const blur = () => {
      var _a2;
      return (_a2 = _ref.value) == null ? void 0 : _a2.blur();
    };
    const handleFocus = (event) => {
      focused.value = true;
      emit("focus", event);
    };
    const handleBlur = (event) => {
      var _a2;
      focused.value = false;
      emit("blur", event);
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "blur").catch((err) => debugWarn());
      }
    };
    const handleMouseLeave = (evt) => {
      hovering.value = false;
      emit("mouseleave", evt);
    };
    const handleMouseEnter = (evt) => {
      hovering.value = true;
      emit("mouseenter", evt);
    };
    const handleKeydown = (evt) => {
      emit("keydown", evt);
    };
    const select = () => {
      var _a2;
      (_a2 = _ref.value) == null ? void 0 : _a2.select();
    };
    const clear2 = () => {
      emit(UPDATE_MODEL_EVENT, "");
      emit("change", "");
      emit("clear");
      emit("input", "");
    };
    watch(() => props.modelValue, () => {
      var _a2;
      nextTick(() => resizeTextarea());
      if (props.validateEvent) {
        (_a2 = formItem == null ? void 0 : formItem.validate) == null ? void 0 : _a2.call(formItem, "change").catch((err) => debugWarn());
      }
    });
    watch(nativeInputValue, () => setNativeInputValue());
    watch(() => props.type, async () => {
      await nextTick();
      setNativeInputValue();
      resizeTextarea();
      updateIconOffset();
    });
    onMounted(async () => {
      if (!props.formatter && props.parser)
        ;
      setNativeInputValue();
      updateIconOffset();
      await nextTick();
      resizeTextarea();
    });
    onUpdated(async () => {
      await nextTick();
      updateIconOffset();
    });
    expose({
      input: input2,
      textarea,
      ref: _ref,
      textareaStyle,
      autosize: toRef(props, "autosize"),
      focus,
      blur,
      select,
      clear: clear2,
      resizeTextarea
    });
    return (_ctx, _cache) => {
      return withDirectives((openBlock(), createElementBlock("div", mergeProps(unref(containerAttrs), {
        class: [
          _ctx.type === "textarea" ? unref(nsTextarea).b() : unref(nsInput).b(),
          unref(nsInput).m(unref(inputSize)),
          unref(nsInput).is("disabled", unref(inputDisabled)),
          unref(nsInput).is("exceed", unref(inputExceed)),
          {
            [unref(nsInput).b("group")]: _ctx.$slots.prepend || _ctx.$slots.append,
            [unref(nsInput).bm("group", "append")]: _ctx.$slots.append,
            [unref(nsInput).bm("group", "prepend")]: _ctx.$slots.prepend,
            [unref(nsInput).m("prefix")]: _ctx.$slots.prefix || _ctx.prefixIcon,
            [unref(nsInput).m("suffix")]: _ctx.$slots.suffix || _ctx.suffixIcon || _ctx.clearable || _ctx.showPassword,
            [unref(nsInput).bm("suffix", "password-clear")]: unref(showClear) && unref(showPwdVisible)
          },
          _ctx.$attrs.class
        ],
        style: unref(containerStyle),
        role: _ctx.containerRole,
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave
      }), [
        createCommentVNode(" input "),
        _ctx.type !== "textarea" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createCommentVNode(" prepend slot "),
          _ctx.$slots.prepend ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(nsInput).be("group", "prepend"))
          }, [
            renderSlot(_ctx.$slots, "prepend")
          ], 2)) : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            class: normalizeClass([unref(nsInput).e("wrapper"), unref(nsInput).is("focus", focused.value)])
          }, [
            createCommentVNode(" prefix slot "),
            _ctx.$slots.prefix || _ctx.prefixIcon ? (openBlock(), createElementBlock("span", {
              key: 0,
              class: normalizeClass(unref(nsInput).e("prefix"))
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(nsInput).e("prefix-inner"))
              }, [
                renderSlot(_ctx.$slots, "prefix"),
                _ctx.prefixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 0,
                  class: normalizeClass(unref(nsInput).e("icon"))
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(_ctx.prefixIcon)))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ], 2)
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("input", mergeProps({
              id: unref(inputId),
              ref_key: "input",
              ref: input2,
              class: unref(nsInput).e("inner")
            }, unref(attrs), {
              type: _ctx.showPassword ? passwordVisible.value ? "text" : "password" : _ctx.type,
              disabled: unref(inputDisabled),
              formatter: _ctx.formatter,
              parser: _ctx.parser,
              readonly: _ctx.readonly,
              autocomplete: _ctx.autocomplete,
              tabindex: _ctx.tabindex,
              "aria-label": _ctx.label,
              placeholder: _ctx.placeholder,
              style: _ctx.inputStyle,
              onCompositionstart: handleCompositionStart,
              onCompositionupdate: handleCompositionUpdate,
              onCompositionend: handleCompositionEnd,
              onInput: handleInput,
              onFocus: handleFocus,
              onBlur: handleBlur,
              onChange: handleChange,
              onKeydown: handleKeydown
            }), null, 16, _hoisted_2$g),
            createCommentVNode(" suffix slot "),
            unref(suffixVisible) ? (openBlock(), createElementBlock("span", {
              key: 1,
              class: normalizeClass(unref(nsInput).e("suffix"))
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(nsInput).e("suffix-inner"))
              }, [
                !unref(showClear) || !unref(showPwdVisible) || !unref(isWordLimitVisible) ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                  renderSlot(_ctx.$slots, "suffix"),
                  _ctx.suffixIcon ? (openBlock(), createBlock(unref(ElIcon), {
                    key: 0,
                    class: normalizeClass(unref(nsInput).e("icon"))
                  }, {
                    default: withCtx(() => [
                      (openBlock(), createBlock(resolveDynamicComponent(_ctx.suffixIcon)))
                    ]),
                    _: 1
                  }, 8, ["class"])) : createCommentVNode("v-if", true)
                ], 64)) : createCommentVNode("v-if", true),
                unref(showClear) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 1,
                  class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("clear")]),
                  onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
                  }, ["prevent"])),
                  onClick: clear2
                }, {
                  default: withCtx(() => [
                    createVNode(unref(circle_close_default))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                unref(showPwdVisible) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 2,
                  class: normalizeClass([unref(nsInput).e("icon"), unref(nsInput).e("password")]),
                  onClick: handlePasswordVisible
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(passwordIcon))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true),
                unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
                  key: 3,
                  class: normalizeClass(unref(nsInput).e("count"))
                }, [
                  createBaseVNode("span", {
                    class: normalizeClass(unref(nsInput).e("count-inner"))
                  }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 3)
                ], 2)) : createCommentVNode("v-if", true),
                unref(validateState) && unref(validateIcon) && unref(needStatusIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                  key: 4,
                  class: normalizeClass([
                    unref(nsInput).e("icon"),
                    unref(nsInput).e("validateIcon"),
                    unref(nsInput).is("loading", unref(validateState) === "validating")
                  ])
                }, {
                  default: withCtx(() => [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(validateIcon))))
                  ]),
                  _: 1
                }, 8, ["class"])) : createCommentVNode("v-if", true)
              ], 2)
            ], 2)) : createCommentVNode("v-if", true)
          ], 2),
          createCommentVNode(" append slot "),
          _ctx.$slots.append ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(unref(nsInput).be("group", "append"))
          }, [
            renderSlot(_ctx.$slots, "append")
          ], 2)) : createCommentVNode("v-if", true)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createCommentVNode(" textarea "),
          createBaseVNode("textarea", mergeProps({
            id: unref(inputId),
            ref_key: "textarea",
            ref: textarea,
            class: unref(nsTextarea).e("inner")
          }, unref(attrs), {
            tabindex: _ctx.tabindex,
            disabled: unref(inputDisabled),
            readonly: _ctx.readonly,
            autocomplete: _ctx.autocomplete,
            style: unref(textareaStyle),
            "aria-label": _ctx.label,
            placeholder: _ctx.placeholder,
            onCompositionstart: handleCompositionStart,
            onCompositionupdate: handleCompositionUpdate,
            onCompositionend: handleCompositionEnd,
            onInput: handleInput,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onChange: handleChange,
            onKeydown: handleKeydown
          }), null, 16, _hoisted_3$9),
          unref(isWordLimitVisible) ? (openBlock(), createElementBlock("span", {
            key: 0,
            style: normalizeStyle(countStyle.value),
            class: normalizeClass(unref(nsInput).e("count"))
          }, toDisplayString(unref(textLength)) + " / " + toDisplayString(unref(attrs).maxlength), 7)) : createCommentVNode("v-if", true)
        ], 64))
      ], 16, _hoisted_1$i)), [
        [vShow, _ctx.type !== "hidden"]
      ]);
    };
  }
}));
var Input = /* @__PURE__ */ _export_sfc$1(_sfc_main$z, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/input/src/input.vue"]]);
const ElInput = withInstall(Input);
const GAP = 4;
const BAR_MAP = {
  vertical: {
    offset: "offsetHeight",
    scroll: "scrollTop",
    scrollSize: "scrollHeight",
    size: "height",
    key: "vertical",
    axis: "Y",
    client: "clientY",
    direction: "top"
  },
  horizontal: {
    offset: "offsetWidth",
    scroll: "scrollLeft",
    scrollSize: "scrollWidth",
    size: "width",
    key: "horizontal",
    axis: "X",
    client: "clientX",
    direction: "left"
  }
};
const renderThumbStyle = ({
  move,
  size: size2,
  bar
}) => ({
  [bar.size]: size2,
  transform: `translate${bar.axis}(${move}%)`
});
const thumbProps = buildProps({
  vertical: Boolean,
  size: String,
  move: Number,
  ratio: {
    type: Number,
    required: true
  },
  always: Boolean
});
const _sfc_main$y = /* @__PURE__ */ defineComponent({
  __name: "thumb",
  props: thumbProps,
  setup(__props) {
    const props = __props;
    const COMPONENT_NAME2 = "Thumb";
    const scrollbar2 = inject(scrollbarContextKey);
    const ns2 = useNamespace("scrollbar");
    if (!scrollbar2)
      throwError(COMPONENT_NAME2, "can not inject scrollbar context");
    const instance = ref();
    const thumb = ref();
    const thumbState = ref({});
    const visible = ref(false);
    let cursorDown = false;
    let cursorLeave = false;
    let originalOnSelectStart = isClient ? document.onselectstart : null;
    const bar = computed(() => BAR_MAP[props.vertical ? "vertical" : "horizontal"]);
    const thumbStyle = computed(() => renderThumbStyle({
      size: props.size,
      move: props.move,
      bar: bar.value
    }));
    const offsetRatio = computed(() => instance.value[bar.value.offset] ** 2 / scrollbar2.wrapElement[bar.value.scrollSize] / props.ratio / thumb.value[bar.value.offset]);
    const clickThumbHandler = (e) => {
      var _a2;
      e.stopPropagation();
      if (e.ctrlKey || [1, 2].includes(e.button))
        return;
      (_a2 = window.getSelection()) == null ? void 0 : _a2.removeAllRanges();
      startDrag(e);
      const el = e.currentTarget;
      if (!el)
        return;
      thumbState.value[bar.value.axis] = el[bar.value.offset] - (e[bar.value.client] - el.getBoundingClientRect()[bar.value.direction]);
    };
    const clickTrackHandler = (e) => {
      if (!thumb.value || !instance.value || !scrollbar2.wrapElement)
        return;
      const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
      const thumbHalf = thumb.value[bar.value.offset] / 2;
      const thumbPositionPercentage = (offset - thumbHalf) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar2.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar2.wrapElement[bar.value.scrollSize] / 100;
    };
    const startDrag = (e) => {
      e.stopImmediatePropagation();
      cursorDown = true;
      document.addEventListener("mousemove", mouseMoveDocumentHandler);
      document.addEventListener("mouseup", mouseUpDocumentHandler);
      originalOnSelectStart = document.onselectstart;
      document.onselectstart = () => false;
    };
    const mouseMoveDocumentHandler = (e) => {
      if (!instance.value || !thumb.value)
        return;
      if (cursorDown === false)
        return;
      const prevPage = thumbState.value[bar.value.axis];
      if (!prevPage)
        return;
      const offset = (instance.value.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
      const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
      const thumbPositionPercentage = (offset - thumbClickPosition) * 100 * offsetRatio.value / instance.value[bar.value.offset];
      scrollbar2.wrapElement[bar.value.scroll] = thumbPositionPercentage * scrollbar2.wrapElement[bar.value.scrollSize] / 100;
    };
    const mouseUpDocumentHandler = () => {
      cursorDown = false;
      thumbState.value[bar.value.axis] = 0;
      document.removeEventListener("mousemove", mouseMoveDocumentHandler);
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
      restoreOnselectstart();
      if (cursorLeave)
        visible.value = false;
    };
    const mouseMoveScrollbarHandler = () => {
      cursorLeave = false;
      visible.value = !!props.size;
    };
    const mouseLeaveScrollbarHandler = () => {
      cursorLeave = true;
      visible.value = cursorDown;
    };
    onBeforeUnmount(() => {
      restoreOnselectstart();
      document.removeEventListener("mouseup", mouseUpDocumentHandler);
    });
    const restoreOnselectstart = () => {
      if (document.onselectstart !== originalOnSelectStart)
        document.onselectstart = originalOnSelectStart;
    };
    useEventListener(toRef(scrollbar2, "scrollbarElement"), "mousemove", mouseMoveScrollbarHandler);
    useEventListener(toRef(scrollbar2, "scrollbarElement"), "mouseleave", mouseLeaveScrollbarHandler);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, {
        name: unref(ns2).b("fade"),
        persisted: ""
      }, {
        default: withCtx(() => [
          withDirectives(createBaseVNode("div", {
            ref_key: "instance",
            ref: instance,
            class: normalizeClass([unref(ns2).e("bar"), unref(ns2).is(unref(bar).key)]),
            onMousedown: clickTrackHandler
          }, [
            createBaseVNode("div", {
              ref_key: "thumb",
              ref: thumb,
              class: normalizeClass(unref(ns2).e("thumb")),
              style: normalizeStyle(unref(thumbStyle)),
              onMousedown: clickThumbHandler
            }, null, 38)
          ], 34), [
            [vShow, _ctx.always || visible.value]
          ])
        ]),
        _: 1
      }, 8, ["name"]);
    };
  }
});
var Thumb = /* @__PURE__ */ _export_sfc$1(_sfc_main$y, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/thumb.vue"]]);
const barProps = buildProps({
  always: {
    type: Boolean,
    default: true
  },
  width: String,
  height: String,
  ratioX: {
    type: Number,
    default: 1
  },
  ratioY: {
    type: Number,
    default: 1
  }
});
const _sfc_main$x = /* @__PURE__ */ defineComponent({
  __name: "bar",
  props: barProps,
  setup(__props, { expose }) {
    const props = __props;
    const moveX = ref(0);
    const moveY = ref(0);
    const handleScroll = (wrap) => {
      if (wrap) {
        const offsetHeight = wrap.offsetHeight - GAP;
        const offsetWidth = wrap.offsetWidth - GAP;
        moveY.value = wrap.scrollTop * 100 / offsetHeight * props.ratioY;
        moveX.value = wrap.scrollLeft * 100 / offsetWidth * props.ratioX;
      }
    };
    expose({
      handleScroll
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(Thumb, {
          move: moveX.value,
          ratio: _ctx.ratioX,
          size: _ctx.width,
          always: _ctx.always
        }, null, 8, ["move", "ratio", "size", "always"]),
        createVNode(Thumb, {
          move: moveY.value,
          ratio: _ctx.ratioY,
          size: _ctx.height,
          vertical: "",
          always: _ctx.always
        }, null, 8, ["move", "ratio", "size", "always"])
      ], 64);
    };
  }
});
var Bar = /* @__PURE__ */ _export_sfc$1(_sfc_main$x, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/bar.vue"]]);
const scrollbarProps = buildProps({
  height: {
    type: [String, Number],
    default: ""
  },
  maxHeight: {
    type: [String, Number],
    default: ""
  },
  native: Boolean,
  wrapStyle: {
    type: definePropType([String, Object, Array]),
    default: ""
  },
  wrapClass: {
    type: [String, Array],
    default: ""
  },
  viewClass: {
    type: [String, Array],
    default: ""
  },
  viewStyle: {
    type: [String, Array, Object],
    default: ""
  },
  noresize: Boolean,
  tag: {
    type: String,
    default: "div"
  },
  always: Boolean,
  minSize: {
    type: Number,
    default: 20
  }
});
const scrollbarEmits = {
  scroll: ({
    scrollTop,
    scrollLeft
  }) => isNumber(scrollTop) && isNumber(scrollLeft)
};
const __default__$b = {
  name: "ElScrollbar"
};
const _sfc_main$w = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$b), {
  props: scrollbarProps,
  emits: scrollbarEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("scrollbar");
    let stopResizeObserver = void 0;
    let stopResizeListener = void 0;
    const scrollbar$ = ref();
    const wrap$ = ref();
    const resize$ = ref();
    const sizeWidth = ref("0");
    const sizeHeight = ref("0");
    const barRef = ref();
    const ratioY = ref(1);
    const ratioX = ref(1);
    const style = computed(() => {
      const style2 = {};
      if (props.height)
        style2.height = addUnit(props.height);
      if (props.maxHeight)
        style2.maxHeight = addUnit(props.maxHeight);
      return [props.wrapStyle, style2];
    });
    const handleScroll = () => {
      var _a2;
      if (wrap$.value) {
        (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrap$.value);
        emit("scroll", {
          scrollTop: wrap$.value.scrollTop,
          scrollLeft: wrap$.value.scrollLeft
        });
      }
    };
    function scrollTo(arg1, arg2) {
      if (isObject$1(arg1)) {
        wrap$.value.scrollTo(arg1);
      } else if (isNumber(arg1) && isNumber(arg2)) {
        wrap$.value.scrollTo(arg1, arg2);
      }
    }
    const setScrollTop = (value) => {
      if (!isNumber(value)) {
        return;
      }
      wrap$.value.scrollTop = value;
    };
    const setScrollLeft = (value) => {
      if (!isNumber(value)) {
        return;
      }
      wrap$.value.scrollLeft = value;
    };
    const update = () => {
      if (!wrap$.value)
        return;
      const offsetHeight = wrap$.value.offsetHeight - GAP;
      const offsetWidth = wrap$.value.offsetWidth - GAP;
      const originalHeight = offsetHeight ** 2 / wrap$.value.scrollHeight;
      const originalWidth = offsetWidth ** 2 / wrap$.value.scrollWidth;
      const height = Math.max(originalHeight, props.minSize);
      const width = Math.max(originalWidth, props.minSize);
      ratioY.value = originalHeight / (offsetHeight - originalHeight) / (height / (offsetHeight - height));
      ratioX.value = originalWidth / (offsetWidth - originalWidth) / (width / (offsetWidth - width));
      sizeHeight.value = height + GAP < offsetHeight ? `${height}px` : "";
      sizeWidth.value = width + GAP < offsetWidth ? `${width}px` : "";
    };
    watch(() => props.noresize, (noresize) => {
      if (noresize) {
        stopResizeObserver == null ? void 0 : stopResizeObserver();
        stopResizeListener == null ? void 0 : stopResizeListener();
      } else {
        ({ stop: stopResizeObserver } = useResizeObserver(resize$, update));
        stopResizeListener = useEventListener("resize", update);
      }
    }, { immediate: true });
    watch(() => [props.maxHeight, props.height], () => {
      if (!props.native)
        nextTick(() => {
          var _a2;
          update();
          if (wrap$.value) {
            (_a2 = barRef.value) == null ? void 0 : _a2.handleScroll(wrap$.value);
          }
        });
    });
    provide(scrollbarContextKey, reactive({
      scrollbarElement: scrollbar$,
      wrapElement: wrap$
    }));
    onMounted(() => {
      if (!props.native)
        nextTick(() => update());
    });
    onUpdated(() => update());
    expose({
      wrap$,
      update,
      scrollTo,
      setScrollTop,
      setScrollLeft,
      handleScroll
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "scrollbar$",
        ref: scrollbar$,
        class: normalizeClass(unref(ns2).b())
      }, [
        createBaseVNode("div", {
          ref_key: "wrap$",
          ref: wrap$,
          class: normalizeClass([
            _ctx.wrapClass,
            unref(ns2).e("wrap"),
            { [unref(ns2).em("wrap", "hidden-default")]: !_ctx.native }
          ]),
          style: normalizeStyle(unref(style)),
          onScroll: handleScroll
        }, [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.tag), {
            ref_key: "resize$",
            ref: resize$,
            class: normalizeClass([unref(ns2).e("view"), _ctx.viewClass]),
            style: normalizeStyle(_ctx.viewStyle)
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["class", "style"]))
        ], 38),
        !_ctx.native ? (openBlock(), createBlock(Bar, {
          key: 0,
          ref_key: "barRef",
          ref: barRef,
          height: sizeHeight.value,
          width: sizeWidth.value,
          always: _ctx.always,
          "ratio-x": ratioX.value,
          "ratio-y": ratioY.value
        }, null, 8, ["height", "width", "always", "ratio-x", "ratio-y"])) : createCommentVNode("v-if", true)
      ], 2);
    };
  }
}));
var Scrollbar = /* @__PURE__ */ _export_sfc$1(_sfc_main$w, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/scrollbar/src/scrollbar.vue"]]);
const ElScrollbar = withInstall(Scrollbar);
const Effect = {
  LIGHT: "light",
  DARK: "dark"
};
const usePopperProps = buildProps({
  role: {
    type: String,
    default: "tooltip"
  }
});
const __default__$a = {
  name: "ElPopperRoot",
  inheritAttrs: false
};
const _sfc_main$v = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$a), {
  props: usePopperProps,
  setup(__props, { expose }) {
    const props = __props;
    const triggerRef2 = ref();
    const popperInstanceRef = ref();
    const contentRef = ref();
    const referenceRef = ref();
    const role = computed(() => props.role);
    const popperProvides = {
      triggerRef: triggerRef2,
      popperInstanceRef,
      contentRef,
      referenceRef,
      role
    };
    expose(popperProvides);
    provide(POPPER_INJECTION_KEY, popperProvides);
    return (_ctx, _cache) => {
      return renderSlot(_ctx.$slots, "default");
    };
  }
}));
var Popper = /* @__PURE__ */ _export_sfc$1(_sfc_main$v, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/popper.vue"]]);
const usePopperArrowProps = buildProps({
  arrowOffset: {
    type: Number,
    default: 5
  }
});
const __default__$9 = {
  name: "ElPopperArrow",
  inheritAttrs: false
};
const _sfc_main$u = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$9), {
  props: usePopperArrowProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("popper");
    const { arrowOffset, arrowRef } = inject(POPPER_CONTENT_INJECTION_KEY, void 0);
    watch(() => props.arrowOffset, (val) => {
      arrowOffset.value = val;
    });
    onBeforeUnmount(() => {
      arrowRef.value = void 0;
    });
    expose({
      arrowRef
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("span", {
        ref_key: "arrowRef",
        ref: arrowRef,
        class: normalizeClass(unref(ns2).e("arrow")),
        "data-popper-arrow": ""
      }, null, 2);
    };
  }
}));
var ElPopperArrow = /* @__PURE__ */ _export_sfc$1(_sfc_main$u, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue"]]);
const NAME = "ElOnlyChild";
const OnlyChild = defineComponent({
  name: NAME,
  setup(_, {
    slots,
    attrs
  }) {
    var _a2;
    const forwardRefInjection = inject(FORWARD_REF_INJECTION_KEY);
    const forwardRefDirective = useForwardRefDirective((_a2 = forwardRefInjection == null ? void 0 : forwardRefInjection.setForwardRef) != null ? _a2 : NOOP);
    return () => {
      var _a22;
      const defaultSlot = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, attrs);
      if (!defaultSlot)
        return null;
      if (defaultSlot.length > 1) {
        return null;
      }
      const firstLegitNode = findFirstLegitChild(defaultSlot);
      if (!firstLegitNode) {
        return null;
      }
      return withDirectives(cloneVNode(firstLegitNode, attrs), [[forwardRefDirective]]);
    };
  }
});
function findFirstLegitChild(node) {
  if (!node)
    return null;
  const children = node;
  for (const child of children) {
    if (isObject$1(child)) {
      switch (child.type) {
        case Comment:
          continue;
        case Text:
          return wrapTextContent(child);
        case "svg":
          return wrapTextContent(child);
        case Fragment:
          return findFirstLegitChild(child.children);
        default:
          return child;
      }
    }
    return wrapTextContent(child);
  }
  return null;
}
function wrapTextContent(s) {
  return createVNode("span", {
    "class": "el-only-child__content"
  }, [s]);
}
const usePopperTriggerProps = buildProps({
  virtualRef: {
    type: definePropType(Object)
  },
  virtualTriggering: Boolean,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function,
  onKeydown: Function,
  onFocus: Function,
  onBlur: Function,
  onContextmenu: Function,
  id: String,
  open: Boolean
});
const __default__$8 = {
  name: "ElPopperTrigger",
  inheritAttrs: false
};
const _sfc_main$t = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$8), {
  props: usePopperTriggerProps,
  setup(__props, { expose }) {
    const props = __props;
    const { role, triggerRef: triggerRef2 } = inject(POPPER_INJECTION_KEY, void 0);
    useForwardRef(triggerRef2);
    const ariaControls = computed(() => {
      return ariaHaspopup.value ? props.id : void 0;
    });
    const ariaDescribedby = computed(() => {
      if (role && role.value === "tooltip") {
        return props.open && props.id ? props.id : void 0;
      }
      return void 0;
    });
    const ariaHaspopup = computed(() => {
      if (role && role.value !== "tooltip") {
        return role.value;
      }
      return void 0;
    });
    const ariaExpanded = computed(() => {
      return ariaHaspopup.value ? `${props.open}` : void 0;
    });
    let virtualTriggerAriaStopWatch = void 0;
    onMounted(() => {
      watch(() => props.virtualRef, (virtualEl) => {
        if (virtualEl) {
          triggerRef2.value = unrefElement(virtualEl);
        }
      }, {
        immediate: true
      });
      watch(() => triggerRef2.value, (el, prevEl) => {
        virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
        virtualTriggerAriaStopWatch = void 0;
        if (isElement(el)) {
          [
            "onMouseenter",
            "onMouseleave",
            "onClick",
            "onKeydown",
            "onFocus",
            "onBlur",
            "onContextmenu"
          ].forEach((eventName) => {
            var _a2;
            const handler = props[eventName];
            if (handler) {
              el.addEventListener(eventName.slice(2).toLowerCase(), handler);
              (_a2 = prevEl == null ? void 0 : prevEl.removeEventListener) == null ? void 0 : _a2.call(prevEl, eventName.slice(2).toLowerCase(), handler);
            }
          });
          virtualTriggerAriaStopWatch = watch([ariaControls, ariaDescribedby, ariaHaspopup, ariaExpanded], (watches) => {
            [
              "aria-controls",
              "aria-describedby",
              "aria-haspopup",
              "aria-expanded"
            ].forEach((key, idx) => {
              isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
            });
          }, { immediate: true });
        }
        if (isElement(prevEl)) {
          [
            "aria-controls",
            "aria-describedby",
            "aria-haspopup",
            "aria-expanded"
          ].forEach((key) => prevEl.removeAttribute(key));
        }
      }, {
        immediate: true
      });
    });
    onBeforeUnmount(() => {
      virtualTriggerAriaStopWatch == null ? void 0 : virtualTriggerAriaStopWatch();
      virtualTriggerAriaStopWatch = void 0;
    });
    expose({
      triggerRef: triggerRef2
    });
    return (_ctx, _cache) => {
      return !_ctx.virtualTriggering ? (openBlock(), createBlock(unref(OnlyChild), mergeProps({ key: 0 }, _ctx.$attrs, {
        "aria-controls": unref(ariaControls),
        "aria-describedby": unref(ariaDescribedby),
        "aria-expanded": unref(ariaExpanded),
        "aria-haspopup": unref(ariaHaspopup)
      }), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["aria-controls", "aria-describedby", "aria-expanded", "aria-haspopup"])) : createCommentVNode("v-if", true);
    };
  }
}));
var ElPopperTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$t, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/trigger.vue"]]);
var E = "top", R = "bottom", W = "right", P = "left", me = "auto", G = [E, R, W, P], U = "start", J = "end", Xe = "clippingParents", je = "viewport", K = "popper", Ye = "reference", De = G.reduce(function(t, e) {
  return t.concat([e + "-" + U, e + "-" + J]);
}, []), Ee = [].concat(G, [me]).reduce(function(t, e) {
  return t.concat([e, e + "-" + U, e + "-" + J]);
}, []), Ge = "beforeRead", Je = "read", Ke = "afterRead", Qe = "beforeMain", Ze = "main", et = "afterMain", tt = "beforeWrite", nt = "write", rt = "afterWrite", ot = [Ge, Je, Ke, Qe, Ze, et, tt, nt, rt];
function C(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function H(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function Q(t) {
  var e = H(t).Element;
  return t instanceof e || t instanceof Element;
}
function B(t) {
  var e = H(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function Pe(t) {
  if (typeof ShadowRoot == "undefined")
    return false;
  var e = H(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function Mt(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(n) {
    var r = e.styles[n] || {}, o = e.attributes[n] || {}, i = e.elements[n];
    !B(i) || !C(i) || (Object.assign(i.style, r), Object.keys(o).forEach(function(a) {
      var s = o[a];
      s === false ? i.removeAttribute(a) : i.setAttribute(a, s === true ? "" : s);
    }));
  });
}
function Rt(t) {
  var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
  return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function() {
    Object.keys(e.elements).forEach(function(r) {
      var o = e.elements[r], i = e.attributes[r] || {}, a = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : n[r]), s = a.reduce(function(f, c) {
        return f[c] = "", f;
      }, {});
      !B(o) || !C(o) || (Object.assign(o.style, s), Object.keys(i).forEach(function(f) {
        o.removeAttribute(f);
      }));
    });
  };
}
var Ae = { name: "applyStyles", enabled: true, phase: "write", fn: Mt, effect: Rt, requires: ["computeStyles"] };
function q(t) {
  return t.split("-")[0];
}
var X = Math.max, ve = Math.min, Z = Math.round;
function ee(t, e) {
  e === void 0 && (e = false);
  var n = t.getBoundingClientRect(), r = 1, o = 1;
  if (B(t) && e) {
    var i = t.offsetHeight, a = t.offsetWidth;
    a > 0 && (r = Z(n.width) / a || 1), i > 0 && (o = Z(n.height) / i || 1);
  }
  return { width: n.width / r, height: n.height / o, top: n.top / o, right: n.right / r, bottom: n.bottom / o, left: n.left / r, x: n.left / r, y: n.top / o };
}
function ke(t) {
  var e = ee(t), n = t.offsetWidth, r = t.offsetHeight;
  return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: r };
}
function it(t, e) {
  var n = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return true;
  if (n && Pe(n)) {
    var r = e;
    do {
      if (r && t.isSameNode(r))
        return true;
      r = r.parentNode || r.host;
    } while (r);
  }
  return false;
}
function N(t) {
  return H(t).getComputedStyle(t);
}
function Wt(t) {
  return ["table", "td", "th"].indexOf(C(t)) >= 0;
}
function I(t) {
  return ((Q(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function ge(t) {
  return C(t) === "html" ? t : t.assignedSlot || t.parentNode || (Pe(t) ? t.host : null) || I(t);
}
function at(t) {
  return !B(t) || N(t).position === "fixed" ? null : t.offsetParent;
}
function Bt(t) {
  var e = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1, n = navigator.userAgent.indexOf("Trident") !== -1;
  if (n && B(t)) {
    var r = N(t);
    if (r.position === "fixed")
      return null;
  }
  var o = ge(t);
  for (Pe(o) && (o = o.host); B(o) && ["html", "body"].indexOf(C(o)) < 0; ) {
    var i = N(o);
    if (i.transform !== "none" || i.perspective !== "none" || i.contain === "paint" || ["transform", "perspective"].indexOf(i.willChange) !== -1 || e && i.willChange === "filter" || e && i.filter && i.filter !== "none")
      return o;
    o = o.parentNode;
  }
  return null;
}
function se(t) {
  for (var e = H(t), n = at(t); n && Wt(n) && N(n).position === "static"; )
    n = at(n);
  return n && (C(n) === "html" || C(n) === "body" && N(n).position === "static") ? e : n || Bt(t) || e;
}
function Le(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function fe(t, e, n) {
  return X(t, ve(e, n));
}
function St(t, e, n) {
  var r = fe(t, e, n);
  return r > n ? n : r;
}
function st() {
  return { top: 0, right: 0, bottom: 0, left: 0 };
}
function ft(t) {
  return Object.assign({}, st(), t);
}
function ct(t, e) {
  return e.reduce(function(n, r) {
    return n[r] = t, n;
  }, {});
}
var Tt = function(t, e) {
  return t = typeof t == "function" ? t(Object.assign({}, e.rects, { placement: e.placement })) : t, ft(typeof t != "number" ? t : ct(t, G));
};
function Ht(t) {
  var e, n = t.state, r = t.name, o = t.options, i = n.elements.arrow, a = n.modifiersData.popperOffsets, s = q(n.placement), f = Le(s), c = [P, W].indexOf(s) >= 0, u = c ? "height" : "width";
  if (!(!i || !a)) {
    var m = Tt(o.padding, n), v = ke(i), l = f === "y" ? E : P, h2 = f === "y" ? R : W, p2 = n.rects.reference[u] + n.rects.reference[f] - a[f] - n.rects.popper[u], g = a[f] - n.rects.reference[f], x = se(i), y = x ? f === "y" ? x.clientHeight || 0 : x.clientWidth || 0 : 0, $ = p2 / 2 - g / 2, d = m[l], b = y - v[u] - m[h2], w = y / 2 - v[u] / 2 + $, O = fe(d, w, b), j = f;
    n.modifiersData[r] = (e = {}, e[j] = O, e.centerOffset = O - w, e);
  }
}
function Ct(t) {
  var e = t.state, n = t.options, r = n.element, o = r === void 0 ? "[data-popper-arrow]" : r;
  o != null && (typeof o == "string" && (o = e.elements.popper.querySelector(o), !o) || !it(e.elements.popper, o) || (e.elements.arrow = o));
}
var pt = { name: "arrow", enabled: true, phase: "main", fn: Ht, effect: Ct, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
function te(t) {
  return t.split("-")[1];
}
var qt = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
function Vt(t) {
  var e = t.x, n = t.y, r = window, o = r.devicePixelRatio || 1;
  return { x: Z(e * o) / o || 0, y: Z(n * o) / o || 0 };
}
function ut(t) {
  var e, n = t.popper, r = t.popperRect, o = t.placement, i = t.variation, a = t.offsets, s = t.position, f = t.gpuAcceleration, c = t.adaptive, u = t.roundOffsets, m = t.isFixed, v = a.x, l = v === void 0 ? 0 : v, h2 = a.y, p2 = h2 === void 0 ? 0 : h2, g = typeof u == "function" ? u({ x: l, y: p2 }) : { x: l, y: p2 };
  l = g.x, p2 = g.y;
  var x = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), $ = P, d = E, b = window;
  if (c) {
    var w = se(n), O = "clientHeight", j = "clientWidth";
    if (w === H(n) && (w = I(n), N(w).position !== "static" && s === "absolute" && (O = "scrollHeight", j = "scrollWidth")), w = w, o === E || (o === P || o === W) && i === J) {
      d = R;
      var A = m && w === b && b.visualViewport ? b.visualViewport.height : w[O];
      p2 -= A - r.height, p2 *= f ? 1 : -1;
    }
    if (o === P || (o === E || o === R) && i === J) {
      $ = W;
      var k = m && w === b && b.visualViewport ? b.visualViewport.width : w[j];
      l -= k - r.width, l *= f ? 1 : -1;
    }
  }
  var D = Object.assign({ position: s }, c && qt), S = u === true ? Vt({ x: l, y: p2 }) : { x: l, y: p2 };
  if (l = S.x, p2 = S.y, f) {
    var L;
    return Object.assign({}, D, (L = {}, L[d] = y ? "0" : "", L[$] = x ? "0" : "", L.transform = (b.devicePixelRatio || 1) <= 1 ? "translate(" + l + "px, " + p2 + "px)" : "translate3d(" + l + "px, " + p2 + "px, 0)", L));
  }
  return Object.assign({}, D, (e = {}, e[d] = y ? p2 + "px" : "", e[$] = x ? l + "px" : "", e.transform = "", e));
}
function Nt(t) {
  var e = t.state, n = t.options, r = n.gpuAcceleration, o = r === void 0 ? true : r, i = n.adaptive, a = i === void 0 ? true : i, s = n.roundOffsets, f = s === void 0 ? true : s, c = { placement: q(e.placement), variation: te(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: o, isFixed: e.options.strategy === "fixed" };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, ut(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: f })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, ut(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: f })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement });
}
var Me = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: Nt, data: {} }, ye = { passive: true };
function It(t) {
  var e = t.state, n = t.instance, r = t.options, o = r.scroll, i = o === void 0 ? true : o, a = r.resize, s = a === void 0 ? true : a, f = H(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return i && c.forEach(function(u) {
    u.addEventListener("scroll", n.update, ye);
  }), s && f.addEventListener("resize", n.update, ye), function() {
    i && c.forEach(function(u) {
      u.removeEventListener("scroll", n.update, ye);
    }), s && f.removeEventListener("resize", n.update, ye);
  };
}
var Re = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
}, effect: It, data: {} }, _t = { left: "right", right: "left", bottom: "top", top: "bottom" };
function be(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return _t[e];
  });
}
var zt = { start: "end", end: "start" };
function lt(t) {
  return t.replace(/start|end/g, function(e) {
    return zt[e];
  });
}
function We(t) {
  var e = H(t), n = e.pageXOffset, r = e.pageYOffset;
  return { scrollLeft: n, scrollTop: r };
}
function Be(t) {
  return ee(I(t)).left + We(t).scrollLeft;
}
function Ft(t) {
  var e = H(t), n = I(t), r = e.visualViewport, o = n.clientWidth, i = n.clientHeight, a = 0, s = 0;
  return r && (o = r.width, i = r.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (a = r.offsetLeft, s = r.offsetTop)), { width: o, height: i, x: a + Be(t), y: s };
}
function Ut(t) {
  var e, n = I(t), r = We(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, i = X(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), a = X(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), s = -r.scrollLeft + Be(t), f = -r.scrollTop;
  return N(o || n).direction === "rtl" && (s += X(n.clientWidth, o ? o.clientWidth : 0) - i), { width: i, height: a, x: s, y: f };
}
function Se(t) {
  var e = N(t), n = e.overflow, r = e.overflowX, o = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(n + o + r);
}
function dt(t) {
  return ["html", "body", "#document"].indexOf(C(t)) >= 0 ? t.ownerDocument.body : B(t) && Se(t) ? t : dt(ge(t));
}
function ce(t, e) {
  var n;
  e === void 0 && (e = []);
  var r = dt(t), o = r === ((n = t.ownerDocument) == null ? void 0 : n.body), i = H(r), a = o ? [i].concat(i.visualViewport || [], Se(r) ? r : []) : r, s = e.concat(a);
  return o ? s : s.concat(ce(ge(a)));
}
function Te(t) {
  return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height });
}
function Xt(t) {
  var e = ee(t);
  return e.top = e.top + t.clientTop, e.left = e.left + t.clientLeft, e.bottom = e.top + t.clientHeight, e.right = e.left + t.clientWidth, e.width = t.clientWidth, e.height = t.clientHeight, e.x = e.left, e.y = e.top, e;
}
function ht(t, e) {
  return e === je ? Te(Ft(t)) : Q(e) ? Xt(e) : Te(Ut(I(t)));
}
function Yt(t) {
  var e = ce(ge(t)), n = ["absolute", "fixed"].indexOf(N(t).position) >= 0, r = n && B(t) ? se(t) : t;
  return Q(r) ? e.filter(function(o) {
    return Q(o) && it(o, r) && C(o) !== "body";
  }) : [];
}
function Gt(t, e, n) {
  var r = e === "clippingParents" ? Yt(t) : [].concat(e), o = [].concat(r, [n]), i = o[0], a = o.reduce(function(s, f) {
    var c = ht(t, f);
    return s.top = X(c.top, s.top), s.right = ve(c.right, s.right), s.bottom = ve(c.bottom, s.bottom), s.left = X(c.left, s.left), s;
  }, ht(t, i));
  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;
}
function mt(t) {
  var e = t.reference, n = t.element, r = t.placement, o = r ? q(r) : null, i = r ? te(r) : null, a = e.x + e.width / 2 - n.width / 2, s = e.y + e.height / 2 - n.height / 2, f;
  switch (o) {
    case E:
      f = { x: a, y: e.y - n.height };
      break;
    case R:
      f = { x: a, y: e.y + e.height };
      break;
    case W:
      f = { x: e.x + e.width, y: s };
      break;
    case P:
      f = { x: e.x - n.width, y: s };
      break;
    default:
      f = { x: e.x, y: e.y };
  }
  var c = o ? Le(o) : null;
  if (c != null) {
    var u = c === "y" ? "height" : "width";
    switch (i) {
      case U:
        f[c] = f[c] - (e[u] / 2 - n[u] / 2);
        break;
      case J:
        f[c] = f[c] + (e[u] / 2 - n[u] / 2);
        break;
    }
  }
  return f;
}
function ne(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, o = r === void 0 ? t.placement : r, i = n.boundary, a = i === void 0 ? Xe : i, s = n.rootBoundary, f = s === void 0 ? je : s, c = n.elementContext, u = c === void 0 ? K : c, m = n.altBoundary, v = m === void 0 ? false : m, l = n.padding, h2 = l === void 0 ? 0 : l, p2 = ft(typeof h2 != "number" ? h2 : ct(h2, G)), g = u === K ? Ye : K, x = t.rects.popper, y = t.elements[v ? g : u], $ = Gt(Q(y) ? y : y.contextElement || I(t.elements.popper), a, f), d = ee(t.elements.reference), b = mt({ reference: d, element: x, strategy: "absolute", placement: o }), w = Te(Object.assign({}, x, b)), O = u === K ? w : d, j = { top: $.top - O.top + p2.top, bottom: O.bottom - $.bottom + p2.bottom, left: $.left - O.left + p2.left, right: O.right - $.right + p2.right }, A = t.modifiersData.offset;
  if (u === K && A) {
    var k = A[o];
    Object.keys(j).forEach(function(D) {
      var S = [W, R].indexOf(D) >= 0 ? 1 : -1, L = [E, R].indexOf(D) >= 0 ? "y" : "x";
      j[D] += k[L] * S;
    });
  }
  return j;
}
function Jt(t, e) {
  e === void 0 && (e = {});
  var n = e, r = n.placement, o = n.boundary, i = n.rootBoundary, a = n.padding, s = n.flipVariations, f = n.allowedAutoPlacements, c = f === void 0 ? Ee : f, u = te(r), m = u ? s ? De : De.filter(function(h2) {
    return te(h2) === u;
  }) : G, v = m.filter(function(h2) {
    return c.indexOf(h2) >= 0;
  });
  v.length === 0 && (v = m);
  var l = v.reduce(function(h2, p2) {
    return h2[p2] = ne(t, { placement: p2, boundary: o, rootBoundary: i, padding: a })[q(p2)], h2;
  }, {});
  return Object.keys(l).sort(function(h2, p2) {
    return l[h2] - l[p2];
  });
}
function Kt(t) {
  if (q(t) === me)
    return [];
  var e = be(t);
  return [lt(t), e, lt(e)];
}
function Qt(t) {
  var e = t.state, n = t.options, r = t.name;
  if (!e.modifiersData[r]._skip) {
    for (var o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? true : a, f = n.fallbackPlacements, c = n.padding, u = n.boundary, m = n.rootBoundary, v = n.altBoundary, l = n.flipVariations, h2 = l === void 0 ? true : l, p2 = n.allowedAutoPlacements, g = e.options.placement, x = q(g), y = x === g, $ = f || (y || !h2 ? [be(g)] : Kt(g)), d = [g].concat($).reduce(function(z, V) {
      return z.concat(q(V) === me ? Jt(e, { placement: V, boundary: u, rootBoundary: m, padding: c, flipVariations: h2, allowedAutoPlacements: p2 }) : V);
    }, []), b = e.rects.reference, w = e.rects.popper, O = /* @__PURE__ */ new Map(), j = true, A = d[0], k = 0; k < d.length; k++) {
      var D = d[k], S = q(D), L = te(D) === U, re = [E, R].indexOf(S) >= 0, oe = re ? "width" : "height", M = ne(e, { placement: D, boundary: u, rootBoundary: m, altBoundary: v, padding: c }), T = re ? L ? W : P : L ? R : E;
      b[oe] > w[oe] && (T = be(T));
      var pe = be(T), _ = [];
      if (i && _.push(M[S] <= 0), s && _.push(M[T] <= 0, M[pe] <= 0), _.every(function(z) {
        return z;
      })) {
        A = D, j = false;
        break;
      }
      O.set(D, _);
    }
    if (j)
      for (var ue = h2 ? 3 : 1, xe = function(z) {
        var V = d.find(function(de) {
          var ae = O.get(de);
          if (ae)
            return ae.slice(0, z).every(function(Y) {
              return Y;
            });
        });
        if (V)
          return A = V, "break";
      }, ie = ue; ie > 0; ie--) {
        var le = xe(ie);
        if (le === "break")
          break;
      }
    e.placement !== A && (e.modifiersData[r]._skip = true, e.placement = A, e.reset = true);
  }
}
var vt = { name: "flip", enabled: true, phase: "main", fn: Qt, requiresIfExists: ["offset"], data: { _skip: false } };
function gt(t, e, n) {
  return n === void 0 && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x };
}
function yt(t) {
  return [E, W, R, P].some(function(e) {
    return t[e] >= 0;
  });
}
function Zt(t) {
  var e = t.state, n = t.name, r = e.rects.reference, o = e.rects.popper, i = e.modifiersData.preventOverflow, a = ne(e, { elementContext: "reference" }), s = ne(e, { altBoundary: true }), f = gt(a, r), c = gt(s, o, i), u = yt(f), m = yt(c);
  e.modifiersData[n] = { referenceClippingOffsets: f, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: m }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": m });
}
var bt = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: Zt };
function en(t, e, n) {
  var r = q(t), o = [P, E].indexOf(r) >= 0 ? -1 : 1, i = typeof n == "function" ? n(Object.assign({}, e, { placement: t })) : n, a = i[0], s = i[1];
  return a = a || 0, s = (s || 0) * o, [P, W].indexOf(r) >= 0 ? { x: s, y: a } : { x: a, y: s };
}
function tn(t) {
  var e = t.state, n = t.options, r = t.name, o = n.offset, i = o === void 0 ? [0, 0] : o, a = Ee.reduce(function(u, m) {
    return u[m] = en(m, e.rects, i), u;
  }, {}), s = a[e.placement], f = s.x, c = s.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += f, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = a;
}
var wt = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: tn };
function nn(t) {
  var e = t.state, n = t.name;
  e.modifiersData[n] = mt({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement });
}
var He = { name: "popperOffsets", enabled: true, phase: "read", fn: nn, data: {} };
function rn(t) {
  return t === "x" ? "y" : "x";
}
function on(t) {
  var e = t.state, n = t.options, r = t.name, o = n.mainAxis, i = o === void 0 ? true : o, a = n.altAxis, s = a === void 0 ? false : a, f = n.boundary, c = n.rootBoundary, u = n.altBoundary, m = n.padding, v = n.tether, l = v === void 0 ? true : v, h2 = n.tetherOffset, p2 = h2 === void 0 ? 0 : h2, g = ne(e, { boundary: f, rootBoundary: c, padding: m, altBoundary: u }), x = q(e.placement), y = te(e.placement), $ = !y, d = Le(x), b = rn(d), w = e.modifiersData.popperOffsets, O = e.rects.reference, j = e.rects.popper, A = typeof p2 == "function" ? p2(Object.assign({}, e.rects, { placement: e.placement })) : p2, k = typeof A == "number" ? { mainAxis: A, altAxis: A } : Object.assign({ mainAxis: 0, altAxis: 0 }, A), D = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, S = { x: 0, y: 0 };
  if (w) {
    if (i) {
      var L, re = d === "y" ? E : P, oe = d === "y" ? R : W, M = d === "y" ? "height" : "width", T = w[d], pe = T + g[re], _ = T - g[oe], ue = l ? -j[M] / 2 : 0, xe = y === U ? O[M] : j[M], ie = y === U ? -j[M] : -O[M], le = e.elements.arrow, z = l && le ? ke(le) : { width: 0, height: 0 }, V = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : st(), de = V[re], ae = V[oe], Y = fe(0, O[M], z[M]), jt = $ ? O[M] / 2 - ue - Y - de - k.mainAxis : xe - Y - de - k.mainAxis, Dt = $ ? -O[M] / 2 + ue + Y + ae + k.mainAxis : ie + Y + ae + k.mainAxis, Oe = e.elements.arrow && se(e.elements.arrow), Et = Oe ? d === "y" ? Oe.clientTop || 0 : Oe.clientLeft || 0 : 0, Ce = (L = D == null ? void 0 : D[d]) != null ? L : 0, Pt = T + jt - Ce - Et, At = T + Dt - Ce, qe = fe(l ? ve(pe, Pt) : pe, T, l ? X(_, At) : _);
      w[d] = qe, S[d] = qe - T;
    }
    if (s) {
      var Ve, kt = d === "x" ? E : P, Lt = d === "x" ? R : W, F = w[b], he = b === "y" ? "height" : "width", Ne = F + g[kt], Ie = F - g[Lt], $e = [E, P].indexOf(x) !== -1, _e = (Ve = D == null ? void 0 : D[b]) != null ? Ve : 0, ze = $e ? Ne : F - O[he] - j[he] - _e + k.altAxis, Fe = $e ? F + O[he] + j[he] - _e - k.altAxis : Ie, Ue = l && $e ? St(ze, F, Fe) : fe(l ? ze : Ne, F, l ? Fe : Ie);
      w[b] = Ue, S[b] = Ue - F;
    }
    e.modifiersData[r] = S;
  }
}
var xt = { name: "preventOverflow", enabled: true, phase: "main", fn: on, requiresIfExists: ["offset"] };
function an(t) {
  return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop };
}
function sn(t) {
  return t === H(t) || !B(t) ? We(t) : an(t);
}
function fn(t) {
  var e = t.getBoundingClientRect(), n = Z(e.width) / t.offsetWidth || 1, r = Z(e.height) / t.offsetHeight || 1;
  return n !== 1 || r !== 1;
}
function cn(t, e, n) {
  n === void 0 && (n = false);
  var r = B(e), o = B(e) && fn(e), i = I(e), a = ee(t, o), s = { scrollLeft: 0, scrollTop: 0 }, f = { x: 0, y: 0 };
  return (r || !r && !n) && ((C(e) !== "body" || Se(i)) && (s = sn(e)), B(e) ? (f = ee(e, true), f.x += e.clientLeft, f.y += e.clientTop) : i && (f.x = Be(i))), { x: a.left + s.scrollLeft - f.x, y: a.top + s.scrollTop - f.y, width: a.width, height: a.height };
}
function pn(t) {
  var e = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set(), r = [];
  t.forEach(function(i) {
    e.set(i.name, i);
  });
  function o(i) {
    n.add(i.name);
    var a = [].concat(i.requires || [], i.requiresIfExists || []);
    a.forEach(function(s) {
      if (!n.has(s)) {
        var f = e.get(s);
        f && o(f);
      }
    }), r.push(i);
  }
  return t.forEach(function(i) {
    n.has(i.name) || o(i);
  }), r;
}
function un(t) {
  var e = pn(t);
  return ot.reduce(function(n, r) {
    return n.concat(e.filter(function(o) {
      return o.phase === r;
    }));
  }, []);
}
function ln(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(n) {
      Promise.resolve().then(function() {
        e = void 0, n(t());
      });
    })), e;
  };
}
function dn(t) {
  var e = t.reduce(function(n, r) {
    var o = n[r.name];
    return n[r.name] = o ? Object.assign({}, o, r, { options: Object.assign({}, o.options, r.options), data: Object.assign({}, o.data, r.data) }) : r, n;
  }, {});
  return Object.keys(e).map(function(n) {
    return e[n];
  });
}
var Ot = { placement: "bottom", modifiers: [], strategy: "absolute" };
function $t() {
  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
    e[n] = arguments[n];
  return !e.some(function(r) {
    return !(r && typeof r.getBoundingClientRect == "function");
  });
}
function we(t) {
  t === void 0 && (t = {});
  var e = t, n = e.defaultModifiers, r = n === void 0 ? [] : n, o = e.defaultOptions, i = o === void 0 ? Ot : o;
  return function(a, s, f) {
    f === void 0 && (f = i);
    var c = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Ot, i), modifiersData: {}, elements: { reference: a, popper: s }, attributes: {}, styles: {} }, u = [], m = false, v = { state: c, setOptions: function(p2) {
      var g = typeof p2 == "function" ? p2(c.options) : p2;
      h2(), c.options = Object.assign({}, i, c.options, g), c.scrollParents = { reference: Q(a) ? ce(a) : a.contextElement ? ce(a.contextElement) : [], popper: ce(s) };
      var x = un(dn([].concat(r, c.options.modifiers)));
      return c.orderedModifiers = x.filter(function(y) {
        return y.enabled;
      }), l(), v.update();
    }, forceUpdate: function() {
      if (!m) {
        var p2 = c.elements, g = p2.reference, x = p2.popper;
        if ($t(g, x)) {
          c.rects = { reference: cn(g, se(x), c.options.strategy === "fixed"), popper: ke(x) }, c.reset = false, c.placement = c.options.placement, c.orderedModifiers.forEach(function(j) {
            return c.modifiersData[j.name] = Object.assign({}, j.data);
          });
          for (var y = 0; y < c.orderedModifiers.length; y++) {
            if (c.reset === true) {
              c.reset = false, y = -1;
              continue;
            }
            var $ = c.orderedModifiers[y], d = $.fn, b = $.options, w = b === void 0 ? {} : b, O = $.name;
            typeof d == "function" && (c = d({ state: c, options: w, name: O, instance: v }) || c);
          }
        }
      }
    }, update: ln(function() {
      return new Promise(function(p2) {
        v.forceUpdate(), p2(c);
      });
    }), destroy: function() {
      h2(), m = true;
    } };
    if (!$t(a, s))
      return v;
    v.setOptions(f).then(function(p2) {
      !m && f.onFirstUpdate && f.onFirstUpdate(p2);
    });
    function l() {
      c.orderedModifiers.forEach(function(p2) {
        var g = p2.name, x = p2.options, y = x === void 0 ? {} : x, $ = p2.effect;
        if (typeof $ == "function") {
          var d = $({ state: c, name: g, instance: v, options: y }), b = function() {
          };
          u.push(d || b);
        }
      });
    }
    function h2() {
      u.forEach(function(p2) {
        return p2();
      }), u = [];
    }
    return v;
  };
}
we();
var mn = [Re, He, Me, Ae];
we({ defaultModifiers: mn });
var gn = [Re, He, Me, Ae, wt, vt, xt, pt, bt], yn = we({ defaultModifiers: gn });
const obtainAllFocusableElements = (element) => {
  const nodes = [];
  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput)
        return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode())
    nodes.push(walker.currentNode);
  return nodes;
};
const getVisibleElement = (elements, container) => {
  for (const element of elements) {
    if (!isHidden(element, container))
      return element;
  }
};
const isHidden = (element, container) => {
  if (getComputedStyle(element).visibility === "hidden")
    return true;
  while (element) {
    if (container && element === container)
      return false;
    if (getComputedStyle(element).display === "none")
      return true;
    element = element.parentElement;
  }
  return false;
};
const getEdges = (container) => {
  const focusable = obtainAllFocusableElements(container);
  const first = getVisibleElement(focusable, container);
  const last = getVisibleElement(focusable.reverse(), container);
  return [first, last];
};
const isSelectable = (element) => {
  return element instanceof HTMLInputElement && "select" in element;
};
const tryFocus = (element, shouldSelect) => {
  if (element && element.focus) {
    const prevFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {
      element.select();
    }
  }
};
function removeFromStack(list, item) {
  const copy = [...list];
  const idx = list.indexOf(item);
  if (idx !== -1) {
    copy.splice(idx, 1);
  }
  return copy;
}
const createFocusableStack = () => {
  let stack2 = [];
  const push = (layer) => {
    const currentLayer = stack2[0];
    if (currentLayer && layer !== currentLayer) {
      currentLayer.pause();
    }
    stack2 = removeFromStack(stack2, layer);
    stack2.unshift(layer);
  };
  const remove2 = (layer) => {
    var _a2, _b;
    stack2 = removeFromStack(stack2, layer);
    (_b = (_a2 = stack2[0]) == null ? void 0 : _a2.resume) == null ? void 0 : _b.call(_a2);
  };
  return {
    push,
    remove: remove2
  };
};
const focusFirstDescendant = (elements, shouldSelect = false) => {
  const prevFocusedElement = document.activeElement;
  for (const element of elements) {
    tryFocus(element, shouldSelect);
    if (document.activeElement !== prevFocusedElement)
      return;
  }
};
const focusableStack = createFocusableStack();
const FOCUS_AFTER_TRAPPED = "focus-trap.focus-after-trapped";
const FOCUS_AFTER_RELEASED = "focus-trap.focus-after-released";
const FOCUS_AFTER_TRAPPED_OPTS = {
  cancelable: true,
  bubbles: false
};
const ON_TRAP_FOCUS_EVT = "focusAfterTrapped";
const ON_RELEASE_FOCUS_EVT = "focusAfterReleased";
const FOCUS_TRAP_INJECTION_KEY = Symbol("elFocusTrap");
const _sfc_main$s = defineComponent({
  name: "ElFocusTrap",
  inheritAttrs: false,
  props: {
    loop: Boolean,
    trapped: Boolean,
    focusTrapEl: Object,
    focusStartEl: {
      type: [Object, String],
      default: "first"
    }
  },
  emits: [
    ON_TRAP_FOCUS_EVT,
    ON_RELEASE_FOCUS_EVT,
    "focusin",
    "focusout",
    "focusout-prevented",
    "release-requested"
  ],
  setup(props, { emit }) {
    const forwardRef = ref();
    let lastFocusBeforeTrapped;
    let lastFocusAfterTrapped;
    useEscapeKeydown((event) => {
      if (props.trapped && !focusLayer.paused) {
        emit("release-requested", event);
      }
    });
    const focusLayer = {
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    };
    const onKeydown = (e) => {
      if (!props.loop && !props.trapped)
        return;
      if (focusLayer.paused)
        return;
      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e;
      const { loop } = props;
      const isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;
      const currentFocusingEl = document.activeElement;
      if (isTabbing && currentFocusingEl) {
        const container = currentTarget;
        const [first, last] = getEdges(container);
        const isTabbable = first && last;
        if (!isTabbable) {
          if (currentFocusingEl === container) {
            e.preventDefault();
            emit("focusout-prevented");
          }
        } else {
          if (!shiftKey && currentFocusingEl === last) {
            e.preventDefault();
            if (loop)
              tryFocus(first, true);
            emit("focusout-prevented");
          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {
            e.preventDefault();
            if (loop)
              tryFocus(last, true);
            emit("focusout-prevented");
          }
        }
      }
    };
    provide(FOCUS_TRAP_INJECTION_KEY, {
      focusTrapRef: forwardRef,
      onKeydown
    });
    watch(() => props.focusTrapEl, (focusTrapEl) => {
      if (focusTrapEl) {
        forwardRef.value = focusTrapEl;
      }
    }, { immediate: true });
    watch([forwardRef], ([forwardRef2], [oldForwardRef]) => {
      if (forwardRef2) {
        forwardRef2.addEventListener("keydown", onKeydown);
        forwardRef2.addEventListener("focusin", onFocusIn);
        forwardRef2.addEventListener("focusout", onFocusOut);
      }
      if (oldForwardRef) {
        oldForwardRef.removeEventListener("keydown", onKeydown);
        oldForwardRef.removeEventListener("focusin", onFocusIn);
        oldForwardRef.removeEventListener("focusout", onFocusOut);
      }
    });
    const trapOnFocus = (e) => {
      emit(ON_TRAP_FOCUS_EVT, e);
    };
    const releaseOnFocus = (e) => emit(ON_RELEASE_FOCUS_EVT, e);
    const onFocusIn = (e) => {
      const trapContainer = unref(forwardRef);
      if (!trapContainer)
        return;
      const target = e.target;
      const isFocusedInTrap = target && trapContainer.contains(target);
      if (isFocusedInTrap)
        emit("focusin", e);
      if (focusLayer.paused)
        return;
      if (props.trapped) {
        if (isFocusedInTrap) {
          lastFocusAfterTrapped = target;
        } else {
          tryFocus(lastFocusAfterTrapped, true);
        }
      }
    };
    const onFocusOut = (e) => {
      const trapContainer = unref(forwardRef);
      if (focusLayer.paused || !trapContainer)
        return;
      if (props.trapped) {
        const relatedTarget = e.relatedTarget;
        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {
          setTimeout(() => {
            if (!focusLayer.paused && props.trapped) {
              tryFocus(lastFocusAfterTrapped, true);
            }
          }, 0);
        }
      } else {
        const target = e.target;
        const isFocusedInTrap = target && trapContainer.contains(target);
        if (!isFocusedInTrap)
          emit("focusout", e);
      }
    };
    async function startTrap() {
      await nextTick();
      const trapContainer = unref(forwardRef);
      if (trapContainer) {
        focusableStack.push(focusLayer);
        const prevFocusedElement = document.activeElement;
        lastFocusBeforeTrapped = prevFocusedElement;
        const isPrevFocusContained = trapContainer.contains(prevFocusedElement);
        if (!isPrevFocusContained) {
          const focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);
          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
          trapContainer.dispatchEvent(focusEvent);
          if (!focusEvent.defaultPrevented) {
            nextTick(() => {
              let focusStartEl = props.focusStartEl;
              if (!isString$1(focusStartEl)) {
                tryFocus(focusStartEl);
                if (document.activeElement !== focusStartEl) {
                  focusStartEl = "first";
                }
              }
              if (focusStartEl === "first") {
                focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);
              }
              if (document.activeElement === prevFocusedElement || focusStartEl === "container") {
                tryFocus(trapContainer);
              }
            });
          }
        }
      }
    }
    function stopTrap() {
      const trapContainer = unref(forwardRef);
      if (trapContainer) {
        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);
        const releasedEvent = new Event(FOCUS_AFTER_RELEASED, FOCUS_AFTER_TRAPPED_OPTS);
        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);
        trapContainer.dispatchEvent(releasedEvent);
        if (!releasedEvent.defaultPrevented) {
          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body, true);
        }
        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);
        focusableStack.remove(focusLayer);
      }
    }
    onMounted(() => {
      if (props.trapped) {
        startTrap();
      }
      watch(() => props.trapped, (trapped) => {
        if (trapped) {
          startTrap();
        } else {
          stopTrap();
        }
      });
    });
    onBeforeUnmount(() => {
      if (props.trapped) {
        stopTrap();
      }
    });
    return {
      onKeydown
    };
  }
});
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return renderSlot(_ctx.$slots, "default", { handleKeydown: _ctx.onKeydown });
}
var ElFocusTrap = /* @__PURE__ */ _export_sfc$1(_sfc_main$s, [["render", _sfc_render$8], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue"]]);
const POSITIONING_STRATEGIES = ["fixed", "absolute"];
const usePopperCoreConfigProps = buildProps({
  boundariesPadding: {
    type: Number,
    default: 0
  },
  fallbackPlacements: {
    type: definePropType(Array),
    default: () => []
  },
  gpuAcceleration: {
    type: Boolean,
    default: true
  },
  offset: {
    type: Number,
    default: 12
  },
  placement: {
    type: String,
    values: Ee,
    default: "bottom"
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  strategy: {
    type: String,
    values: POSITIONING_STRATEGIES,
    default: "absolute"
  }
});
const usePopperContentProps = buildProps(__spreadProps(__spreadValues({}, usePopperCoreConfigProps), {
  id: String,
  style: { type: definePropType([String, Array, Object]) },
  className: { type: definePropType([String, Array, Object]) },
  effect: {
    type: String,
    default: "dark"
  },
  visible: Boolean,
  enterable: {
    type: Boolean,
    default: true
  },
  pure: Boolean,
  focusOnShow: {
    type: Boolean,
    default: false
  },
  trapping: {
    type: Boolean,
    default: false
  },
  popperClass: {
    type: definePropType([String, Array, Object])
  },
  popperStyle: {
    type: definePropType([String, Array, Object])
  },
  referenceEl: {
    type: definePropType(Object)
  },
  triggerTargetEl: {
    type: definePropType(Object)
  },
  stopPopperMouseEvent: {
    type: Boolean,
    default: true
  },
  ariaLabel: {
    type: String,
    default: void 0
  },
  virtualTriggering: Boolean,
  zIndex: Number
}));
const usePopperContentEmits = [
  "mouseenter",
  "mouseleave",
  "focus",
  "blur",
  "close"
];
const buildPopperOptions = (props, arrowProps) => {
  const { placement, strategy, popperOptions } = props;
  const options = __spreadProps(__spreadValues({
    placement,
    strategy
  }, popperOptions), {
    modifiers: genModifiers(props)
  });
  attachArrow(options, arrowProps);
  deriveExtraModifiers(options, popperOptions == null ? void 0 : popperOptions.modifiers);
  return options;
};
const unwrapMeasurableEl = ($el) => {
  if (!isClient)
    return;
  return unrefElement($el);
};
function genModifiers(options) {
  const { offset, gpuAcceleration, fallbackPlacements } = options;
  return [
    {
      name: "offset",
      options: {
        offset: [0, offset != null ? offset : 12]
      }
    },
    {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    },
    {
      name: "flip",
      options: {
        padding: 5,
        fallbackPlacements: fallbackPlacements != null ? fallbackPlacements : []
      }
    },
    {
      name: "computeStyles",
      options: {
        gpuAcceleration,
        adaptive: gpuAcceleration
      }
    }
  ];
}
function attachArrow(options, { arrowEl, arrowOffset }) {
  options.modifiers.push({
    name: "arrow",
    options: {
      element: arrowEl,
      padding: arrowOffset != null ? arrowOffset : 5
    }
  });
}
function deriveExtraModifiers(options, modifiers) {
  if (modifiers) {
    options.modifiers = [...options.modifiers, ...modifiers != null ? modifiers : []];
  }
}
const __default__$7 = {
  name: "ElPopperContent"
};
const _sfc_main$r = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$7), {
  props: usePopperContentProps,
  emits: usePopperContentEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const { popperInstanceRef, contentRef, triggerRef: triggerRef2, role } = inject(POPPER_INJECTION_KEY, void 0);
    const formItemContext = inject(formItemContextKey, void 0);
    const { nextZIndex } = useZIndex();
    const ns2 = useNamespace("popper");
    const popperContentRef = ref();
    const focusStartRef = ref("first");
    const arrowRef = ref();
    const arrowOffset = ref();
    provide(POPPER_CONTENT_INJECTION_KEY, {
      arrowRef,
      arrowOffset
    });
    if (formItemContext && (formItemContext.addInputId || formItemContext.removeInputId)) {
      provide(formItemContextKey, __spreadProps(__spreadValues({}, formItemContext), {
        addInputId: NOOP,
        removeInputId: NOOP
      }));
    }
    const contentZIndex = ref(props.zIndex || nextZIndex());
    const trapped = ref(false);
    let triggerTargetAriaStopWatch = void 0;
    const computedReference = computed(() => unwrapMeasurableEl(props.referenceEl) || unref(triggerRef2));
    const contentStyle = computed(() => [{ zIndex: unref(contentZIndex) }, props.popperStyle]);
    const contentClass = computed(() => [
      ns2.b(),
      ns2.is("pure", props.pure),
      ns2.is(props.effect),
      props.popperClass
    ]);
    const ariaModal = computed(() => {
      return role && role.value === "dialog" ? "false" : void 0;
    });
    const createPopperInstance = ({ referenceEl, popperContentEl, arrowEl }) => {
      const options = buildPopperOptions(props, {
        arrowEl,
        arrowOffset: unref(arrowOffset)
      });
      return yn(referenceEl, popperContentEl, options);
    };
    const updatePopper = (shouldUpdateZIndex = true) => {
      var _a2;
      (_a2 = unref(popperInstanceRef)) == null ? void 0 : _a2.update();
      shouldUpdateZIndex && (contentZIndex.value = props.zIndex || nextZIndex());
    };
    const togglePopperAlive = () => {
      var _a2, _b;
      const monitorable = { name: "eventListeners", enabled: props.visible };
      (_b = (_a2 = unref(popperInstanceRef)) == null ? void 0 : _a2.setOptions) == null ? void 0 : _b.call(_a2, (options) => __spreadProps(__spreadValues({}, options), {
        modifiers: [...options.modifiers || [], monitorable]
      }));
      updatePopper(false);
      if (props.visible && props.focusOnShow) {
        trapped.value = true;
      } else if (props.visible === false) {
        trapped.value = false;
      }
    };
    const onFocusAfterTrapped = () => {
      emit("focus");
    };
    const onFocusAfterReleased = () => {
      focusStartRef.value = "first";
      emit("blur");
    };
    const onFocusInTrap = (event) => {
      var _a2;
      if (props.visible && !trapped.value) {
        if (event.relatedTarget) {
          (_a2 = event.relatedTarget) == null ? void 0 : _a2.focus();
        }
        if (event.target) {
          focusStartRef.value = event.target;
        }
        trapped.value = true;
      }
    };
    const onFocusoutPrevented = () => {
      if (!props.trapping) {
        trapped.value = false;
      }
    };
    const onReleaseRequested = () => {
      trapped.value = false;
      emit("close");
    };
    onMounted(() => {
      let updateHandle;
      watch(computedReference, (referenceEl) => {
        var _a2;
        updateHandle == null ? void 0 : updateHandle();
        const popperInstance = unref(popperInstanceRef);
        (_a2 = popperInstance == null ? void 0 : popperInstance.destroy) == null ? void 0 : _a2.call(popperInstance);
        if (referenceEl) {
          const popperContentEl = unref(popperContentRef);
          contentRef.value = popperContentEl;
          popperInstanceRef.value = createPopperInstance({
            referenceEl,
            popperContentEl,
            arrowEl: unref(arrowRef)
          });
          updateHandle = watch(() => referenceEl.getBoundingClientRect(), () => updatePopper(), {
            immediate: true
          });
        } else {
          popperInstanceRef.value = void 0;
        }
      }, {
        immediate: true
      });
      watch(() => props.triggerTargetEl, (triggerTargetEl, prevTriggerTargetEl) => {
        triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
        triggerTargetAriaStopWatch = void 0;
        const el = unref(triggerTargetEl || popperContentRef.value);
        const prevEl = unref(prevTriggerTargetEl || popperContentRef.value);
        if (isElement(el)) {
          const { ariaLabel, id } = toRefs(props);
          triggerTargetAriaStopWatch = watch([role, ariaLabel, ariaModal, id], (watches) => {
            ["role", "aria-label", "aria-modal", "id"].forEach((key, idx) => {
              isNil(watches[idx]) ? el.removeAttribute(key) : el.setAttribute(key, watches[idx]);
            });
          }, { immediate: true });
        }
        if (isElement(prevEl)) {
          ["role", "aria-label", "aria-modal", "id"].forEach((key) => {
            prevEl.removeAttribute(key);
          });
        }
      }, { immediate: true });
      watch(() => props.visible, togglePopperAlive, { immediate: true });
      watch(() => buildPopperOptions(props, {
        arrowEl: unref(arrowRef),
        arrowOffset: unref(arrowOffset)
      }), (option) => {
        var _a2;
        return (_a2 = popperInstanceRef.value) == null ? void 0 : _a2.setOptions(option);
      });
    });
    onBeforeUnmount(() => {
      triggerTargetAriaStopWatch == null ? void 0 : triggerTargetAriaStopWatch();
      triggerTargetAriaStopWatch = void 0;
    });
    expose({
      popperContentRef,
      popperInstanceRef,
      updatePopper,
      contentStyle
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "popperContentRef",
        ref: popperContentRef,
        style: normalizeStyle(unref(contentStyle)),
        class: normalizeClass(unref(contentClass)),
        tabindex: "-1",
        onMouseenter: _cache[0] || (_cache[0] = (e) => _ctx.$emit("mouseenter", e)),
        onMouseleave: _cache[1] || (_cache[1] = (e) => _ctx.$emit("mouseleave", e))
      }, [
        createVNode(unref(ElFocusTrap), {
          trapped: trapped.value,
          "trap-on-focus-in": true,
          "focus-trap-el": popperContentRef.value,
          "focus-start-el": focusStartRef.value,
          onFocusAfterTrapped,
          onFocusAfterReleased,
          onFocusin: onFocusInTrap,
          onFocusoutPrevented,
          onReleaseRequested
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8, ["trapped", "focus-trap-el", "focus-start-el"])
      ], 38);
    };
  }
}));
var ElPopperContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$r, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/popper/src/content.vue"]]);
const ElPopper = withInstall(Popper);
const ns = useNamespace("tooltip");
const useTooltipContentProps = buildProps(__spreadProps(__spreadValues(__spreadValues({}, useDelayedToggleProps), usePopperContentProps), {
  appendTo: {
    type: definePropType([String, Object]),
    default: POPPER_CONTAINER_SELECTOR
  },
  content: {
    type: String,
    default: ""
  },
  rawContent: {
    type: Boolean,
    default: false
  },
  persistent: Boolean,
  ariaLabel: String,
  visible: {
    type: definePropType(Boolean),
    default: null
  },
  transition: {
    type: String,
    default: `${ns.namespace.value}-fade-in-linear`
  },
  teleported: {
    type: Boolean,
    default: true
  },
  disabled: {
    type: Boolean
  }
}));
const useTooltipTriggerProps = buildProps(__spreadProps(__spreadValues({}, usePopperTriggerProps), {
  disabled: Boolean,
  trigger: {
    type: definePropType([String, Array]),
    default: "hover"
  },
  triggerKeys: {
    type: definePropType(Array),
    default: () => [EVENT_CODE.enter, EVENT_CODE.space]
  }
}));
const useTooltipProps = buildProps({
  openDelay: {
    type: Number
  },
  visibleArrow: {
    type: Boolean,
    default: void 0
  },
  hideAfter: {
    type: Number,
    default: 200
  },
  showArrow: {
    type: Boolean,
    default: true
  }
});
const TOOLTIP_INJECTION_KEY = Symbol("elTooltip");
const _sfc_main$q = defineComponent({
  name: "ElTooltipContent",
  components: {
    ElPopperContent
  },
  inheritAttrs: false,
  props: useTooltipContentProps,
  setup(props) {
    const contentRef = ref(null);
    const intermediateOpen = ref(false);
    const entering = ref(false);
    const leaving = ref(false);
    const destroyed = ref(false);
    const {
      controlled,
      id,
      open,
      trigger: trigger2,
      onClose,
      onOpen,
      onShow,
      onHide,
      onBeforeShow,
      onBeforeHide
    } = inject(TOOLTIP_INJECTION_KEY, void 0);
    const persistentRef = computed(() => {
      return props.persistent;
    });
    onBeforeUnmount(() => {
      destroyed.value = true;
    });
    const shouldRender = computed(() => {
      return unref(persistentRef) ? true : unref(open);
    });
    const shouldShow = computed(() => {
      return props.disabled ? false : unref(open);
    });
    const contentStyle = computed(() => {
      var _a2;
      return (_a2 = props.style) != null ? _a2 : {};
    });
    const ariaHidden = computed(() => !unref(open));
    const onTransitionLeave = () => {
      onHide();
    };
    const stopWhenControlled = () => {
      if (unref(controlled))
        return true;
    };
    const onContentEnter = composeEventHandlers(stopWhenControlled, () => {
      if (props.enterable && unref(trigger2) === "hover") {
        onOpen();
      }
    });
    const onContentLeave = composeEventHandlers(stopWhenControlled, () => {
      if (unref(trigger2) === "hover") {
        onClose();
      }
    });
    const onBeforeEnter = () => {
      var _a2, _b;
      (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.updatePopper) == null ? void 0 : _b.call(_a2);
      onBeforeShow == null ? void 0 : onBeforeShow();
    };
    const onBeforeLeave = () => {
      onBeforeHide == null ? void 0 : onBeforeHide();
    };
    const onAfterShow = () => {
      onShow();
      stopHandle = onClickOutside(computed(() => {
        var _a2;
        return (_a2 = contentRef.value) == null ? void 0 : _a2.popperContentRef;
      }), () => {
        if (unref(controlled))
          return;
        const $trigger = unref(trigger2);
        if ($trigger !== "hover") {
          onClose();
        }
      });
    };
    const onBlur = () => {
      if (!props.virtualTriggering) {
        onClose();
      }
    };
    let stopHandle;
    watch(() => unref(open), (val) => {
      if (!val) {
        stopHandle == null ? void 0 : stopHandle();
      }
    }, {
      flush: "post"
    });
    return {
      ariaHidden,
      entering,
      leaving,
      id,
      intermediateOpen,
      contentStyle,
      contentRef,
      destroyed,
      shouldRender,
      shouldShow,
      onClose,
      open,
      onAfterShow,
      onBeforeEnter,
      onBeforeLeave,
      onContentEnter,
      onContentLeave,
      onTransitionLeave,
      onBlur
    };
  }
});
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popper_content = resolveComponent("el-popper-content");
  return openBlock(), createBlock(Teleport, {
    disabled: !_ctx.teleported,
    to: _ctx.appendTo
  }, [
    createVNode(Transition, {
      name: _ctx.transition,
      onAfterLeave: _ctx.onTransitionLeave,
      onBeforeEnter: _ctx.onBeforeEnter,
      onAfterEnter: _ctx.onAfterShow,
      onBeforeLeave: _ctx.onBeforeLeave
    }, {
      default: withCtx(() => [
        _ctx.shouldRender ? withDirectives((openBlock(), createBlock(_component_el_popper_content, mergeProps({
          key: 0,
          id: _ctx.id,
          ref: "contentRef"
        }, _ctx.$attrs, {
          "aria-label": _ctx.ariaLabel,
          "aria-hidden": _ctx.ariaHidden,
          "boundaries-padding": _ctx.boundariesPadding,
          "fallback-placements": _ctx.fallbackPlacements,
          "gpu-acceleration": _ctx.gpuAcceleration,
          offset: _ctx.offset,
          placement: _ctx.placement,
          "popper-options": _ctx.popperOptions,
          strategy: _ctx.strategy,
          effect: _ctx.effect,
          enterable: _ctx.enterable,
          pure: _ctx.pure,
          "popper-class": _ctx.popperClass,
          "popper-style": [_ctx.popperStyle, _ctx.contentStyle],
          "reference-el": _ctx.referenceEl,
          "trigger-target-el": _ctx.triggerTargetEl,
          visible: _ctx.shouldShow,
          "z-index": _ctx.zIndex,
          onMouseenter: _ctx.onContentEnter,
          onMouseleave: _ctx.onContentLeave,
          onBlur: _ctx.onBlur,
          onClose: _ctx.onClose
        }), {
          default: withCtx(() => [
            createCommentVNode(" Workaround bug #6378 "),
            !_ctx.destroyed ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 16, ["id", "aria-label", "aria-hidden", "boundaries-padding", "fallback-placements", "gpu-acceleration", "offset", "placement", "popper-options", "strategy", "effect", "enterable", "pure", "popper-class", "popper-style", "reference-el", "trigger-target-el", "visible", "z-index", "onMouseenter", "onMouseleave", "onBlur", "onClose"])), [
          [vShow, _ctx.shouldShow]
        ]) : createCommentVNode("v-if", true)
      ]),
      _: 3
    }, 8, ["name", "onAfterLeave", "onBeforeEnter", "onAfterEnter", "onBeforeLeave"])
  ], 8, ["disabled", "to"]);
}
var ElTooltipContent = /* @__PURE__ */ _export_sfc$1(_sfc_main$q, [["render", _sfc_render$7], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/content.vue"]]);
const isTriggerType = (trigger2, type) => {
  if (isArray$2(trigger2)) {
    return trigger2.includes(type);
  }
  return trigger2 === type;
};
const whenTrigger = (trigger2, type, handler) => {
  return (e) => {
    isTriggerType(unref(trigger2), type) && handler(e);
  };
};
const _sfc_main$p = defineComponent({
  name: "ElTooltipTrigger",
  components: {
    ElPopperTrigger
  },
  props: useTooltipTriggerProps,
  setup(props) {
    const ns2 = useNamespace("tooltip");
    const { controlled, id, open, onOpen, onClose, onToggle } = inject(TOOLTIP_INJECTION_KEY, void 0);
    const triggerRef2 = ref(null);
    const stopWhenControlledOrDisabled = () => {
      if (unref(controlled) || props.disabled) {
        return true;
      }
    };
    const trigger2 = toRef(props, "trigger");
    const onMouseenter = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onOpen));
    const onMouseleave = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "hover", onClose));
    const onClick = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "click", (e) => {
      if (e.button === 0) {
        onToggle(e);
      }
    }));
    const onFocus = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onOpen));
    const onBlur = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "focus", onClose));
    const onContextMenu = composeEventHandlers(stopWhenControlledOrDisabled, whenTrigger(trigger2, "contextmenu", (e) => {
      e.preventDefault();
      onToggle(e);
    }));
    const onKeydown = composeEventHandlers(stopWhenControlledOrDisabled, (e) => {
      const { code } = e;
      if (props.triggerKeys.includes(code)) {
        e.preventDefault();
        onToggle(e);
      }
    });
    return {
      onBlur,
      onContextMenu,
      onFocus,
      onMouseenter,
      onMouseleave,
      onClick,
      onKeydown,
      open,
      id,
      triggerRef: triggerRef2,
      ns: ns2
    };
  }
});
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_popper_trigger = resolveComponent("el-popper-trigger");
  return openBlock(), createBlock(_component_el_popper_trigger, {
    id: _ctx.id,
    "virtual-ref": _ctx.virtualRef,
    open: _ctx.open,
    "virtual-triggering": _ctx.virtualTriggering,
    class: normalizeClass(_ctx.ns.e("trigger")),
    onBlur: _ctx.onBlur,
    onClick: _ctx.onClick,
    onContextmenu: _ctx.onContextMenu,
    onFocus: _ctx.onFocus,
    onMouseenter: _ctx.onMouseenter,
    onMouseleave: _ctx.onMouseleave,
    onKeydown: _ctx.onKeydown
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["id", "virtual-ref", "open", "virtual-triggering", "class", "onBlur", "onClick", "onContextmenu", "onFocus", "onMouseenter", "onMouseleave", "onKeydown"]);
}
var ElTooltipTrigger = /* @__PURE__ */ _export_sfc$1(_sfc_main$p, [["render", _sfc_render$6], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/trigger.vue"]]);
const { useModelToggleProps, useModelToggle, useModelToggleEmits } = createModelToggleComposable("visible");
const _sfc_main$o = defineComponent({
  name: "ElTooltip",
  components: {
    ElPopper,
    ElPopperArrow,
    ElTooltipContent,
    ElTooltipTrigger
  },
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, usePopperProps), useModelToggleProps), useTooltipContentProps), useTooltipTriggerProps), usePopperArrowProps), useTooltipProps),
  emits: [
    ...useModelToggleEmits,
    "before-show",
    "before-hide",
    "show",
    "hide",
    "open",
    "close"
  ],
  setup(props, { emit }) {
    usePopperContainer();
    const compatShowAfter = computed(() => {
      if (!isUndefined(props.openDelay))
        ;
      return props.openDelay || props.showAfter;
    });
    const compatShowArrow = computed(() => {
      if (!isUndefined(props.visibleArrow))
        ;
      return isBoolean(props.visibleArrow) ? props.visibleArrow : props.showArrow;
    });
    const id = useId();
    const popperRef = ref(null);
    const contentRef = ref(null);
    const updatePopper = () => {
      var _a2;
      const popperComponent = unref(popperRef);
      if (popperComponent) {
        (_a2 = popperComponent.popperInstanceRef) == null ? void 0 : _a2.update();
      }
    };
    const open = ref(false);
    const toggleReason = ref(void 0);
    const { show, hide } = useModelToggle({
      indicator: open,
      toggleReason
    });
    const { onOpen, onClose } = useDelayedToggle({
      showAfter: compatShowAfter,
      hideAfter: toRef(props, "hideAfter"),
      open: show,
      close: hide
    });
    const controlled = computed(() => isBoolean(props.visible));
    provide(TOOLTIP_INJECTION_KEY, {
      controlled,
      id,
      open: readonly(open),
      trigger: toRef(props, "trigger"),
      onOpen: (event) => {
        onOpen(event);
      },
      onClose: (event) => {
        onClose(event);
      },
      onToggle: (event) => {
        if (unref(open)) {
          onClose(event);
        } else {
          onOpen(event);
        }
      },
      onShow: () => {
        emit("show", toggleReason.value);
      },
      onHide: () => {
        emit("hide", toggleReason.value);
      },
      onBeforeShow: () => {
        emit("before-show", toggleReason.value);
      },
      onBeforeHide: () => {
        emit("before-hide", toggleReason.value);
      },
      updatePopper
    });
    watch(() => props.disabled, (disabled) => {
      if (disabled && open.value) {
        open.value = false;
      }
    });
    const isFocusInsideContent = () => {
      var _a2, _b;
      const popperContent = (_b = (_a2 = contentRef.value) == null ? void 0 : _a2.contentRef) == null ? void 0 : _b.popperContentRef;
      return popperContent && popperContent.contains(document.activeElement);
    };
    return {
      compatShowAfter,
      compatShowArrow,
      popperRef,
      contentRef,
      open,
      hide,
      isFocusInsideContent,
      updatePopper,
      onOpen,
      onClose
    };
  }
});
const _hoisted_1$h = ["innerHTML"];
const _hoisted_2$f = { key: 1 };
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip_trigger = resolveComponent("el-tooltip-trigger");
  const _component_el_popper_arrow = resolveComponent("el-popper-arrow");
  const _component_el_tooltip_content = resolveComponent("el-tooltip-content");
  const _component_el_popper = resolveComponent("el-popper");
  return openBlock(), createBlock(_component_el_popper, {
    ref: "popperRef",
    role: _ctx.role
  }, {
    default: withCtx(() => [
      createVNode(_component_el_tooltip_trigger, {
        disabled: _ctx.disabled,
        trigger: _ctx.trigger,
        "trigger-keys": _ctx.triggerKeys,
        "virtual-ref": _ctx.virtualRef,
        "virtual-triggering": _ctx.virtualTriggering
      }, {
        default: withCtx(() => [
          _ctx.$slots.default ? renderSlot(_ctx.$slots, "default", { key: 0 }) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["disabled", "trigger", "trigger-keys", "virtual-ref", "virtual-triggering"]),
      createVNode(_component_el_tooltip_content, {
        ref: "contentRef",
        "aria-label": _ctx.ariaLabel,
        "boundaries-padding": _ctx.boundariesPadding,
        content: _ctx.content,
        disabled: _ctx.disabled,
        effect: _ctx.effect,
        enterable: _ctx.enterable,
        "fallback-placements": _ctx.fallbackPlacements,
        "hide-after": _ctx.hideAfter,
        "gpu-acceleration": _ctx.gpuAcceleration,
        offset: _ctx.offset,
        persistent: _ctx.persistent,
        "popper-class": _ctx.popperClass,
        "popper-style": _ctx.popperStyle,
        placement: _ctx.placement,
        "popper-options": _ctx.popperOptions,
        pure: _ctx.pure,
        "raw-content": _ctx.rawContent,
        "reference-el": _ctx.referenceEl,
        "trigger-target-el": _ctx.triggerTargetEl,
        "show-after": _ctx.compatShowAfter,
        strategy: _ctx.strategy,
        teleported: _ctx.teleported,
        transition: _ctx.transition,
        "virtual-triggering": _ctx.virtualTriggering,
        "z-index": _ctx.zIndex,
        "append-to": _ctx.appendTo
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "content", {}, () => [
            _ctx.rawContent ? (openBlock(), createElementBlock("span", {
              key: 0,
              innerHTML: _ctx.content
            }, null, 8, _hoisted_1$h)) : (openBlock(), createElementBlock("span", _hoisted_2$f, toDisplayString(_ctx.content), 1))
          ]),
          _ctx.compatShowArrow ? (openBlock(), createBlock(_component_el_popper_arrow, {
            key: 0,
            "arrow-offset": _ctx.arrowOffset
          }, null, 8, ["arrow-offset"])) : createCommentVNode("v-if", true)
        ]),
        _: 3
      }, 8, ["aria-label", "boundaries-padding", "content", "disabled", "effect", "enterable", "fallback-placements", "hide-after", "gpu-acceleration", "offset", "persistent", "popper-class", "popper-style", "placement", "popper-options", "pure", "raw-content", "reference-el", "trigger-target-el", "show-after", "strategy", "teleported", "transition", "virtual-triggering", "z-index", "append-to"])
    ]),
    _: 3
  }, 8, ["role"]);
}
var Tooltip = /* @__PURE__ */ _export_sfc$1(_sfc_main$o, [["render", _sfc_render$5], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/tooltip/src/tooltip.vue"]]);
const ElTooltip = withInstall(Tooltip);
const badgeProps = buildProps({
  value: {
    type: [String, Number],
    default: ""
  },
  max: {
    type: Number,
    default: 99
  },
  isDot: Boolean,
  hidden: Boolean,
  type: {
    type: String,
    values: ["primary", "success", "warning", "info", "danger"],
    default: "danger"
  }
});
const _hoisted_1$g = ["textContent"];
const __default__$6 = {
  name: "ElBadge"
};
const _sfc_main$n = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$6), {
  props: badgeProps,
  setup(__props, { expose }) {
    const props = __props;
    const ns2 = useNamespace("badge");
    const content = computed(() => {
      if (props.isDot)
        return "";
      if (isNumber(props.value) && isNumber(props.max)) {
        return props.max < props.value ? `${props.max}+` : `${props.value}`;
      }
      return `${props.value}`;
    });
    expose({
      content
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(ns2).b())
      }, [
        renderSlot(_ctx.$slots, "default"),
        createVNode(Transition, {
          name: `${unref(ns2).namespace.value}-zoom-in-center`,
          persisted: ""
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("sup", {
              class: normalizeClass([
                unref(ns2).e("content"),
                unref(ns2).em("content", _ctx.type),
                unref(ns2).is("fixed", !!_ctx.$slots.default),
                unref(ns2).is("dot", _ctx.isDot)
              ]),
              textContent: toDisplayString(unref(content))
            }, null, 10, _hoisted_1$g), [
              [vShow, !_ctx.hidden && (unref(content) || _ctx.isDot)]
            ])
          ]),
          _: 1
        }, 8, ["name"])
      ], 2);
    };
  }
}));
var Badge = /* @__PURE__ */ _export_sfc$1(_sfc_main$n, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/badge/src/badge.vue"]]);
const ElBadge = withInstall(Badge);
const buttonTypes = [
  "default",
  "primary",
  "success",
  "warning",
  "info",
  "danger",
  "text",
  ""
];
const buttonNativeTypes = ["button", "submit", "reset"];
const buttonProps = buildProps({
  size: useSizeProp,
  disabled: Boolean,
  type: {
    type: String,
    values: buttonTypes,
    default: ""
  },
  icon: {
    type: iconPropType,
    default: ""
  },
  nativeType: {
    type: String,
    values: buttonNativeTypes,
    default: "button"
  },
  loading: Boolean,
  loadingIcon: {
    type: iconPropType,
    default: () => loading_default
  },
  plain: Boolean,
  text: Boolean,
  link: Boolean,
  bg: Boolean,
  autofocus: Boolean,
  round: Boolean,
  circle: Boolean,
  color: String,
  dark: Boolean,
  autoInsertSpace: {
    type: Boolean,
    default: void 0
  }
});
const buttonEmits = {
  click: (evt) => evt instanceof MouseEvent
};
function bound01(n, max) {
  if (isOnePointZero(n)) {
    n = "100%";
  }
  var isPercent = isPercentage(n);
  n = max === 360 ? n : Math.min(max, Math.max(0, parseFloat(n)));
  if (isPercent) {
    n = parseInt(String(n * max), 10) / 100;
  }
  if (Math.abs(n - max) < 1e-6) {
    return 1;
  }
  if (max === 360) {
    n = (n < 0 ? n % max + max : n % max) / parseFloat(String(max));
  } else {
    n = n % max / parseFloat(String(max));
  }
  return n;
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function isOnePointZero(n) {
  return typeof n === "string" && n.indexOf(".") !== -1 && parseFloat(n) === 1;
}
function isPercentage(n) {
  return typeof n === "string" && n.indexOf("%") !== -1;
}
function boundAlpha(a) {
  a = parseFloat(a);
  if (isNaN(a) || a < 0 || a > 1) {
    a = 1;
  }
  return a;
}
function convertToPercentage(n) {
  if (n <= 1) {
    return "".concat(Number(n) * 100, "%");
  }
  return n;
}
function pad2(c) {
  return c.length === 1 ? "0" + c : String(c);
}
function rgbToRgb(r, g, b) {
  return {
    r: bound01(r, 255) * 255,
    g: bound01(g, 255) * 255,
    b: bound01(b, 255) * 255
  };
}
function rgbToHsl(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h2 = 0;
  var s = 0;
  var l = (max + min) / 2;
  if (max === min) {
    s = 0;
    h2 = 0;
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, l };
}
function hue2rgb(p2, q2, t) {
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p2 + (q2 - p2) * (6 * t);
  }
  if (t < 1 / 2) {
    return q2;
  }
  if (t < 2 / 3) {
    return p2 + (q2 - p2) * (2 / 3 - t) * 6;
  }
  return p2;
}
function hslToRgb(h2, s, l) {
  var r;
  var g;
  var b;
  h2 = bound01(h2, 360);
  s = bound01(s, 100);
  l = bound01(l, 100);
  if (s === 0) {
    g = l;
    b = l;
    r = l;
  } else {
    var q2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p2 = 2 * l - q2;
    r = hue2rgb(p2, q2, h2 + 1 / 3);
    g = hue2rgb(p2, q2, h2);
    b = hue2rgb(p2, q2, h2 - 1 / 3);
  }
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHsv(r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  var max = Math.max(r, g, b);
  var min = Math.min(r, g, b);
  var h2 = 0;
  var v = max;
  var d = max - min;
  var s = max === 0 ? 0 : d / max;
  if (max === min) {
    h2 = 0;
  } else {
    switch (max) {
      case r:
        h2 = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h2 = (b - r) / d + 2;
        break;
      case b:
        h2 = (r - g) / d + 4;
        break;
    }
    h2 /= 6;
  }
  return { h: h2, s, v };
}
function hsvToRgb(h2, s, v) {
  h2 = bound01(h2, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  var i = Math.floor(h2);
  var f = h2 - i;
  var p2 = v * (1 - s);
  var q2 = v * (1 - f * s);
  var t = v * (1 - (1 - f) * s);
  var mod = i % 6;
  var r = [v, q2, p2, p2, t, v][mod];
  var g = [t, v, v, q2, p2, p2][mod];
  var b = [p2, p2, t, v, v, q2][mod];
  return { r: r * 255, g: g * 255, b: b * 255 };
}
function rgbToHex(r, g, b, allow3Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16))
  ];
  if (allow3Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r, g, b, a, allow4Char) {
  var hex = [
    pad2(Math.round(r).toString(16)),
    pad2(Math.round(g).toString(16)),
    pad2(Math.round(b).toString(16)),
    pad2(convertDecimalToHex(a))
  ];
  if (allow4Char && hex[0].startsWith(hex[0].charAt(1)) && hex[1].startsWith(hex[1].charAt(1)) && hex[2].startsWith(hex[2].charAt(1)) && hex[3].startsWith(hex[3].charAt(1))) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function convertDecimalToHex(d) {
  return Math.round(parseFloat(d) * 255).toString(16);
}
function convertHexToDecimal(h2) {
  return parseIntFromHex(h2) / 255;
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function numberInputToObject(color) {
  return {
    r: color >> 16,
    g: (color & 65280) >> 8,
    b: color & 255
  };
}
var names = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function inputToRGB(color) {
  var rgb = { r: 0, g: 0, b: 0 };
  var a = 1;
  var s = null;
  var v = null;
  var l = null;
  var ok = false;
  var format = false;
  if (typeof color === "string") {
    color = stringInputToObject(color);
  }
  if (typeof color === "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s = convertToPercentage(color.s);
      v = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s, v);
      ok = true;
      format = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s = convertToPercentage(color.s);
      l = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s, l);
      ok = true;
      format = "hsl";
    }
    if (Object.prototype.hasOwnProperty.call(color, "a")) {
      a = color.a;
    }
  }
  a = boundAlpha(a);
  return {
    ok,
    format: color.format || format,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a
  };
}
var CSS_INTEGER = "[-\\+]?\\d+%?";
var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
var matchers = {
  CSS_UNIT: new RegExp(CSS_UNIT),
  rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
  rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
  hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
  hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
  hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
  hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function stringInputToObject(color) {
  color = color.trim().toLowerCase();
  if (color.length === 0) {
    return false;
  }
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color === "transparent") {
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  }
  var match = matchers.rgb.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3] };
  }
  match = matchers.rgba.exec(color);
  if (match) {
    return { r: match[1], g: match[2], b: match[3], a: match[4] };
  }
  match = matchers.hsl.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3] };
  }
  match = matchers.hsla.exec(color);
  if (match) {
    return { h: match[1], s: match[2], l: match[3], a: match[4] };
  }
  match = matchers.hsv.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3] };
  }
  match = matchers.hsva.exec(color);
  if (match) {
    return { h: match[1], s: match[2], v: match[3], a: match[4] };
  }
  match = matchers.hex8.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      a: convertHexToDecimal(match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex6.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1]),
      g: parseIntFromHex(match[2]),
      b: parseIntFromHex(match[3]),
      format: named ? "name" : "hex"
    };
  }
  match = matchers.hex4.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      a: convertHexToDecimal(match[4] + match[4]),
      format: named ? "name" : "hex8"
    };
  }
  match = matchers.hex3.exec(color);
  if (match) {
    return {
      r: parseIntFromHex(match[1] + match[1]),
      g: parseIntFromHex(match[2] + match[2]),
      b: parseIntFromHex(match[3] + match[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function isValidCSSUnit(color) {
  return Boolean(matchers.CSS_UNIT.exec(String(color)));
}
var TinyColor = function() {
  function TinyColor2(color, opts) {
    if (color === void 0) {
      color = "";
    }
    if (opts === void 0) {
      opts = {};
    }
    var _a2;
    if (color instanceof TinyColor2) {
      return color;
    }
    if (typeof color === "number") {
      color = numberInputToObject(color);
    }
    this.originalInput = color;
    var rgb = inputToRGB(color);
    this.originalInput = color;
    this.r = rgb.r;
    this.g = rgb.g;
    this.b = rgb.b;
    this.a = rgb.a;
    this.roundA = Math.round(100 * this.a) / 100;
    this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
    this.gradientType = opts.gradientType;
    if (this.r < 1) {
      this.r = Math.round(this.r);
    }
    if (this.g < 1) {
      this.g = Math.round(this.g);
    }
    if (this.b < 1) {
      this.b = Math.round(this.b);
    }
    this.isValid = rgb.ok;
  }
  TinyColor2.prototype.isDark = function() {
    return this.getBrightness() < 128;
  };
  TinyColor2.prototype.isLight = function() {
    return !this.isDark();
  };
  TinyColor2.prototype.getBrightness = function() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  };
  TinyColor2.prototype.getLuminance = function() {
    var rgb = this.toRgb();
    var R2;
    var G2;
    var B2;
    var RsRGB = rgb.r / 255;
    var GsRGB = rgb.g / 255;
    var BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928) {
      R2 = RsRGB / 12.92;
    } else {
      R2 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    }
    if (GsRGB <= 0.03928) {
      G2 = GsRGB / 12.92;
    } else {
      G2 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    }
    if (BsRGB <= 0.03928) {
      B2 = BsRGB / 12.92;
    } else {
      B2 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
  };
  TinyColor2.prototype.getAlpha = function() {
    return this.a;
  };
  TinyColor2.prototype.setAlpha = function(alpha) {
    this.a = boundAlpha(alpha);
    this.roundA = Math.round(100 * this.a) / 100;
    return this;
  };
  TinyColor2.prototype.toHsv = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
  };
  TinyColor2.prototype.toHsvString = function() {
    var hsv = rgbToHsv(this.r, this.g, this.b);
    var h2 = Math.round(hsv.h * 360);
    var s = Math.round(hsv.s * 100);
    var v = Math.round(hsv.v * 100);
    return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHsl = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
  };
  TinyColor2.prototype.toHslString = function() {
    var hsl = rgbToHsl(this.r, this.g, this.b);
    var h2 = Math.round(hsl.h * 360);
    var s = Math.round(hsl.s * 100);
    var l = Math.round(hsl.l * 100);
    return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l, "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toHex = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return rgbToHex(this.r, this.g, this.b, allow3Char);
  };
  TinyColor2.prototype.toHexString = function(allow3Char) {
    if (allow3Char === void 0) {
      allow3Char = false;
    }
    return "#" + this.toHex(allow3Char);
  };
  TinyColor2.prototype.toHex8 = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
  };
  TinyColor2.prototype.toHex8String = function(allow4Char) {
    if (allow4Char === void 0) {
      allow4Char = false;
    }
    return "#" + this.toHex8(allow4Char);
  };
  TinyColor2.prototype.toRgb = function() {
    return {
      r: Math.round(this.r),
      g: Math.round(this.g),
      b: Math.round(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toRgbString = function() {
    var r = Math.round(this.r);
    var g = Math.round(this.g);
    var b = Math.round(this.b);
    return this.a === 1 ? "rgb(".concat(r, ", ").concat(g, ", ").concat(b, ")") : "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toPercentageRgb = function() {
    var fmt = function(x) {
      return "".concat(Math.round(bound01(x, 255) * 100), "%");
    };
    return {
      r: fmt(this.r),
      g: fmt(this.g),
      b: fmt(this.b),
      a: this.a
    };
  };
  TinyColor2.prototype.toPercentageRgbString = function() {
    var rnd = function(x) {
      return Math.round(bound01(x, 255) * 100);
    };
    return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
  };
  TinyColor2.prototype.toName = function() {
    if (this.a === 0) {
      return "transparent";
    }
    if (this.a < 1) {
      return false;
    }
    var hex = "#" + rgbToHex(this.r, this.g, this.b, false);
    for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
      var _b = _a2[_i], key = _b[0], value = _b[1];
      if (hex === value) {
        return key;
      }
    }
    return false;
  };
  TinyColor2.prototype.toString = function(format) {
    var formatSet = Boolean(format);
    format = format !== null && format !== void 0 ? format : this.format;
    var formattedString = false;
    var hasAlpha = this.a < 1 && this.a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format.startsWith("hex") || format === "name");
    if (needsAlphaFormat) {
      if (format === "name" && this.a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format === "hex" || format === "hex6") {
      formattedString = this.toHexString();
    }
    if (format === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format === "name") {
      formattedString = this.toName();
    }
    if (format === "hsl") {
      formattedString = this.toHslString();
    }
    if (format === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  };
  TinyColor2.prototype.toNumber = function() {
    return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
  };
  TinyColor2.prototype.clone = function() {
    return new TinyColor2(this.toString());
  };
  TinyColor2.prototype.lighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l += amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.brighten = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var rgb = this.toRgb();
    rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
    rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
    rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
    return new TinyColor2(rgb);
  };
  TinyColor2.prototype.darken = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.l -= amount / 100;
    hsl.l = clamp01(hsl.l);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.tint = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("white", amount);
  };
  TinyColor2.prototype.shade = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    return this.mix("black", amount);
  };
  TinyColor2.prototype.desaturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s -= amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.saturate = function(amount) {
    if (amount === void 0) {
      amount = 10;
    }
    var hsl = this.toHsl();
    hsl.s += amount / 100;
    hsl.s = clamp01(hsl.s);
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.greyscale = function() {
    return this.desaturate(100);
  };
  TinyColor2.prototype.spin = function(amount) {
    var hsl = this.toHsl();
    var hue = (hsl.h + amount) % 360;
    hsl.h = hue < 0 ? 360 + hue : hue;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.mix = function(color, amount) {
    if (amount === void 0) {
      amount = 50;
    }
    var rgb1 = this.toRgb();
    var rgb2 = new TinyColor2(color).toRgb();
    var p2 = amount / 100;
    var rgba = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
      a: (rgb2.a - rgb1.a) * p2 + rgb1.a
    };
    return new TinyColor2(rgba);
  };
  TinyColor2.prototype.analogous = function(results, slices) {
    if (results === void 0) {
      results = 6;
    }
    if (slices === void 0) {
      slices = 30;
    }
    var hsl = this.toHsl();
    var part = 360 / slices;
    var ret = [this];
    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
      hsl.h = (hsl.h + part) % 360;
      ret.push(new TinyColor2(hsl));
    }
    return ret;
  };
  TinyColor2.prototype.complement = function() {
    var hsl = this.toHsl();
    hsl.h = (hsl.h + 180) % 360;
    return new TinyColor2(hsl);
  };
  TinyColor2.prototype.monochromatic = function(results) {
    if (results === void 0) {
      results = 6;
    }
    var hsv = this.toHsv();
    var h2 = hsv.h;
    var s = hsv.s;
    var v = hsv.v;
    var res = [];
    var modification = 1 / results;
    while (results--) {
      res.push(new TinyColor2({ h: h2, s, v }));
      v = (v + modification) % 1;
    }
    return res;
  };
  TinyColor2.prototype.splitcomplement = function() {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    return [
      this,
      new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
      new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
    ];
  };
  TinyColor2.prototype.onBackground = function(background) {
    var fg = this.toRgb();
    var bg = new TinyColor2(background).toRgb();
    return new TinyColor2({
      r: bg.r + (fg.r - bg.r) * fg.a,
      g: bg.g + (fg.g - bg.g) * fg.a,
      b: bg.b + (fg.b - bg.b) * fg.a
    });
  };
  TinyColor2.prototype.triad = function() {
    return this.polyad(3);
  };
  TinyColor2.prototype.tetrad = function() {
    return this.polyad(4);
  };
  TinyColor2.prototype.polyad = function(n) {
    var hsl = this.toHsl();
    var h2 = hsl.h;
    var result = [this];
    var increment = 360 / n;
    for (var i = 1; i < n; i++) {
      result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
    }
    return result;
  };
  TinyColor2.prototype.equals = function(color) {
    return this.toRgbString() === new TinyColor2(color).toRgbString();
  };
  return TinyColor2;
}();
function darken(color, amount = 20) {
  return color.mix("#141414", amount).toString();
}
function useButtonCustomStyle(props) {
  const _disabled = useDisabled();
  const ns2 = useNamespace("button");
  return computed(() => {
    let styles = {};
    const buttonColor = props.color;
    if (buttonColor) {
      const color = new TinyColor(buttonColor);
      const activeBgColor = props.dark ? color.tint(20).toString() : darken(color, 20);
      if (props.plain) {
        styles = ns2.cssVarBlock({
          "bg-color": props.dark ? darken(color, 90) : color.tint(90).toString(),
          "text-color": buttonColor,
          "border-color": props.dark ? darken(color, 50) : color.tint(50).toString(),
          "hover-text-color": `var(${ns2.cssVarName("color-white")})`,
          "hover-bg-color": buttonColor,
          "hover-border-color": buttonColor,
          "active-bg-color": activeBgColor,
          "active-text-color": `var(${ns2.cssVarName("color-white")})`,
          "active-border-color": activeBgColor
        });
        if (_disabled.value) {
          styles[ns2.cssVarBlockName("disabled-bg-color")] = props.dark ? darken(color, 90) : color.tint(90).toString();
          styles[ns2.cssVarBlockName("disabled-text-color")] = props.dark ? darken(color, 50) : color.tint(50).toString();
          styles[ns2.cssVarBlockName("disabled-border-color")] = props.dark ? darken(color, 80) : color.tint(80).toString();
        }
      } else {
        const hoverBgColor = props.dark ? darken(color, 30) : color.tint(30).toString();
        const textColor = color.isDark() ? `var(${ns2.cssVarName("color-white")})` : `var(${ns2.cssVarName("color-black")})`;
        styles = ns2.cssVarBlock({
          "bg-color": buttonColor,
          "text-color": textColor,
          "border-color": buttonColor,
          "hover-bg-color": hoverBgColor,
          "hover-text-color": textColor,
          "hover-border-color": hoverBgColor,
          "active-bg-color": activeBgColor,
          "active-border-color": activeBgColor
        });
        if (_disabled.value) {
          const disabledButtonColor = props.dark ? darken(color, 50) : color.tint(50).toString();
          styles[ns2.cssVarBlockName("disabled-bg-color")] = disabledButtonColor;
          styles[ns2.cssVarBlockName("disabled-text-color")] = props.dark ? "rgba(255, 255, 255, 0.5)" : `var(${ns2.cssVarName("color-white")})`;
          styles[ns2.cssVarBlockName("disabled-border-color")] = disabledButtonColor;
        }
      }
    }
    return styles;
  });
}
const _hoisted_1$f = ["aria-disabled", "disabled", "autofocus", "type"];
const __default__$5 = {
  name: "ElButton"
};
const _sfc_main$m = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$5), {
  props: buttonProps,
  emits: buttonEmits,
  setup(__props, { expose, emit }) {
    const props = __props;
    const slots = useSlots();
    useDeprecated({
      from: "type.text",
      replacement: "type.link",
      version: "3.0.0",
      scope: "props",
      ref: "https://element-plus.org/en-US/component/button.html#button-attributes"
    }, computed(() => props.type === "text"));
    const buttonGroupContext = inject(buttonGroupContextKey, void 0);
    const globalConfig2 = useGlobalConfig("button");
    const ns2 = useNamespace("button");
    const { form } = useFormItem();
    const _size = useSize(computed(() => buttonGroupContext == null ? void 0 : buttonGroupContext.size));
    const _disabled = useDisabled();
    const _ref = ref();
    const _type = computed(() => props.type || (buttonGroupContext == null ? void 0 : buttonGroupContext.type) || "");
    const autoInsertSpace = computed(() => {
      var _a2, _b, _c;
      return (_c = (_b = props.autoInsertSpace) != null ? _b : (_a2 = globalConfig2.value) == null ? void 0 : _a2.autoInsertSpace) != null ? _c : false;
    });
    const shouldAddSpace = computed(() => {
      var _a2;
      const defaultSlot = (_a2 = slots.default) == null ? void 0 : _a2.call(slots);
      if (autoInsertSpace.value && (defaultSlot == null ? void 0 : defaultSlot.length) === 1) {
        const slot = defaultSlot[0];
        if ((slot == null ? void 0 : slot.type) === Text) {
          const text = slot.children;
          return /^\p{Unified_Ideograph}{2}$/u.test(text.trim());
        }
      }
      return false;
    });
    const buttonStyle = useButtonCustomStyle(props);
    const handleClick = (evt) => {
      if (props.nativeType === "reset") {
        form == null ? void 0 : form.resetFields();
      }
      emit("click", evt);
    };
    expose({
      ref: _ref,
      size: _size,
      type: _type,
      disabled: _disabled,
      shouldAddSpace
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("button", {
        ref_key: "_ref",
        ref: _ref,
        class: normalizeClass([
          unref(ns2).b(),
          unref(ns2).m(unref(_type)),
          unref(ns2).m(unref(_size)),
          unref(ns2).is("disabled", unref(_disabled)),
          unref(ns2).is("loading", _ctx.loading),
          unref(ns2).is("plain", _ctx.plain),
          unref(ns2).is("round", _ctx.round),
          unref(ns2).is("circle", _ctx.circle),
          unref(ns2).is("text", _ctx.text),
          unref(ns2).is("link", _ctx.link),
          unref(ns2).is("has-bg", _ctx.bg)
        ]),
        "aria-disabled": unref(_disabled) || _ctx.loading,
        disabled: unref(_disabled) || _ctx.loading,
        autofocus: _ctx.autofocus,
        type: _ctx.nativeType,
        style: normalizeStyle(unref(buttonStyle)),
        onClick: handleClick
      }, [
        _ctx.loading ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          _ctx.$slots.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }) : (openBlock(), createBlock(unref(ElIcon), {
            key: 1,
            class: normalizeClass(unref(ns2).is("loading"))
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(_ctx.loadingIcon)))
            ]),
            _: 1
          }, 8, ["class"]))
        ], 64)) : _ctx.icon || _ctx.$slots.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 1 }, {
          default: withCtx(() => [
            _ctx.icon ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.icon), { key: 0 })) : renderSlot(_ctx.$slots, "icon", { key: 1 })
          ]),
          _: 3
        })) : createCommentVNode("v-if", true),
        _ctx.$slots.default ? (openBlock(), createElementBlock("span", {
          key: 2,
          class: normalizeClass({ [unref(ns2).em("text", "expand")]: unref(shouldAddSpace) })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)) : createCommentVNode("v-if", true)
      ], 14, _hoisted_1$f);
    };
  }
}));
var Button = /* @__PURE__ */ _export_sfc$1(_sfc_main$m, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button.vue"]]);
const buttonGroupProps = {
  size: buttonProps.size,
  type: buttonProps.type
};
const __default__$4 = {
  name: "ElButtonGroup"
};
const _sfc_main$l = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$4), {
  props: buttonGroupProps,
  setup(__props) {
    const props = __props;
    provide(buttonGroupContextKey, reactive({
      size: toRef(props, "size"),
      type: toRef(props, "type")
    }));
    const ns2 = useNamespace("button");
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(`${unref(ns2).b("group")}`)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2);
    };
  }
}));
var ButtonGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$l, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/button/src/button-group.vue"]]);
const ElButton = withInstall(Button, {
  ButtonGroup
});
withNoopInstall(ButtonGroup);
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var dayjs_min = { exports: {} };
(function(module2, exports2) {
  !function(t, e) {
    module2.exports = e();
  }(commonjsGlobal, function() {
    var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", f = "month", h2 = "quarter", c = "year", d = "date", $ = "Invalid Date", l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_") }, m = function(t2, e2, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
    }, g = { s: m, z: function(t2) {
      var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t2(e2, n2) {
      if (e2.date() < n2.date())
        return -t2(n2, e2);
      var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, f), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), f);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: f, y: c, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: h2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === void 0;
    } }, v = "en", D = {};
    D[v] = M;
    var p2 = function(t2) {
      return t2 instanceof _;
    }, S = function t2(e2, n2, r2) {
      var i2;
      if (!e2)
        return v;
      if (typeof e2 == "string") {
        var s2 = e2.toLowerCase();
        D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
        var u2 = e2.split("-");
        if (!i2 && u2.length > 1)
          return t2(u2[0]);
      } else {
        var a2 = e2.name;
        D[a2] = e2, i2 = a2;
      }
      return !r2 && i2 && (v = i2), i2 || !r2 && v;
    }, w = function(t2, e2) {
      if (p2(t2))
        return t2.clone();
      var n2 = typeof e2 == "object" ? e2 : {};
      return n2.date = t2, n2.args = arguments, new _(n2);
    }, O = g;
    O.l = S, O.i = p2, O.w = function(t2, e2) {
      return w(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = S(t2.locale, null, true), this.parse(t2);
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var e2 = t3.date, n2 = t3.utc;
          if (e2 === null)
            return new Date(NaN);
          if (O.u(e2))
            return new Date();
          if (e2 instanceof Date)
            return new Date(e2);
          if (typeof e2 == "string" && !/Z$/i.test(e2)) {
            var r2 = e2.match(l);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e2);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return O;
      }, m2.isValid = function() {
        return !(this.$d.toString() === $);
      }, m2.isSame = function(t2, e2) {
        var n2 = w(t2);
        return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
      }, m2.isAfter = function(t2, e2) {
        return w(t2) < this.startOf(e2);
      }, m2.isBefore = function(t2, e2) {
        return this.endOf(e2) < w(t2);
      }, m2.$g = function(t2, e2, n2) {
        return O.u(t2) ? this[e2] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e2) {
        var n2 = this, r2 = !!O.u(e2) || e2, h3 = O.p(t2), $2 = function(t3, e3) {
          var i2 = O.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
          return r2 ? i2 : i2.endOf(a);
        }, l2 = function(t3, e3) {
          return O.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, g2 = "set" + (this.$u ? "UTC" : "");
        switch (h3) {
          case c:
            return r2 ? $2(1, 0) : $2(31, 11);
          case f:
            return r2 ? $2(1, M3) : $2(0, M3 + 1);
          case o:
            var v2 = this.$locale().weekStart || 0, D2 = (y2 < v2 ? y2 + 7 : y2) - v2;
            return $2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
          case a:
          case d:
            return l2(g2 + "Hours", 0);
          case u:
            return l2(g2 + "Minutes", 1);
          case s:
            return l2(g2 + "Seconds", 2);
          case i:
            return l2(g2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e2) {
        var n2, o2 = O.p(t2), h3 = "set" + (this.$u ? "UTC" : ""), $2 = (n2 = {}, n2[a] = h3 + "Date", n2[d] = h3 + "Date", n2[f] = h3 + "Month", n2[c] = h3 + "FullYear", n2[u] = h3 + "Hours", n2[s] = h3 + "Minutes", n2[i] = h3 + "Seconds", n2[r] = h3 + "Milliseconds", n2)[o2], l2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
        if (o2 === f || o2 === c) {
          var y2 = this.clone().set(d, 1);
          y2.$d[$2](l2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          $2 && this.$d[$2](l2);
        return this.init(), this;
      }, m2.set = function(t2, e2) {
        return this.clone().$set(t2, e2);
      }, m2.get = function(t2) {
        return this[O.p(t2)]();
      }, m2.add = function(r2, h3) {
        var d2, $2 = this;
        r2 = Number(r2);
        var l2 = O.p(h3), y2 = function(t2) {
          var e2 = w($2);
          return O.w(e2.date(e2.date() + Math.round(t2 * r2)), $2);
        };
        if (l2 === f)
          return this.set(f, this.$M + r2);
        if (l2 === c)
          return this.set(c, this.$y + r2);
        if (l2 === a)
          return y2(1);
        if (l2 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[l2] || 1, m3 = this.$d.getTime() + r2 * M3;
        return O.w(m3, this);
      }, m2.subtract = function(t2, e2) {
        return this.add(-1 * t2, e2);
      }, m2.format = function(t2) {
        var e2 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || $;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, f2 = n2.months, h3 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
        }, c2 = function(t3) {
          return O.s(s2 % 12 || 12, t3, "0");
        }, d2 = n2.meridiem || function(t3, e3, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        }, l2 = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: a2 + 1, MM: O.s(a2 + 1, 2, "0"), MMM: h3(n2.monthsShort, a2, f2, 3), MMMM: h3(f2, a2), D: this.$D, DD: O.s(this.$D, 2, "0"), d: String(this.$W), dd: h3(n2.weekdaysMin, this.$W, o2, 2), ddd: h3(n2.weekdaysShort, this.$W, o2, 3), dddd: o2[this.$W], H: String(s2), HH: O.s(s2, 2, "0"), h: c2(1), hh: c2(2), a: d2(s2, u2, true), A: d2(s2, u2, false), m: String(u2), mm: O.s(u2, 2, "0"), s: String(this.$s), ss: O.s(this.$s, 2, "0"), SSS: O.s(this.$ms, 3, "0"), Z: i2 };
        return r2.replace(y, function(t3, e3) {
          return e3 || l2[t3] || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, $2) {
        var l2, y2 = O.p(d2), M3 = w(r2), m3 = (M3.utcOffset() - this.utcOffset()) * e, g2 = this - M3, v2 = O.m(this, M3);
        return v2 = (l2 = {}, l2[c] = v2 / 12, l2[f] = v2, l2[h2] = v2 / 3, l2[o] = (g2 - m3) / 6048e5, l2[a] = (g2 - m3) / 864e5, l2[u] = g2 / n, l2[s] = g2 / e, l2[i] = g2 / t, l2)[y2] || g2, $2 ? v2 : O.a(v2);
      }, m2.daysInMonth = function() {
        return this.endOf(f).$D;
      }, m2.$locale = function() {
        return D[this.$L];
      }, m2.locale = function(t2, e2) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S(t2, e2, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return O.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), T = _.prototype;
    return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function(t2) {
      T[t2[1]] = function(e2) {
        return this.$g(e2, t2[0], t2[1]);
      };
    }), w.extend = function(t2, e2) {
      return t2.$i || (t2(e2, _, w), t2.$i = true), w;
    }, w.locale = S, w.isDayjs = p2, w.unix = function(t2) {
      return w(1e3 * t2);
    }, w.en = D[v], w.Ls = D, w.p = {}, w;
  });
})(dayjs_min);
var dayjs = dayjs_min.exports;
var localeData$1 = { exports: {} };
(function(module2, exports2) {
  !function(n, e) {
    module2.exports = e();
  }(commonjsGlobal, function() {
    return function(n, e, t) {
      var r = e.prototype, o = function(n2) {
        return n2 && (n2.indexOf ? n2 : n2.s);
      }, u = function(n2, e2, t2, r2, u2) {
        var i2 = n2.name ? n2 : n2.$locale(), a2 = o(i2[e2]), s2 = o(i2[t2]), f = a2 || s2.map(function(n3) {
          return n3.slice(0, r2);
        });
        if (!u2)
          return f;
        var d = i2.weekStart;
        return f.map(function(n3, e3) {
          return f[(e3 + (d || 0)) % 7];
        });
      }, i = function() {
        return t.Ls[t.locale()];
      }, a = function(n2, e2) {
        return n2.formats[e2] || function(n3) {
          return n3.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(n4, e3, t2) {
            return e3 || t2.slice(1);
          });
        }(n2.formats[e2.toUpperCase()]);
      }, s = function() {
        var n2 = this;
        return { months: function(e2) {
          return e2 ? e2.format("MMMM") : u(n2, "months");
        }, monthsShort: function(e2) {
          return e2 ? e2.format("MMM") : u(n2, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return n2.$locale().weekStart || 0;
        }, weekdays: function(e2) {
          return e2 ? e2.format("dddd") : u(n2, "weekdays");
        }, weekdaysMin: function(e2) {
          return e2 ? e2.format("dd") : u(n2, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(e2) {
          return e2 ? e2.format("ddd") : u(n2, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(e2) {
          return a(n2.$locale(), e2);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      r.localeData = function() {
        return s.bind(this)();
      }, t.localeData = function() {
        var n2 = i();
        return { firstDayOfWeek: function() {
          return n2.weekStart || 0;
        }, weekdays: function() {
          return t.weekdays();
        }, weekdaysShort: function() {
          return t.weekdaysShort();
        }, weekdaysMin: function() {
          return t.weekdaysMin();
        }, months: function() {
          return t.months();
        }, monthsShort: function() {
          return t.monthsShort();
        }, longDateFormat: function(e2) {
          return a(n2, e2);
        }, meridiem: n2.meridiem, ordinal: n2.ordinal };
      }, t.months = function() {
        return u(i(), "months");
      }, t.monthsShort = function() {
        return u(i(), "monthsShort", "months", 3);
      }, t.weekdays = function(n2) {
        return u(i(), "weekdays", null, null, n2);
      }, t.weekdaysShort = function(n2) {
        return u(i(), "weekdaysShort", "weekdays", 3, n2);
      }, t.weekdaysMin = function(n2) {
        return u(i(), "weekdaysMin", "weekdays", 2, n2);
      };
    };
  });
})(localeData$1);
var localeData = localeData$1.exports;
var customParseFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d\d/, r = /\d\d?/, i = /\d*[^-_:/,()\s\d]+/, o = {}, s = function(e2) {
      return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
    };
    var a = function(e2) {
      return function(t2) {
        this[e2] = +t2;
      };
    }, f = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
      (this.zone || (this.zone = {})).offset = function(e3) {
        if (!e3)
          return 0;
        if (e3 === "Z")
          return 0;
        var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
        return n2 === 0 ? 0 : t2[0] === "+" ? -n2 : n2;
      }(e2);
    }], h2 = function(e2) {
      var t2 = o[e2];
      return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
    }, u = function(e2, t2) {
      var n2, r2 = o.meridiem;
      if (r2) {
        for (var i2 = 1; i2 <= 24; i2 += 1)
          if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
      } else
        n2 = e2 === (t2 ? "pm" : "PM");
      return n2;
    }, d = { A: [i, function(e2) {
      this.afternoon = u(e2, false);
    }], a: [i, function(e2) {
      this.afternoon = u(e2, true);
    }], S: [/\d/, function(e2) {
      this.milliseconds = 100 * +e2;
    }], SS: [n, function(e2) {
      this.milliseconds = 10 * +e2;
    }], SSS: [/\d{3}/, function(e2) {
      this.milliseconds = +e2;
    }], s: [r, a("seconds")], ss: [r, a("seconds")], m: [r, a("minutes")], mm: [r, a("minutes")], H: [r, a("hours")], h: [r, a("hours")], HH: [r, a("hours")], hh: [r, a("hours")], D: [r, a("day")], DD: [n, a("day")], Do: [i, function(e2) {
      var t2 = o.ordinal, n2 = e2.match(/\d+/);
      if (this.day = n2[0], t2)
        for (var r2 = 1; r2 <= 31; r2 += 1)
          t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
    }], M: [r, a("month")], MM: [n, a("month")], MMM: [i, function(e2) {
      var t2 = h2("months"), n2 = (h2("monthsShort") || t2.map(function(e3) {
        return e3.slice(0, 3);
      })).indexOf(e2) + 1;
      if (n2 < 1)
        throw new Error();
      this.month = n2 % 12 || n2;
    }], MMMM: [i, function(e2) {
      var t2 = h2("months").indexOf(e2) + 1;
      if (t2 < 1)
        throw new Error();
      this.month = t2 % 12 || t2;
    }], Y: [/[+-]?\d+/, a("year")], YY: [n, function(e2) {
      this.year = s(e2);
    }], YYYY: [/\d{4}/, a("year")], Z: f, ZZ: f };
    function c(n2) {
      var r2, i2;
      r2 = n2, i2 = o && o.formats;
      for (var s2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
        var o2 = r3 && r3.toUpperCase();
        return n3 || i2[r3] || e[r3] || i2[o2].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
          return t3 || n4.slice(1);
        });
      })).match(t), a2 = s2.length, f2 = 0; f2 < a2; f2 += 1) {
        var h3 = s2[f2], u2 = d[h3], c2 = u2 && u2[0], l = u2 && u2[1];
        s2[f2] = l ? { regex: c2, parser: l } : h3.replace(/^\[|\]$/g, "");
      }
      return function(e2) {
        for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
          var i3 = s2[n3];
          if (typeof i3 == "string")
            r3 += i3.length;
          else {
            var o2 = i3.regex, f3 = i3.parser, h4 = e2.slice(r3), u3 = o2.exec(h4)[0];
            f3.call(t2, u3), e2 = e2.replace(u3, "");
          }
        }
        return function(e3) {
          var t3 = e3.afternoon;
          if (t3 !== void 0) {
            var n4 = e3.hours;
            t3 ? n4 < 12 && (e3.hours += 12) : n4 === 12 && (e3.hours = 0), delete e3.afternoon;
          }
        }(t2), t2;
      };
    }
    return function(e2, t2, n2) {
      n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (s = e2.parseTwoDigitYear);
      var r2 = t2.prototype, i2 = r2.parse;
      r2.parse = function(e3) {
        var t3 = e3.date, r3 = e3.utc, s2 = e3.args;
        this.$u = r3;
        var a2 = s2[1];
        if (typeof a2 == "string") {
          var f2 = s2[2] === true, h3 = s2[3] === true, u2 = f2 || h3, d2 = s2[2];
          h3 && (d2 = s2[2]), o = this.$locale(), !f2 && d2 && (o = n2.Ls[d2]), this.$d = function(e4, t4, n3) {
            try {
              if (["x", "X"].indexOf(t4) > -1)
                return new Date((t4 === "X" ? 1e3 : 1) * e4);
              var r4 = c(t4)(e4), i3 = r4.year, o2 = r4.month, s3 = r4.day, a3 = r4.hours, f3 = r4.minutes, h4 = r4.seconds, u3 = r4.milliseconds, d3 = r4.zone, l2 = new Date(), m2 = s3 || (i3 || o2 ? 1 : l2.getDate()), M2 = i3 || l2.getFullYear(), Y = 0;
              i3 && !o2 || (Y = o2 > 0 ? o2 - 1 : l2.getMonth());
              var p2 = a3 || 0, v = f3 || 0, D = h4 || 0, g = u3 || 0;
              return d3 ? new Date(Date.UTC(M2, Y, m2, p2, v, D, g + 60 * d3.offset * 1e3)) : n3 ? new Date(Date.UTC(M2, Y, m2, p2, v, D, g)) : new Date(M2, Y, m2, p2, v, D, g);
            } catch (e5) {
              return new Date("");
            }
          }(t3, a2, r3), this.init(), d2 && d2 !== true && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = new Date("")), o = {};
        } else if (a2 instanceof Array)
          for (var l = a2.length, m = 1; m <= l; m += 1) {
            s2[1] = a2[m - 1];
            var M = n2.apply(this, s2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === l && (this.$d = new Date(""));
          }
        else
          i2.call(this, e3);
      };
    };
  });
})(customParseFormat$1);
var customParseFormat = customParseFormat$1.exports;
const timeUnits = ["hours", "minutes", "seconds"];
const DEFAULT_FORMATS_TIME = "HH:mm:ss";
const DEFAULT_FORMATS_DATE = "YYYY-MM-DD";
const DEFAULT_FORMATS_DATEPICKER = {
  date: DEFAULT_FORMATS_DATE,
  dates: DEFAULT_FORMATS_DATE,
  week: "gggg[w]ww",
  year: "YYYY",
  month: "YYYY-MM",
  datetime: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`,
  monthrange: "YYYY-MM",
  daterange: DEFAULT_FORMATS_DATE,
  datetimerange: `${DEFAULT_FORMATS_DATE} ${DEFAULT_FORMATS_TIME}`
};
const buildTimeList = (value, bound) => {
  return [
    value > 0 ? value - 1 : void 0,
    value,
    value < bound ? value + 1 : void 0
  ];
};
const rangeArr = (n) => Array.from(Array.from({ length: n }).keys());
const extractDateFormat = (format) => {
  return format.replace(/\W?m{1,2}|\W?ZZ/g, "").replace(/\W?h{1,2}|\W?s{1,3}|\W?a/gi, "").trim();
};
const extractTimeFormat = (format) => {
  return format.replace(/\W?D{1,2}|\W?Do|\W?d{1,4}|\W?M{1,4}|\W?Y{2,4}/g, "").trim();
};
const dateEquals = function(a, b) {
  const aIsDate = isDate(a);
  const bIsDate = isDate(b);
  if (aIsDate && bIsDate) {
    return a.getTime() === b.getTime();
  }
  if (!aIsDate && !bIsDate) {
    return a === b;
  }
  return false;
};
const valueEquals = function(a, b) {
  const aIsArray = isArray$2(a);
  const bIsArray = isArray$2(b);
  if (aIsArray && bIsArray) {
    if (a.length !== b.length) {
      return false;
    }
    return a.every((item, index2) => dateEquals(item, b[index2]));
  }
  if (!aIsArray && !bIsArray) {
    return dateEquals(a, b);
  }
  return false;
};
const parseDate = function(date2, format, lang) {
  const day = isEmpty(format) || format === "x" ? dayjs(date2).locale(lang) : dayjs(date2, format).locale(lang);
  return day.isValid() ? day : void 0;
};
const formatter = function(date2, format, lang) {
  if (isEmpty(format))
    return date2;
  if (format === "x")
    return +date2;
  return dayjs(date2).locale(lang).format(format);
};
const timePickerDefaultProps = buildProps({
  id: {
    type: definePropType([Array, String])
  },
  name: {
    type: definePropType([Array, String]),
    default: ""
  },
  popperClass: {
    type: String,
    default: ""
  },
  format: String,
  valueFormat: String,
  type: {
    type: String,
    default: ""
  },
  clearable: {
    type: Boolean,
    default: true
  },
  clearIcon: {
    type: definePropType([String, Object]),
    default: circle_close_default
  },
  editable: {
    type: Boolean,
    default: true
  },
  prefixIcon: {
    type: definePropType([String, Object]),
    default: ""
  },
  size: useSizeProp,
  readonly: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  placeholder: {
    type: String,
    default: ""
  },
  popperOptions: {
    type: definePropType(Object),
    default: () => ({})
  },
  modelValue: {
    type: definePropType([Date, Array, String, Number]),
    default: ""
  },
  rangeSeparator: {
    type: String,
    default: "-"
  },
  startPlaceholder: String,
  endPlaceholder: String,
  defaultValue: {
    type: definePropType([Date, Array])
  },
  defaultTime: {
    type: definePropType([Date, Array])
  },
  isRange: {
    type: Boolean,
    default: false
  },
  disabledHours: {
    type: Function
  },
  disabledMinutes: {
    type: Function
  },
  disabledSeconds: {
    type: Function
  },
  disabledDate: {
    type: Function
  },
  cellClassName: {
    type: Function
  },
  shortcuts: {
    type: Array,
    default: () => []
  },
  arrowControl: {
    type: Boolean,
    default: false
  },
  label: {
    type: String,
    default: void 0
  },
  tabindex: {
    type: definePropType([String, Number]),
    default: 0
  },
  validateEvent: {
    type: Boolean,
    default: true
  },
  unlinkPanels: Boolean
});
const _hoisted_1$e = ["id", "name", "placeholder", "value", "disabled", "readonly"];
const _hoisted_2$e = ["id", "name", "placeholder", "value", "disabled", "readonly"];
const __default__$3 = {
  name: "Picker"
};
const _sfc_main$k = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$3), {
  props: timePickerDefaultProps,
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur",
    "calendar-change",
    "panel-change",
    "visible-change",
    "keydown"
  ],
  setup(__props, { expose, emit }) {
    const props = __props;
    const { lang } = useLocale();
    const nsDate = useNamespace("date");
    const nsInput = useNamespace("input");
    const nsRange = useNamespace("range");
    const elForm = inject(formContextKey, {});
    const elFormItem = inject(formItemContextKey, {});
    const elPopperOptions = inject("ElPopperOptions", {});
    const refPopper = ref();
    const inputRef = ref();
    const pickerVisible = ref(false);
    const pickerActualVisible = ref(false);
    const valueOnOpen = ref(null);
    let hasJustTabExitedInput = false;
    let ignoreFocusEvent = false;
    watch(pickerVisible, (val) => {
      if (!val) {
        userInput.value = null;
        nextTick(() => {
          emitChange(props.modelValue);
        });
      } else {
        valueOnOpen.value = props.modelValue;
      }
    });
    const emitChange = (val, isClear) => {
      var _a2;
      if (isClear || !valueEquals(val, valueOnOpen.value)) {
        emit("change", val);
        props.validateEvent && ((_a2 = elFormItem.validate) == null ? void 0 : _a2.call(elFormItem, "change").catch((err) => debugWarn()));
      }
    };
    const emitInput = (input2) => {
      if (!valueEquals(props.modelValue, input2)) {
        let formatted;
        if (isArray$2(input2)) {
          formatted = input2.map((item) => formatter(item, props.valueFormat, lang.value));
        } else if (input2) {
          formatted = formatter(input2, props.valueFormat, lang.value);
        }
        emit("update:modelValue", input2 ? formatted : input2, lang.value);
      }
    };
    const emitKeydown = (e) => {
      emit("keydown", e);
    };
    const refInput = computed(() => {
      if (inputRef.value) {
        const _r = isRangeInput.value ? inputRef.value : inputRef.value.$el;
        return Array.from(_r.querySelectorAll("input"));
      }
      return [];
    });
    const setSelectionRange = (start, end, pos) => {
      const _inputs = refInput.value;
      if (!_inputs.length)
        return;
      if (!pos || pos === "min") {
        _inputs[0].setSelectionRange(start, end);
        _inputs[0].focus();
      } else if (pos === "max") {
        _inputs[1].setSelectionRange(start, end);
        _inputs[1].focus();
      }
    };
    const focusOnInputBox = () => {
      focus(true, true);
      nextTick(() => {
        ignoreFocusEvent = false;
      });
    };
    const onPick = (date2 = "", visible = false) => {
      if (!visible) {
        focusOnInputBox();
      }
      pickerVisible.value = visible;
      let result;
      if (isArray$2(date2)) {
        result = date2.map((_) => _.toDate());
      } else {
        result = date2 ? date2.toDate() : date2;
      }
      userInput.value = null;
      emitInput(result);
    };
    const onBeforeShow = () => {
      pickerActualVisible.value = true;
    };
    const onShow = () => {
      emit("visible-change", true);
    };
    const onKeydownPopperContent = (event) => {
      if ((event == null ? void 0 : event.key) === EVENT_CODE.esc) {
        focus(true, true);
      }
    };
    const onHide = () => {
      pickerActualVisible.value = false;
      ignoreFocusEvent = false;
      emit("visible-change", false);
    };
    const focus = (focusStartInput = true, isIgnoreFocusEvent = false) => {
      ignoreFocusEvent = isIgnoreFocusEvent;
      const [leftInput, rightInput] = unref(refInput);
      let input2 = leftInput;
      if (!focusStartInput && isRangeInput.value) {
        input2 = rightInput;
      }
      if (input2) {
        input2.focus();
      }
    };
    const handleFocusInput = (e) => {
      if (props.readonly || pickerDisabled.value || pickerVisible.value || ignoreFocusEvent) {
        return;
      }
      pickerVisible.value = true;
      emit("focus", e);
    };
    let currentHandleBlurDeferCallback;
    const handleBlurInput = (e) => {
      const handleBlurDefer = async () => {
        setTimeout(() => {
          var _a2, _b;
          if (currentHandleBlurDeferCallback === handleBlurDefer) {
            if (!(((_a2 = refPopper.value) == null ? void 0 : _a2.isFocusInsideContent()) && !hasJustTabExitedInput) && refInput.value.filter((input2) => {
              return input2.contains(document.activeElement);
            }).length === 0) {
              handleChange();
              pickerVisible.value = false;
              emit("blur", e);
              props.validateEvent && ((_b = elFormItem.validate) == null ? void 0 : _b.call(elFormItem, "blur").catch((err) => debugWarn()));
            }
            hasJustTabExitedInput = false;
          }
        }, 0);
      };
      currentHandleBlurDeferCallback = handleBlurDefer;
      handleBlurDefer();
    };
    const pickerDisabled = computed(() => {
      return props.disabled || elForm.disabled;
    });
    const parsedValue2 = computed(() => {
      let dayOrDays;
      if (valueIsEmpty.value) {
        if (pickerOptions.value.getDefaultValue) {
          dayOrDays = pickerOptions.value.getDefaultValue();
        }
      } else {
        if (isArray$2(props.modelValue)) {
          dayOrDays = props.modelValue.map((d) => parseDate(d, props.valueFormat, lang.value));
        } else {
          dayOrDays = parseDate(props.modelValue, props.valueFormat, lang.value);
        }
      }
      if (pickerOptions.value.getRangeAvailableTime) {
        const availableResult = pickerOptions.value.getRangeAvailableTime(dayOrDays);
        if (!isEqual(availableResult, dayOrDays)) {
          dayOrDays = availableResult;
          emitInput(isArray$2(dayOrDays) ? dayOrDays.map((_) => _.toDate()) : dayOrDays.toDate());
        }
      }
      if (isArray$2(dayOrDays) && dayOrDays.some((day) => !day)) {
        dayOrDays = [];
      }
      return dayOrDays;
    });
    const displayValue = computed(() => {
      if (!pickerOptions.value.panelReady)
        return "";
      const formattedValue = formatDayjsToString(parsedValue2.value);
      if (isArray$2(userInput.value)) {
        return [
          userInput.value[0] || formattedValue && formattedValue[0] || "",
          userInput.value[1] || formattedValue && formattedValue[1] || ""
        ];
      } else if (userInput.value !== null) {
        return userInput.value;
      }
      if (!isTimePicker.value && valueIsEmpty.value)
        return "";
      if (!pickerVisible.value && valueIsEmpty.value)
        return "";
      if (formattedValue) {
        return isDatesPicker.value ? formattedValue.join(", ") : formattedValue;
      }
      return "";
    });
    const isTimeLikePicker = computed(() => props.type.includes("time"));
    const isTimePicker = computed(() => props.type.startsWith("time"));
    const isDatesPicker = computed(() => props.type === "dates");
    const triggerIcon = computed(() => props.prefixIcon || (isTimeLikePicker.value ? clock_default : calendar_default));
    const showClose = ref(false);
    const onClearIconClick = (event) => {
      if (props.readonly || pickerDisabled.value)
        return;
      if (showClose.value) {
        event.stopPropagation();
        focusOnInputBox();
        emitInput(null);
        emitChange(null, true);
        showClose.value = false;
        pickerVisible.value = false;
        pickerOptions.value.handleClear && pickerOptions.value.handleClear();
      }
    };
    const valueIsEmpty = computed(() => {
      const { modelValue } = props;
      return !modelValue || isArray$2(modelValue) && !modelValue.filter(Boolean).length;
    });
    const onMouseDownInput = async (event) => {
      var _a2;
      if (props.readonly || pickerDisabled.value)
        return;
      if (((_a2 = event.target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
        pickerVisible.value = true;
      }
    };
    const onMouseEnter = () => {
      if (props.readonly || pickerDisabled.value)
        return;
      if (!valueIsEmpty.value && props.clearable) {
        showClose.value = true;
      }
    };
    const onMouseLeave = () => {
      showClose.value = false;
    };
    const onTouchStartInput = (event) => {
      var _a2;
      if (((_a2 = event.touches[0].target) == null ? void 0 : _a2.tagName) !== "INPUT" || refInput.value.includes(document.activeElement)) {
        pickerVisible.value = true;
      }
    };
    const isRangeInput = computed(() => {
      return props.type.includes("range");
    });
    const pickerSize = useSize();
    const popperEl = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = unref(refPopper)) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.contentRef;
    });
    const actualInputRef = computed(() => {
      var _a2;
      if (unref(isRangeInput)) {
        return unref(inputRef);
      }
      return (_a2 = unref(inputRef)) == null ? void 0 : _a2.$el;
    });
    onClickOutside(actualInputRef, (e) => {
      const unrefedPopperEl = unref(popperEl);
      const inputEl = unref(actualInputRef);
      if (unrefedPopperEl && (e.target === unrefedPopperEl || e.composedPath().includes(unrefedPopperEl)) || e.target === inputEl || e.composedPath().includes(inputEl))
        return;
      pickerVisible.value = false;
    });
    const userInput = ref(null);
    const handleChange = () => {
      if (userInput.value) {
        const value = parseUserInputToDayjs(displayValue.value);
        if (value) {
          if (isValidValue(value)) {
            emitInput(isArray$2(value) ? value.map((_) => _.toDate()) : value.toDate());
            userInput.value = null;
          }
        }
      }
      if (userInput.value === "") {
        emitInput(null);
        emitChange(null);
        userInput.value = null;
      }
    };
    const parseUserInputToDayjs = (value) => {
      if (!value)
        return null;
      return pickerOptions.value.parseUserInput(value);
    };
    const formatDayjsToString = (value) => {
      if (!value)
        return null;
      return pickerOptions.value.formatToString(value);
    };
    const isValidValue = (value) => {
      return pickerOptions.value.isValidValue(value);
    };
    const handleKeydownInput = async (event) => {
      const { code } = event;
      emitKeydown(event);
      if (code === EVENT_CODE.esc) {
        if (pickerVisible.value === true) {
          pickerVisible.value = false;
          event.preventDefault();
          event.stopPropagation();
        }
        return;
      }
      if (code === EVENT_CODE.down) {
        if (pickerOptions.value.handleFocusPicker) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (pickerVisible.value === false) {
          pickerVisible.value = true;
          await nextTick();
        }
        if (pickerOptions.value.handleFocusPicker) {
          pickerOptions.value.handleFocusPicker();
          return;
        }
      }
      if (code === EVENT_CODE.tab) {
        hasJustTabExitedInput = true;
        return;
      }
      if (code === EVENT_CODE.enter || code === EVENT_CODE.numpadEnter) {
        if (userInput.value === null || userInput.value === "" || isValidValue(parseUserInputToDayjs(displayValue.value))) {
          handleChange();
          pickerVisible.value = false;
        }
        event.stopPropagation();
        return;
      }
      if (userInput.value) {
        event.stopPropagation();
        return;
      }
      if (pickerOptions.value.handleKeydownInput) {
        pickerOptions.value.handleKeydownInput(event);
      }
    };
    const onUserInput = (e) => {
      userInput.value = e;
      if (!pickerVisible.value) {
        pickerVisible.value = true;
      }
    };
    const handleStartInput = (event) => {
      const target = event.target;
      if (userInput.value) {
        userInput.value = [target.value, userInput.value[1]];
      } else {
        userInput.value = [target.value, null];
      }
    };
    const handleEndInput = (event) => {
      const target = event.target;
      if (userInput.value) {
        userInput.value = [userInput.value[0], target.value];
      } else {
        userInput.value = [null, target.value];
      }
    };
    const handleStartChange = () => {
      var _a2;
      const values = userInput.value;
      const value = parseUserInputToDayjs(values && values[0]);
      const parsedVal = unref(parsedValue2);
      if (value && value.isValid()) {
        userInput.value = [
          formatDayjsToString(value),
          ((_a2 = displayValue.value) == null ? void 0 : _a2[1]) || null
        ];
        const newValue = [value, parsedVal && (parsedVal[1] || null)];
        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const handleEndChange = () => {
      var _a2;
      const values = unref(userInput);
      const value = parseUserInputToDayjs(values && values[1]);
      const parsedVal = unref(parsedValue2);
      if (value && value.isValid()) {
        userInput.value = [
          ((_a2 = unref(displayValue)) == null ? void 0 : _a2[0]) || null,
          formatDayjsToString(value)
        ];
        const newValue = [parsedVal && parsedVal[0], value];
        if (isValidValue(newValue)) {
          emitInput(newValue);
          userInput.value = null;
        }
      }
    };
    const pickerOptions = ref({});
    const onSetPickerOption = (e) => {
      pickerOptions.value[e[0]] = e[1];
      pickerOptions.value.panelReady = true;
    };
    const onCalendarChange = (e) => {
      emit("calendar-change", e);
    };
    const onPanelChange = (value, mode, view) => {
      emit("panel-change", value, mode, view);
    };
    provide("EP_PICKER_BASE", {
      props
    });
    expose({
      focus,
      handleFocusInput,
      handleBlurInput,
      onPick
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(unref(ElTooltip), mergeProps({
        ref_key: "refPopper",
        ref: refPopper,
        visible: pickerVisible.value,
        "onUpdate:visible": _cache[2] || (_cache[2] = ($event) => pickerVisible.value = $event),
        effect: "light",
        pure: "",
        trigger: "click"
      }, _ctx.$attrs, {
        role: "dialog",
        teleported: "",
        transition: `${unref(nsDate).namespace.value}-zoom-in-top`,
        "popper-class": [`${unref(nsDate).namespace.value}-picker__popper`, _ctx.popperClass],
        "popper-options": unref(elPopperOptions),
        "fallback-placements": ["bottom", "top", "right", "left"],
        "gpu-acceleration": false,
        "stop-popper-mouse-event": false,
        "hide-after": 0,
        persistent: "",
        onBeforeShow,
        onShow,
        onHide
      }), {
        default: withCtx(() => [
          !unref(isRangeInput) ? (openBlock(), createBlock(unref(ElInput), {
            key: 0,
            id: _ctx.id,
            ref_key: "inputRef",
            ref: inputRef,
            "container-role": "combobox",
            "model-value": unref(displayValue),
            name: _ctx.name,
            size: unref(pickerSize),
            disabled: unref(pickerDisabled),
            placeholder: _ctx.placeholder,
            class: normalizeClass([unref(nsDate).b("editor"), unref(nsDate).bm("editor", _ctx.type), _ctx.$attrs.class]),
            style: normalizeStyle(_ctx.$attrs.style),
            readonly: !_ctx.editable || _ctx.readonly || unref(isDatesPicker) || _ctx.type === "week",
            label: _ctx.label,
            tabindex: _ctx.tabindex,
            onInput: onUserInput,
            onFocus: handleFocusInput,
            onBlur: handleBlurInput,
            onKeydown: handleKeydownInput,
            onChange: handleChange,
            onMousedown: onMouseDownInput,
            onMouseenter: onMouseEnter,
            onMouseleave: onMouseLeave,
            onTouchstart: onTouchStartInput,
            onClick: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"]))
          }, {
            prefix: withCtx(() => [
              unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(unref(nsInput).e("icon")),
                onMousedown: onMouseDownInput,
                onTouchstart: onTouchStartInput
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
                ]),
                _: 1
              }, 8, ["class"])) : createCommentVNode("v-if", true)
            ]),
            suffix: withCtx(() => [
              showClose.value && _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
                key: 0,
                class: normalizeClass(`${unref(nsInput).e("icon")} clear-icon`),
                onClick: withModifiers(onClearIconClick, ["stop"])
              }, {
                default: withCtx(() => [
                  (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
                ]),
                _: 1
              }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
            ]),
            _: 1
          }, 8, ["id", "model-value", "name", "size", "disabled", "placeholder", "class", "style", "readonly", "label", "tabindex", "onKeydown"])) : (openBlock(), createElementBlock("div", {
            key: 1,
            ref_key: "inputRef",
            ref: inputRef,
            class: normalizeClass([
              unref(nsDate).b("editor"),
              unref(nsDate).bm("editor", _ctx.type),
              unref(nsInput).e("wrapper"),
              unref(nsDate).is("disabled", unref(pickerDisabled)),
              unref(nsDate).is("active", pickerVisible.value),
              unref(nsRange).b("editor"),
              unref(pickerSize) ? unref(nsRange).bm("editor", unref(pickerSize)) : "",
              _ctx.$attrs.class
            ]),
            style: normalizeStyle(_ctx.$attrs.style),
            onClick: handleFocusInput,
            onMousedown: onMouseDownInput,
            onMouseenter: onMouseEnter,
            onMouseleave: onMouseLeave,
            onTouchstart: onTouchStartInput,
            onKeydown: handleKeydownInput
          }, [
            unref(triggerIcon) ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass([unref(nsInput).e("icon"), unref(nsRange).e("icon")]),
              onMousedown: onMouseDownInput,
              onTouchstart: onTouchStartInput
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(unref(triggerIcon))))
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("v-if", true),
            createBaseVNode("input", {
              id: _ctx.id && _ctx.id[0],
              autocomplete: "off",
              name: _ctx.name && _ctx.name[0],
              placeholder: _ctx.startPlaceholder,
              value: unref(displayValue) && unref(displayValue)[0],
              disabled: unref(pickerDisabled),
              readonly: !_ctx.editable || _ctx.readonly,
              class: normalizeClass(unref(nsRange).b("input")),
              onInput: handleStartInput,
              onChange: handleStartChange,
              onFocus: handleFocusInput,
              onBlur: handleBlurInput
            }, null, 42, _hoisted_1$e),
            renderSlot(_ctx.$slots, "range-separator", {}, () => [
              createBaseVNode("span", {
                class: normalizeClass(unref(nsRange).b("separator"))
              }, toDisplayString(_ctx.rangeSeparator), 3)
            ]),
            createBaseVNode("input", {
              id: _ctx.id && _ctx.id[1],
              autocomplete: "off",
              name: _ctx.name && _ctx.name[1],
              placeholder: _ctx.endPlaceholder,
              value: unref(displayValue) && unref(displayValue)[1],
              disabled: unref(pickerDisabled),
              readonly: !_ctx.editable || _ctx.readonly,
              class: normalizeClass(unref(nsRange).b("input")),
              onFocus: handleFocusInput,
              onBlur: handleBlurInput,
              onInput: handleEndInput,
              onChange: handleEndChange
            }, null, 42, _hoisted_2$e),
            _ctx.clearIcon ? (openBlock(), createBlock(unref(ElIcon), {
              key: 1,
              class: normalizeClass([
                unref(nsInput).e("icon"),
                unref(nsRange).e("close-icon"),
                {
                  [unref(nsRange).e("close-icon--hidden")]: !showClose.value
                }
              ]),
              onClick: onClearIconClick
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(_ctx.clearIcon)))
              ]),
              _: 1
            }, 8, ["class"])) : createCommentVNode("v-if", true)
          ], 38))
        ]),
        content: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {
            visible: pickerVisible.value,
            actualVisible: pickerActualVisible.value,
            parsedValue: unref(parsedValue2),
            format: _ctx.format,
            unlinkPanels: _ctx.unlinkPanels,
            type: _ctx.type,
            defaultValue: _ctx.defaultValue,
            onPick,
            onSelectRange: setSelectionRange,
            onSetPickerOption,
            onCalendarChange,
            onPanelChange,
            onKeydown: onKeydownPopperContent,
            onMousedown: _cache[1] || (_cache[1] = withModifiers(() => {
            }, ["stop"]))
          })
        ]),
        _: 3
      }, 16, ["visible", "transition", "popper-class", "popper-options"]);
    };
  }
}));
var CommonPicker = /* @__PURE__ */ _export_sfc$1(_sfc_main$k, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/common/picker.vue"]]);
const panelTimePickerProps = buildProps({
  visible: Boolean,
  actualVisible: {
    type: Boolean,
    default: void 0
  },
  datetimeRole: String,
  parsedValue: {
    type: definePropType(Object)
  },
  format: {
    type: String,
    default: ""
  }
});
const useTimePanel = ({
  getAvailableHours,
  getAvailableMinutes,
  getAvailableSeconds
}) => {
  const getAvailableTime = (date2, role, first, compareDate) => {
    const availableTimeGetters = {
      hour: getAvailableHours,
      minute: getAvailableMinutes,
      second: getAvailableSeconds
    };
    let result = date2;
    ["hour", "minute", "second"].forEach((type) => {
      if (availableTimeGetters[type]) {
        let availableTimeSlots;
        const method = availableTimeGetters[type];
        switch (type) {
          case "minute": {
            availableTimeSlots = method(result.hour(), role, compareDate);
            break;
          }
          case "second": {
            availableTimeSlots = method(result.hour(), result.minute(), role, compareDate);
            break;
          }
          default: {
            availableTimeSlots = method(role, compareDate);
            break;
          }
        }
        if ((availableTimeSlots == null ? void 0 : availableTimeSlots.length) && !availableTimeSlots.includes(result[type]())) {
          const pos = first ? 0 : availableTimeSlots.length - 1;
          result = result[type](availableTimeSlots[pos]);
        }
      }
    });
    return result;
  };
  const timePickerOptions = {};
  const onSetOption = ([key, val]) => {
    timePickerOptions[key] = val;
  };
  return {
    timePickerOptions,
    getAvailableTime,
    onSetOption
  };
};
const nodeList = /* @__PURE__ */ new Map();
let startClick;
if (isClient) {
  document.addEventListener("mousedown", (e) => startClick = e);
  document.addEventListener("mouseup", (e) => {
    for (const handlers2 of nodeList.values()) {
      for (const { documentHandler } of handlers2) {
        documentHandler(e, startClick);
      }
    }
  });
}
function createDocumentHandler(el, binding) {
  let excludes = [];
  if (Array.isArray(binding.arg)) {
    excludes = binding.arg;
  } else if (isElement(binding.arg)) {
    excludes.push(binding.arg);
  }
  return function(mouseup, mousedown) {
    const popperRef = binding.instance.popperRef;
    const mouseUpTarget = mouseup.target;
    const mouseDownTarget = mousedown == null ? void 0 : mousedown.target;
    const isBound = !binding || !binding.instance;
    const isTargetExists = !mouseUpTarget || !mouseDownTarget;
    const isContainedByEl = el.contains(mouseUpTarget) || el.contains(mouseDownTarget);
    const isSelf = el === mouseUpTarget;
    const isTargetExcluded = excludes.length && excludes.some((item) => item == null ? void 0 : item.contains(mouseUpTarget)) || excludes.length && excludes.includes(mouseDownTarget);
    const isContainedByPopper = popperRef && (popperRef.contains(mouseUpTarget) || popperRef.contains(mouseDownTarget));
    if (isBound || isTargetExists || isContainedByEl || isSelf || isTargetExcluded || isContainedByPopper) {
      return;
    }
    binding.value(mouseup, mousedown);
  };
}
const ClickOutside = {
  beforeMount(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    nodeList.get(el).push({
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    });
  },
  updated(el, binding) {
    if (!nodeList.has(el)) {
      nodeList.set(el, []);
    }
    const handlers2 = nodeList.get(el);
    const oldHandlerIndex = handlers2.findIndex((item) => item.bindingFn === binding.oldValue);
    const newHandler = {
      documentHandler: createDocumentHandler(el, binding),
      bindingFn: binding.value
    };
    if (oldHandlerIndex >= 0) {
      handlers2.splice(oldHandlerIndex, 1, newHandler);
    } else {
      handlers2.push(newHandler);
    }
  },
  unmounted(el) {
    nodeList.delete(el);
  }
};
var vRepeatClick = {
  beforeMount(el, binding) {
    let interval = null;
    let startTime;
    const handler = () => binding.value && binding.value();
    const clear2 = () => {
      if (Date.now() - startTime < 100) {
        handler();
      }
      clearInterval(interval);
      interval = null;
    };
    on$1(el, "mousedown", (e) => {
      if (e.button !== 0)
        return;
      startTime = Date.now();
      once(document, "mouseup", clear2);
      clearInterval(interval);
      interval = setInterval(handler, 100);
    });
  }
};
const Resize = {
  beforeMount(el, binding) {
    el._handleResize = () => {
      var _a2;
      el && ((_a2 = binding.value) == null ? void 0 : _a2.call(binding, el));
    };
    addResizeListener(el, el._handleResize);
  },
  beforeUnmount(el) {
    removeResizeListener(el, el._handleResize);
  }
};
const basicTimeSpinnerProps = buildProps({
  role: {
    type: String,
    required: true
  },
  spinnerDate: {
    type: definePropType(Object),
    required: true
  },
  showSeconds: {
    type: Boolean,
    default: true
  },
  arrowControl: Boolean,
  amPmMode: {
    type: definePropType(String),
    default: ""
  },
  disabledHours: {
    type: definePropType(Function)
  },
  disabledMinutes: {
    type: definePropType(Function)
  },
  disabledSeconds: {
    type: definePropType(Function)
  }
});
const makeList = (total, method, methodFunc) => {
  const arr = [];
  const disabledArr = method && methodFunc();
  for (let i = 0; i < total; i++) {
    arr[i] = disabledArr ? disabledArr.includes(i) : false;
  }
  return arr;
};
const makeAvailableArr = (list) => {
  return list.map((_, index2) => !_ ? index2 : _).filter((_) => _ !== true);
};
const getTimeLists = (disabledHours, disabledMinutes, disabledSeconds) => {
  const getHoursList = (role, compare) => {
    return makeList(24, disabledHours, () => disabledHours(role, compare));
  };
  const getMinutesList = (hour, role, compare) => {
    return makeList(60, disabledMinutes, () => disabledMinutes(hour, role, compare));
  };
  const getSecondsList = (hour, minute, role, compare) => {
    return makeList(60, disabledSeconds, () => disabledSeconds(hour, minute, role, compare));
  };
  return {
    getHoursList,
    getMinutesList,
    getSecondsList
  };
};
const getAvailableArrs = (disabledHours, disabledMinutes, disabledSeconds) => {
  const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(disabledHours, disabledMinutes, disabledSeconds);
  const getAvailableHours = (role, compare) => {
    return makeAvailableArr(getHoursList(role, compare));
  };
  const getAvailableMinutes = (hour, role, compare) => {
    return makeAvailableArr(getMinutesList(hour, role, compare));
  };
  const getAvailableSeconds = (hour, minute, role, compare) => {
    return makeAvailableArr(getSecondsList(hour, minute, role, compare));
  };
  return {
    getAvailableHours,
    getAvailableMinutes,
    getAvailableSeconds
  };
};
const useOldValue = (props) => {
  const oldValue = ref(props.parsedValue);
  watch(() => props.visible, (val) => {
    if (!val) {
      oldValue.value = props.parsedValue;
    }
  });
  return oldValue;
};
const _hoisted_1$d = ["onClick"];
const _hoisted_2$d = ["onMouseenter"];
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  __name: "basic-time-spinner",
  props: basicTimeSpinnerProps,
  emits: ["change", "select-range", "set-option"],
  setup(__props, { emit }) {
    const props = __props;
    const ns2 = useNamespace("time");
    const { getHoursList, getMinutesList, getSecondsList } = getTimeLists(props.disabledHours, props.disabledMinutes, props.disabledSeconds);
    let isScrolling = false;
    const currentScrollbar = ref();
    const listHoursRef = ref();
    const listMinutesRef = ref();
    const listSecondsRef = ref();
    const listRefsMap = {
      hours: listHoursRef,
      minutes: listMinutesRef,
      seconds: listSecondsRef
    };
    const spinnerItems = computed(() => {
      return props.showSeconds ? timeUnits : timeUnits.slice(0, 2);
    });
    const timePartials = computed(() => {
      const { spinnerDate } = props;
      const hours = spinnerDate.hour();
      const minutes = spinnerDate.minute();
      const seconds = spinnerDate.second();
      return { hours, minutes, seconds };
    });
    const timeList = computed(() => {
      const { hours, minutes } = unref(timePartials);
      return {
        hours: getHoursList(props.role),
        minutes: getMinutesList(hours, props.role),
        seconds: getSecondsList(hours, minutes, props.role)
      };
    });
    const arrowControlTimeList = computed(() => {
      const { hours, minutes, seconds } = unref(timePartials);
      return {
        hours: buildTimeList(hours, 23),
        minutes: buildTimeList(minutes, 59),
        seconds: buildTimeList(seconds, 59)
      };
    });
    const debouncedResetScroll = debounce((type) => {
      isScrolling = false;
      adjustCurrentSpinner(type);
    }, 200);
    const getAmPmFlag = (hour) => {
      const shouldShowAmPm = !!props.amPmMode;
      if (!shouldShowAmPm)
        return "";
      const isCapital = props.amPmMode === "A";
      let content = hour < 12 ? " am" : " pm";
      if (isCapital)
        content = content.toUpperCase();
      return content;
    };
    const emitSelectRange = (type) => {
      let range;
      switch (type) {
        case "hours":
          range = [0, 2];
          break;
        case "minutes":
          range = [3, 5];
          break;
        case "seconds":
          range = [6, 8];
          break;
      }
      const [left, right] = range;
      emit("select-range", left, right);
      currentScrollbar.value = type;
    };
    const adjustCurrentSpinner = (type) => {
      adjustSpinner(type, unref(timePartials)[type]);
    };
    const adjustSpinners = () => {
      adjustCurrentSpinner("hours");
      adjustCurrentSpinner("minutes");
      adjustCurrentSpinner("seconds");
    };
    const getScrollbarElement = (el) => el.querySelector(`.${ns2.namespace.value}-scrollbar__wrap`);
    const adjustSpinner = (type, value) => {
      if (props.arrowControl)
        return;
      const scrollbar2 = unref(listRefsMap[type]);
      if (scrollbar2 && scrollbar2.$el) {
        getScrollbarElement(scrollbar2.$el).scrollTop = Math.max(0, value * typeItemHeight(type));
      }
    };
    const typeItemHeight = (type) => {
      const scrollbar2 = unref(listRefsMap[type]);
      return (scrollbar2 == null ? void 0 : scrollbar2.$el.querySelector("li").offsetHeight) || 0;
    };
    const onIncrement = () => {
      scrollDown(1);
    };
    const onDecrement = () => {
      scrollDown(-1);
    };
    const scrollDown = (step) => {
      if (!currentScrollbar.value) {
        emitSelectRange("hours");
      }
      const label = currentScrollbar.value;
      let now2 = unref(timePartials)[label];
      const total = currentScrollbar.value === "hours" ? 24 : 60;
      now2 = (now2 + step + total) % total;
      modifyDateField(label, now2);
      adjustSpinner(label, now2);
      nextTick(() => emitSelectRange(label));
    };
    const modifyDateField = (type, value) => {
      const list = unref(timeList)[type];
      const isDisabled = list[value];
      if (isDisabled)
        return;
      const { hours, minutes, seconds } = unref(timePartials);
      let changeTo;
      switch (type) {
        case "hours":
          changeTo = props.spinnerDate.hour(value).minute(minutes).second(seconds);
          break;
        case "minutes":
          changeTo = props.spinnerDate.hour(hours).minute(value).second(seconds);
          break;
        case "seconds":
          changeTo = props.spinnerDate.hour(hours).minute(minutes).second(value);
          break;
      }
      emit("change", changeTo);
    };
    const handleClick = (type, { value, disabled }) => {
      if (!disabled) {
        modifyDateField(type, value);
        emitSelectRange(type);
        adjustSpinner(type, value);
      }
    };
    const handleScroll = (type) => {
      isScrolling = true;
      debouncedResetScroll(type);
      const value = Math.min(Math.round((getScrollbarElement(unref(listRefsMap[type]).$el).scrollTop - (scrollBarHeight(type) * 0.5 - 10) / typeItemHeight(type) + 3) / typeItemHeight(type)), type === "hours" ? 23 : 59);
      modifyDateField(type, value);
    };
    const scrollBarHeight = (type) => {
      return unref(listRefsMap[type]).$el.offsetHeight;
    };
    const bindScrollEvent = () => {
      const bindFunction = (type) => {
        const scrollbar2 = unref(listRefsMap[type]);
        if (scrollbar2 && scrollbar2.$el) {
          getScrollbarElement(scrollbar2.$el).onscroll = () => {
            handleScroll(type);
          };
        }
      };
      bindFunction("hours");
      bindFunction("minutes");
      bindFunction("seconds");
    };
    onMounted(() => {
      nextTick(() => {
        !props.arrowControl && bindScrollEvent();
        adjustSpinners();
        if (props.role === "start")
          emitSelectRange("hours");
      });
    });
    const setRef2 = (scrollbar2, type) => {
      listRefsMap[type].value = scrollbar2;
    };
    emit("set-option", [`${props.role}_scrollDown`, scrollDown]);
    emit("set-option", [`${props.role}_emitSelectRange`, emitSelectRange]);
    watch(() => props.spinnerDate, () => {
      if (isScrolling)
        return;
      adjustSpinners();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([unref(ns2).b("spinner"), { "has-seconds": _ctx.showSeconds }])
      }, [
        !_ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(unref(spinnerItems), (item) => {
          return openBlock(), createBlock(unref(ElScrollbar), {
            key: item,
            ref_for: true,
            ref: (scollbar) => setRef2(scollbar, item),
            class: normalizeClass(unref(ns2).be("spinner", "wrapper")),
            "wrap-style": "max-height: inherit;",
            "view-class": unref(ns2).be("spinner", "list"),
            noresize: "",
            tag: "ul",
            onMouseenter: ($event) => emitSelectRange(item),
            onMousemove: ($event) => adjustCurrentSpinner(item)
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(timeList)[item], (disabled, key) => {
                return openBlock(), createElementBlock("li", {
                  key,
                  class: normalizeClass([
                    unref(ns2).be("spinner", "item"),
                    unref(ns2).is("active", key === unref(timePartials)[item]),
                    unref(ns2).is("disabled", disabled)
                  ]),
                  onClick: ($event) => handleClick(item, { value: key, disabled })
                }, [
                  item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? key % 12 || 12 : key)).slice(-2)) + toDisplayString(getAmPmFlag(key)), 1)
                  ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(("0" + key).slice(-2)), 1)
                  ], 64))
                ], 10, _hoisted_1$d);
              }), 128))
            ]),
            _: 2
          }, 1032, ["class", "view-class", "onMouseenter", "onMousemove"]);
        }), 128)) : createCommentVNode("v-if", true),
        _ctx.arrowControl ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(spinnerItems), (item) => {
          return openBlock(), createElementBlock("div", {
            key: item,
            class: normalizeClass([unref(ns2).be("spinner", "wrapper"), unref(ns2).is("arrow")]),
            onMouseenter: ($event) => emitSelectRange(item)
          }, [
            withDirectives((openBlock(), createBlock(unref(ElIcon), {
              class: normalizeClass(["arrow-up", unref(ns2).be("spinner", "arrow")])
            }, {
              default: withCtx(() => [
                createVNode(unref(arrow_up_default))
              ]),
              _: 1
            }, 8, ["class"])), [
              [unref(vRepeatClick), onDecrement]
            ]),
            withDirectives((openBlock(), createBlock(unref(ElIcon), {
              class: normalizeClass(["arrow-down", unref(ns2).be("spinner", "arrow")])
            }, {
              default: withCtx(() => [
                createVNode(unref(arrow_down_default))
              ]),
              _: 1
            }, 8, ["class"])), [
              [unref(vRepeatClick), onIncrement]
            ]),
            createBaseVNode("ul", {
              class: normalizeClass(unref(ns2).be("spinner", "list"))
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(arrowControlTimeList)[item], (time, key) => {
                return openBlock(), createElementBlock("li", {
                  key,
                  class: normalizeClass([
                    unref(ns2).be("spinner", "item"),
                    unref(ns2).is("active", time === unref(timePartials)[item]),
                    unref(ns2).is("disabled", unref(timeList)[item][time])
                  ])
                }, [
                  typeof time === "number" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                    item === "hours" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                      createTextVNode(toDisplayString(("0" + (_ctx.amPmMode ? time % 12 || 12 : time)).slice(-2)) + toDisplayString(getAmPmFlag(time)), 1)
                    ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(("0" + time).slice(-2)), 1)
                    ], 64))
                  ], 64)) : createCommentVNode("v-if", true)
                ], 2);
              }), 128))
            ], 2)
          ], 42, _hoisted_2$d);
        }), 128)) : createCommentVNode("v-if", true)
      ], 2);
    };
  }
});
var TimeSpinner = /* @__PURE__ */ _export_sfc$1(_sfc_main$j, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/basic-time-spinner.vue"]]);
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  __name: "panel-time-pick",
  props: panelTimePickerProps,
  emits: ["pick", "select-range", "set-picker-option"],
  setup(__props, { emit }) {
    const props = __props;
    const pickerBase = inject("EP_PICKER_BASE");
    const {
      arrowControl,
      disabledHours,
      disabledMinutes,
      disabledSeconds,
      defaultValue
    } = pickerBase.props;
    const { getAvailableHours, getAvailableMinutes, getAvailableSeconds } = getAvailableArrs(disabledHours, disabledMinutes, disabledSeconds);
    const ns2 = useNamespace("time");
    const { t, lang } = useLocale();
    const selectionRange = ref([0, 2]);
    const oldValue = useOldValue(props);
    const transitionName = computed(() => {
      return isUndefined(props.actualVisible) ? `${ns2.namespace.value}-zoom-in-top` : "";
    });
    const showSeconds = computed(() => {
      return props.format.includes("ss");
    });
    const amPmMode = computed(() => {
      if (props.format.includes("A"))
        return "A";
      if (props.format.includes("a"))
        return "a";
      return "";
    });
    const isValidValue = (_date) => {
      const parsedDate = dayjs(_date).locale(lang.value);
      const result = getRangeAvailableTime(parsedDate);
      return parsedDate.isSame(result);
    };
    const handleCancel = () => {
      emit("pick", oldValue.value, false);
    };
    const handleConfirm = (visible = false, first = false) => {
      if (first)
        return;
      emit("pick", props.parsedValue, visible);
    };
    const handleChange = (_date) => {
      if (!props.visible) {
        return;
      }
      const result = getRangeAvailableTime(_date).millisecond(0);
      emit("pick", result, true);
    };
    const setSelectionRange = (start, end) => {
      emit("select-range", start, end);
      selectionRange.value = [start, end];
    };
    const changeSelectionRange = (step) => {
      const list = [0, 3].concat(showSeconds.value ? [6] : []);
      const mapping = ["hours", "minutes"].concat(showSeconds.value ? ["seconds"] : []);
      const index2 = list.indexOf(selectionRange.value[0]);
      const next = (index2 + step + list.length) % list.length;
      timePickerOptions["start_emitSelectRange"](mapping[next]);
    };
    const handleKeydown = (event) => {
      const code = event.code;
      const { left, right, up, down } = EVENT_CODE;
      if ([left, right].includes(code)) {
        const step = code === left ? -1 : 1;
        changeSelectionRange(step);
        event.preventDefault();
        return;
      }
      if ([up, down].includes(code)) {
        const step = code === up ? -1 : 1;
        timePickerOptions["start_scrollDown"](step);
        event.preventDefault();
        return;
      }
    };
    const { timePickerOptions, onSetOption, getAvailableTime } = useTimePanel({
      getAvailableHours,
      getAvailableMinutes,
      getAvailableSeconds
    });
    const getRangeAvailableTime = (date2) => {
      return getAvailableTime(date2, props.datetimeRole || "", true);
    };
    const parseUserInput = (value) => {
      if (!value)
        return null;
      return dayjs(value, props.format).locale(lang.value);
    };
    const formatToString = (value) => {
      if (!value)
        return null;
      return value.format(props.format);
    };
    const getDefaultValue2 = () => {
      return dayjs(defaultValue).locale(lang.value);
    };
    emit("set-picker-option", ["isValidValue", isValidValue]);
    emit("set-picker-option", ["formatToString", formatToString]);
    emit("set-picker-option", ["parseUserInput", parseUserInput]);
    emit("set-picker-option", ["handleKeydownInput", handleKeydown]);
    emit("set-picker-option", ["getRangeAvailableTime", getRangeAvailableTime]);
    emit("set-picker-option", ["getDefaultValue", getDefaultValue2]);
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, { name: unref(transitionName) }, {
        default: withCtx(() => [
          _ctx.actualVisible || _ctx.visible ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(ns2).b("panel"))
          }, [
            createBaseVNode("div", {
              class: normalizeClass([unref(ns2).be("panel", "content"), { "has-seconds": unref(showSeconds) }])
            }, [
              createVNode(TimeSpinner, {
                ref: "spinner",
                role: _ctx.datetimeRole || "start",
                "arrow-control": unref(arrowControl),
                "show-seconds": unref(showSeconds),
                "am-pm-mode": unref(amPmMode),
                "spinner-date": _ctx.parsedValue,
                "disabled-hours": unref(disabledHours),
                "disabled-minutes": unref(disabledMinutes),
                "disabled-seconds": unref(disabledSeconds),
                onChange: handleChange,
                onSetOption: unref(onSetOption),
                onSelectRange: setSelectionRange
              }, null, 8, ["role", "arrow-control", "show-seconds", "am-pm-mode", "spinner-date", "disabled-hours", "disabled-minutes", "disabled-seconds", "onSetOption"])
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass(unref(ns2).be("panel", "footer"))
            }, [
              createBaseVNode("button", {
                type: "button",
                class: normalizeClass([unref(ns2).be("panel", "btn"), "cancel"]),
                onClick: handleCancel
              }, toDisplayString(unref(t)("el.datepicker.cancel")), 3),
              createBaseVNode("button", {
                type: "button",
                class: normalizeClass([unref(ns2).be("panel", "btn"), "confirm"]),
                onClick: _cache[0] || (_cache[0] = ($event) => handleConfirm())
              }, toDisplayString(unref(t)("el.datepicker.confirm")), 3)
            ], 2)
          ], 2)) : createCommentVNode("v-if", true)
        ]),
        _: 1
      }, 8, ["name"]);
    };
  }
});
var TimePickPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$i, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/time-picker/src/time-picker-com/panel-time-pick.vue"]]);
const tagProps = buildProps({
  closable: Boolean,
  type: {
    type: String,
    values: ["success", "info", "warning", "danger", ""],
    default: ""
  },
  hit: Boolean,
  disableTransitions: Boolean,
  color: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    values: componentSizes,
    default: ""
  },
  effect: {
    type: String,
    values: ["dark", "light", "plain"],
    default: "light"
  },
  round: Boolean
});
const tagEmits = {
  close: (evt) => evt instanceof MouseEvent,
  click: (evt) => evt instanceof MouseEvent
};
const __default__$2 = {
  name: "ElTag"
};
const _sfc_main$h = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$2), {
  props: tagProps,
  emits: tagEmits,
  setup(__props, { emit }) {
    const props = __props;
    const tagSize = useSize();
    const ns2 = useNamespace("tag");
    const classes = computed(() => {
      const { type, hit, effect: effect2, closable, round } = props;
      return [
        ns2.b(),
        ns2.is("closable", closable),
        ns2.m(type),
        ns2.m(tagSize.value),
        ns2.m(effect2),
        ns2.is("hit", hit),
        ns2.is("round", round)
      ];
    });
    const handleClose = (event) => {
      emit("close", event);
    };
    const handleClick = (event) => {
      emit("click", event);
    };
    return (_ctx, _cache) => {
      return _ctx.disableTransitions ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass(unref(classes)),
        style: normalizeStyle({ backgroundColor: _ctx.color }),
        onClick: handleClick
      }, [
        createBaseVNode("span", {
          class: normalizeClass(unref(ns2).e("content"))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2),
        _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
          key: 0,
          class: normalizeClass(unref(ns2).e("close")),
          onClick: withModifiers(handleClose, ["stop"])
        }, {
          default: withCtx(() => [
            createVNode(unref(close_default))
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
      ], 6)) : (openBlock(), createBlock(Transition, {
        key: 1,
        name: `${unref(ns2).namespace.value}-zoom-in-center`,
        appear: ""
      }, {
        default: withCtx(() => [
          createBaseVNode("span", {
            class: normalizeClass(unref(classes)),
            style: normalizeStyle({ backgroundColor: _ctx.color }),
            onClick: handleClick
          }, [
            createBaseVNode("span", {
              class: normalizeClass(unref(ns2).e("content"))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 2),
            _ctx.closable ? (openBlock(), createBlock(unref(ElIcon), {
              key: 0,
              class: normalizeClass(unref(ns2).e("close")),
              onClick: withModifiers(handleClose, ["stop"])
            }, {
              default: withCtx(() => [
                createVNode(unref(close_default))
              ]),
              _: 1
            }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
          ], 6)
        ]),
        _: 3
      }, 8, ["name"]));
    };
  }
}));
var Tag = /* @__PURE__ */ _export_sfc$1(_sfc_main$h, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/tag/src/tag.vue"]]);
const ElTag = withInstall(Tag);
const __default__$1 = {
  name: "ElCollapseTransition"
};
const _sfc_main$g = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__$1), {
  setup(__props) {
    const ns2 = useNamespace("collapse-transition");
    const on2 = {
      beforeEnter(el) {
        if (!el.dataset)
          el.dataset = {};
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.style.maxHeight = 0;
        el.style.paddingTop = 0;
        el.style.paddingBottom = 0;
      },
      enter(el) {
        el.dataset.oldOverflow = el.style.overflow;
        if (el.scrollHeight !== 0) {
          el.style.maxHeight = `${el.scrollHeight}px`;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        } else {
          el.style.maxHeight = 0;
          el.style.paddingTop = el.dataset.oldPaddingTop;
          el.style.paddingBottom = el.dataset.oldPaddingBottom;
        }
        el.style.overflow = "hidden";
      },
      afterEnter(el) {
        el.style.maxHeight = "";
        el.style.overflow = el.dataset.oldOverflow;
      },
      beforeLeave(el) {
        if (!el.dataset)
          el.dataset = {};
        el.dataset.oldPaddingTop = el.style.paddingTop;
        el.dataset.oldPaddingBottom = el.style.paddingBottom;
        el.dataset.oldOverflow = el.style.overflow;
        el.style.maxHeight = `${el.scrollHeight}px`;
        el.style.overflow = "hidden";
      },
      leave(el) {
        if (el.scrollHeight !== 0) {
          el.style.maxHeight = 0;
          el.style.paddingTop = 0;
          el.style.paddingBottom = 0;
        }
      },
      afterLeave(el) {
        el.style.maxHeight = "";
        el.style.overflow = el.dataset.oldOverflow;
        el.style.paddingTop = el.dataset.oldPaddingTop;
        el.style.paddingBottom = el.dataset.oldPaddingBottom;
      }
    };
    return (_ctx, _cache) => {
      return openBlock(), createBlock(Transition, mergeProps({
        name: unref(ns2).b()
      }, toHandlers(on2)), {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default")
        ]),
        _: 3
      }, 16, ["name"]);
    };
  }
}));
var CollapseTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$g, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/collapse-transition/src/collapse-transition.vue"]]);
CollapseTransition.install = (app) => {
  app.component(CollapseTransition.name, CollapseTransition);
};
const _CollapseTransition = CollapseTransition;
const messageConfig = {};
const configProviderProps = buildProps({
  a11y: {
    type: Boolean,
    default: true
  },
  locale: {
    type: definePropType(Object)
  },
  size: useSizeProp,
  button: {
    type: definePropType(Object)
  },
  experimentalFeatures: {
    type: definePropType(Object)
  },
  keyboardNavigation: {
    type: Boolean,
    default: true
  },
  message: {
    type: definePropType(Object)
  },
  zIndex: Number,
  namespace: {
    type: String,
    default: "el"
  }
});
const ConfigProvider = defineComponent({
  name: "ElConfigProvider",
  props: configProviderProps,
  setup(props, { slots }) {
    watch(() => props.message, (val) => {
      Object.assign(messageConfig, val != null ? val : {});
    }, { immediate: true, deep: true });
    const config = provideGlobalConfig(props);
    return () => renderSlot(slots, "default", { config: config == null ? void 0 : config.value });
  }
});
const ElConfigProvider = withInstall(ConfigProvider);
var advancedFormat$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t, r) {
      var n = t.prototype, s = n.format;
      r.en.ordinal = function(e2) {
        var t2 = ["th", "st", "nd", "rd"], r2 = e2 % 100;
        return "[" + e2 + (t2[(r2 - 20) % 10] || t2[r2] || t2[0]) + "]";
      }, n.format = function(e2) {
        var t2 = this, r2 = this.$locale();
        if (!this.isValid())
          return s.bind(this)(e2);
        var n2 = this.$utils(), a = (e2 || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(e3) {
          switch (e3) {
            case "Q":
              return Math.ceil((t2.$M + 1) / 3);
            case "Do":
              return r2.ordinal(t2.$D);
            case "gggg":
              return t2.weekYear();
            case "GGGG":
              return t2.isoWeekYear();
            case "wo":
              return r2.ordinal(t2.week(), "W");
            case "w":
            case "ww":
              return n2.s(t2.week(), e3 === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return n2.s(t2.isoWeek(), e3 === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return n2.s(String(t2.$H === 0 ? 24 : t2.$H), e3 === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(t2.$d.getTime() / 1e3);
            case "x":
              return t2.$d.getTime();
            case "z":
              return "[" + t2.offsetName() + "]";
            case "zzz":
              return "[" + t2.offsetName("long") + "]";
            default:
              return e3;
          }
        });
        return s.bind(this)(a);
      };
    };
  });
})(advancedFormat$1);
var advancedFormat = advancedFormat$1.exports;
var weekOfYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    var e = "week", t = "year";
    return function(i, n, r) {
      var f = n.prototype;
      f.week = function(i2) {
        if (i2 === void 0 && (i2 = null), i2 !== null)
          return this.add(7 * (i2 - this.week()), "day");
        var n2 = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var f2 = r(this).startOf(t).add(1, t).date(n2), s = r(this).endOf(e);
          if (f2.isBefore(s))
            return 1;
        }
        var a = r(this).startOf(t).date(n2).startOf(e).subtract(1, "millisecond"), o = this.diff(a, e, true);
        return o < 0 ? r(this).startOf("week").week() : Math.ceil(o);
      }, f.weeks = function(e2) {
        return e2 === void 0 && (e2 = null), this.week(e2);
      };
    };
  });
})(weekOfYear$1);
var weekOfYear = weekOfYear$1.exports;
var weekYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.weekYear = function() {
        var e2 = this.month(), t2 = this.week(), n = this.year();
        return t2 === 1 && e2 === 11 ? n + 1 : e2 === 0 && t2 >= 52 ? n - 1 : n;
      };
    };
  });
})(weekYear$1);
var weekYear = weekYear$1.exports;
var dayOfYear$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t, n) {
      t.prototype.dayOfYear = function(e2) {
        var t2 = Math.round((n(this).startOf("day") - n(this).startOf("year")) / 864e5) + 1;
        return e2 == null ? t2 : this.add(e2 - t2, "day");
      };
    };
  });
})(dayOfYear$1);
var dayOfYear = dayOfYear$1.exports;
var isSameOrAfter$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal, function() {
    return function(e, t) {
      t.prototype.isSameOrAfter = function(e2, t2) {
        return this.isSame(e2, t2) || this.isAfter(e2, t2);
      };
    };
  });
})(isSameOrAfter$1);
var isSameOrAfter = isSameOrAfter$1.exports;
var isSameOrBefore$1 = { exports: {} };
(function(module2, exports2) {
  !function(e, i) {
    module2.exports = i();
  }(commonjsGlobal, function() {
    return function(e, i) {
      i.prototype.isSameOrBefore = function(e2, i2) {
        return this.isSame(e2, i2) || this.isBefore(e2, i2);
      };
    };
  });
})(isSameOrBefore$1);
var isSameOrBefore = isSameOrBefore$1.exports;
const datePickerProps = buildProps({
  type: {
    type: definePropType(String),
    default: "date"
  }
});
const selectionModes = ["date", "dates", "year", "month", "week", "range"];
const datePickerSharedProps = buildProps({
  disabledDate: {
    type: definePropType(Function)
  },
  date: {
    type: definePropType(Object),
    required: true
  },
  minDate: {
    type: definePropType(Object)
  },
  maxDate: {
    type: definePropType(Object)
  },
  parsedValue: {
    type: definePropType([Object, Array])
  },
  rangeState: {
    type: definePropType(Object),
    default: () => ({
      endDate: null,
      selecting: false
    })
  }
});
const panelSharedProps = buildProps({
  type: {
    type: definePropType(String),
    required: true,
    values: datePickTypes
  }
});
const panelRangeSharedProps = buildProps({
  unlinkPanels: Boolean,
  parsedValue: {
    type: definePropType(Array)
  }
});
const selectionModeWithDefault = (mode) => {
  return {
    type: String,
    values: selectionModes,
    default: mode
  };
};
const panelDatePickProps = buildProps(__spreadProps(__spreadValues({}, panelSharedProps), {
  parsedValue: {
    type: definePropType([Object, Array])
  },
  visible: {
    type: Boolean
  },
  format: {
    type: String,
    default: ""
  }
}));
const basicDateTableProps = buildProps(__spreadProps(__spreadValues({}, datePickerSharedProps), {
  cellClassName: {
    type: definePropType(Function)
  },
  showWeekNumber: Boolean,
  selectionMode: selectionModeWithDefault("date")
}));
const isValidRange = (range) => {
  if (!isArray$2(range))
    return false;
  const [left, right] = range;
  return dayjs.isDayjs(left) && dayjs.isDayjs(right) && left.isSameOrBefore(right);
};
const getDefaultValue = (defaultValue, { lang, unit, unlinkPanels }) => {
  let start;
  if (isArray$2(defaultValue)) {
    let [left, right] = defaultValue.map((d) => dayjs(d).locale(lang));
    if (!unlinkPanels) {
      right = left.add(1, unit);
    }
    return [left, right];
  } else if (defaultValue) {
    start = dayjs(defaultValue);
  } else {
    start = dayjs();
  }
  start = start.locale(lang);
  return [start, start.add(1, unit)];
};
const buildPickerTable = (dimension, rows, {
  columnIndexOffset,
  startDate,
  nextEndDate,
  now: now2,
  unit,
  relativeDateGetter,
  setCellMetadata,
  setRowMetadata
}) => {
  for (let rowIndex = 0; rowIndex < dimension.row; rowIndex++) {
    const row = rows[rowIndex];
    for (let columnIndex = 0; columnIndex < dimension.column; columnIndex++) {
      let cell = row[columnIndex + columnIndexOffset];
      if (!cell) {
        cell = {
          row: rowIndex,
          column: columnIndex,
          type: "normal",
          inRange: false,
          start: false,
          end: false
        };
      }
      const index2 = rowIndex * dimension.column + columnIndex;
      const nextStartDate = relativeDateGetter(index2);
      cell.dayjs = nextStartDate;
      cell.date = nextStartDate.toDate();
      cell.timestamp = nextStartDate.valueOf();
      cell.type = "normal";
      cell.inRange = !!(startDate && nextStartDate.isSameOrAfter(startDate, unit) && nextEndDate && nextStartDate.isSameOrBefore(nextEndDate, unit)) || !!(startDate && nextStartDate.isSameOrBefore(startDate, unit) && nextEndDate && nextStartDate.isSameOrAfter(nextEndDate, unit));
      if (startDate == null ? void 0 : startDate.isSameOrAfter(nextEndDate)) {
        cell.start = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit);
        cell.end = startDate && nextStartDate.isSame(startDate, unit);
      } else {
        cell.start = !!startDate && nextStartDate.isSame(startDate, unit);
        cell.end = !!nextEndDate && nextStartDate.isSame(nextEndDate, unit);
      }
      const isToday = nextStartDate.isSame(now2, unit);
      if (isToday) {
        cell.type = "today";
      }
      setCellMetadata == null ? void 0 : setCellMetadata(cell, { rowIndex, columnIndex });
      row[columnIndex + columnIndexOffset] = cell;
    }
    setRowMetadata == null ? void 0 : setRowMetadata(row);
  }
};
const basicCellProps = buildProps({
  cell: {
    type: definePropType(Object)
  }
});
var ElDatePickerCell = defineComponent({
  name: "ElDatePickerCell",
  props: basicCellProps,
  setup(props) {
    const ns2 = useNamespace("date-table-cell");
    const {
      slots
    } = inject(ROOT_PICKER_INJECTION_KEY);
    return () => {
      const {
        cell
      } = props;
      if (slots.default) {
        const list = slots.default(cell).filter((item) => {
          return item.patchFlag !== -2 && item.type.toString() !== "Symbol(Comment)";
        });
        if (list.length) {
          return list;
        }
      }
      return createVNode("div", {
        "class": ns2.b()
      }, [createVNode("span", {
        "class": ns2.e("text")
      }, [cell == null ? void 0 : cell.text])]);
    };
  }
});
const _hoisted_1$c = ["aria-label"];
const _hoisted_2$c = {
  key: 0,
  scope: "col"
};
const _hoisted_3$8 = ["aria-label"];
const _hoisted_4$6 = ["aria-current", "aria-selected", "tabindex"];
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  __name: "basic-date-table",
  props: basicDateTableProps,
  emits: ["changerange", "pick", "select"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const ns2 = useNamespace("date-table");
    const { t, lang } = useLocale();
    const tbodyRef = ref();
    const currentCellRef = ref();
    const lastRow = ref();
    const lastColumn = ref();
    const tableRows = ref([[], [], [], [], [], []]);
    const firstDayOfWeek = props.date.$locale().weekStart || 7;
    const WEEKS_CONSTANT = props.date.locale("en").localeData().weekdaysShort().map((_) => _.toLowerCase());
    const offsetDay = computed(() => {
      return firstDayOfWeek > 3 ? 7 - firstDayOfWeek : -firstDayOfWeek;
    });
    const startDate = computed(() => {
      const startDayOfMonth = props.date.startOf("month");
      return startDayOfMonth.subtract(startDayOfMonth.day() || 7, "day");
    });
    const WEEKS = computed(() => {
      return WEEKS_CONSTANT.concat(WEEKS_CONSTANT).slice(firstDayOfWeek, firstDayOfWeek + 7);
    });
    const hasCurrent = computed(() => {
      return rows.value.flat().some((row) => {
        return row.isCurrent;
      });
    });
    const days = computed(() => {
      const startOfMonth = props.date.startOf("month");
      const startOfMonthDay = startOfMonth.day() || 7;
      const dateCountOfMonth = startOfMonth.daysInMonth();
      const dateCountOfLastMonth = startOfMonth.subtract(1, "month").daysInMonth();
      return {
        startOfMonthDay,
        dateCountOfMonth,
        dateCountOfLastMonth
      };
    });
    const selectedDate = computed(() => {
      return props.selectionMode === "dates" ? castArray(props.parsedValue) : [];
    });
    const setDateText = (cell, {
      count,
      rowIndex,
      columnIndex
    }) => {
      const { startOfMonthDay, dateCountOfMonth, dateCountOfLastMonth } = unref(days);
      const offset = unref(offsetDay);
      if (rowIndex >= 0 && rowIndex <= 1) {
        const numberOfDaysFromPreviousMonth = startOfMonthDay + offset < 0 ? 7 + startOfMonthDay + offset : startOfMonthDay + offset;
        if (columnIndex + rowIndex * 7 >= numberOfDaysFromPreviousMonth) {
          cell.text = count;
          return true;
        } else {
          cell.text = dateCountOfLastMonth - (numberOfDaysFromPreviousMonth - columnIndex % 7) + 1 + rowIndex * 7;
          cell.type = "prev-month";
        }
      } else {
        if (count <= dateCountOfMonth) {
          cell.text = count;
        } else {
          cell.text = count - dateCountOfMonth;
          cell.type = "next-month";
        }
        return true;
      }
      return false;
    };
    const setCellMetadata = (cell, {
      columnIndex,
      rowIndex
    }, count) => {
      const { disabledDate: disabledDate2, cellClassName } = props;
      const _selectedDate = unref(selectedDate);
      const shouldIncrement = setDateText(cell, { count, rowIndex, columnIndex });
      const cellDate = cell.dayjs.toDate();
      cell.selected = _selectedDate.find((d) => d.valueOf() === cell.dayjs.valueOf());
      cell.isSelected = !!cell.selected;
      cell.isCurrent = isCurrent(cell);
      cell.disabled = disabledDate2 == null ? void 0 : disabledDate2(cellDate);
      cell.customClass = cellClassName == null ? void 0 : cellClassName(cellDate);
      return shouldIncrement;
    };
    const setRowMetadata = (row) => {
      if (props.selectionMode === "week") {
        const [start, end] = props.showWeekNumber ? [1, 7] : [0, 6];
        const isActive = isWeekActive(row[start + 1]);
        row[start].inRange = isActive;
        row[start].start = isActive;
        row[end].inRange = isActive;
        row[end].end = isActive;
      }
    };
    const rows = computed(() => {
      const { minDate, maxDate, rangeState, showWeekNumber } = props;
      const offset = offsetDay.value;
      const rows_ = tableRows.value;
      const dateUnit = "day";
      let count = 1;
      if (showWeekNumber) {
        for (let rowIndex = 0; rowIndex < 6; rowIndex++) {
          if (!rows_[rowIndex][0]) {
            rows_[rowIndex][0] = {
              type: "week",
              text: startDate.value.add(rowIndex * 7 + 1, dateUnit).week()
            };
          }
        }
      }
      buildPickerTable({ row: 6, column: 7 }, rows_, {
        startDate: minDate,
        columnIndexOffset: showWeekNumber ? 1 : 0,
        nextEndDate: rangeState.endDate || maxDate || rangeState.selecting && minDate || null,
        now: dayjs().locale(unref(lang)).startOf(dateUnit),
        unit: dateUnit,
        relativeDateGetter: (idx) => startDate.value.add(idx - offset, dateUnit),
        setCellMetadata: (...args) => {
          if (setCellMetadata(...args, count)) {
            count += 1;
          }
        },
        setRowMetadata
      });
      return rows_;
    });
    watch(() => props.date, async () => {
      var _a2, _b;
      if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
        await nextTick();
        (_b = currentCellRef.value) == null ? void 0 : _b.focus();
      }
    });
    const focus = async () => {
      var _a2;
      (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
    };
    const isNormalDay = (type = "") => {
      return ["normal", "today"].includes(type);
    };
    const isCurrent = (cell) => {
      return props.selectionMode === "date" && isNormalDay(cell.type) && cellMatchesDate(cell, props.parsedValue);
    };
    const cellMatchesDate = (cell, date2) => {
      if (!date2)
        return false;
      return dayjs(date2).locale(lang.value).isSame(props.date.date(Number(cell.text)), "day");
    };
    const getCellClasses = (cell) => {
      const classes = [];
      if (isNormalDay(cell.type) && !cell.disabled) {
        classes.push("available");
        if (cell.type === "today") {
          classes.push("today");
        }
      } else {
        classes.push(cell.type);
      }
      if (isCurrent(cell)) {
        classes.push("current");
      }
      if (cell.inRange && (isNormalDay(cell.type) || props.selectionMode === "week")) {
        classes.push("in-range");
        if (cell.start) {
          classes.push("start-date");
        }
        if (cell.end) {
          classes.push("end-date");
        }
      }
      if (cell.disabled) {
        classes.push("disabled");
      }
      if (cell.selected) {
        classes.push("selected");
      }
      if (cell.customClass) {
        classes.push(cell.customClass);
      }
      return classes.join(" ");
    };
    const getDateOfCell = (row, column) => {
      const offsetFromStart = row * 7 + (column - (props.showWeekNumber ? 1 : 0)) - offsetDay.value;
      return startDate.value.add(offsetFromStart, "day");
    };
    const handleMouseMove = (event) => {
      var _a2;
      if (!props.rangeState.selecting)
        return;
      let target = event.target;
      if (target.tagName === "SPAN") {
        target = (_a2 = target.parentNode) == null ? void 0 : _a2.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      if (rows.value[row][column].disabled)
        return;
      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        emit("changerange", {
          selecting: true,
          endDate: getDateOfCell(row, column)
        });
      }
    };
    const isSelectedCell = (cell) => {
      return !hasCurrent.value && (cell == null ? void 0 : cell.text) === 1 && cell.type === "normal" || cell.isCurrent;
    };
    const handleFocus = (event) => {
      if (!hasCurrent.value && props.selectionMode === "date") {
        handlePickDate(event, true);
      }
    };
    const handlePickDate = (event, isKeyboardMovement = false) => {
      const target = event.target.closest("td");
      if (!target || target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex - 1;
      const column = target.cellIndex;
      const cell = rows.value[row][column];
      if (cell.disabled || cell.type === "week")
        return;
      const newDate = getDateOfCell(row, column);
      if (props.selectionMode === "range") {
        if (!props.rangeState.selecting || !props.minDate) {
          emit("pick", { minDate: newDate, maxDate: null });
          emit("select", true);
        } else {
          if (newDate >= props.minDate) {
            emit("pick", { minDate: props.minDate, maxDate: newDate });
          } else {
            emit("pick", { minDate: newDate, maxDate: props.minDate });
          }
          emit("select", false);
        }
      } else if (props.selectionMode === "date") {
        emit("pick", newDate, isKeyboardMovement);
      } else if (props.selectionMode === "week") {
        const weekNumber = newDate.week();
        const value = `${newDate.year()}w${weekNumber}`;
        emit("pick", {
          year: newDate.year(),
          week: weekNumber,
          value,
          date: newDate.startOf("week")
        });
      } else if (props.selectionMode === "dates") {
        const newValue = cell.selected ? castArray(props.parsedValue).filter((d) => (d == null ? void 0 : d.valueOf()) !== newDate.valueOf()) : castArray(props.parsedValue).concat([newDate]);
        emit("pick", newValue);
      }
    };
    const isWeekActive = (cell) => {
      if (props.selectionMode !== "week")
        return false;
      let newDate = props.date.startOf("day");
      if (cell.type === "prev-month") {
        newDate = newDate.subtract(1, "month");
      }
      if (cell.type === "next-month") {
        newDate = newDate.add(1, "month");
      }
      newDate = newDate.date(Number.parseInt(cell.text, 10));
      if (props.parsedValue && !Array.isArray(props.parsedValue)) {
        const dayOffset = (props.parsedValue.day() - firstDayOfWeek + 7) % 7 - 1;
        const weekDate = props.parsedValue.subtract(dayOffset, "day");
        return weekDate.isSame(newDate, "day");
      }
      return false;
    };
    expose({
      focus
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("table", {
        role: "grid",
        "aria-label": unref(t)("el.datepicker.dateTablePrompt"),
        cellspacing: "0",
        cellpadding: "0",
        class: normalizeClass([unref(ns2).b(), { "is-week-mode": _ctx.selectionMode === "week" }]),
        onClick: handlePickDate,
        onMousemove: handleMouseMove
      }, [
        createBaseVNode("tbody", {
          ref_key: "tbodyRef",
          ref: tbodyRef
        }, [
          createBaseVNode("tr", null, [
            _ctx.showWeekNumber ? (openBlock(), createElementBlock("th", _hoisted_2$c, toDisplayString(unref(t)("el.datepicker.week")), 1)) : createCommentVNode("v-if", true),
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(WEEKS), (week, key) => {
              return openBlock(), createElementBlock("th", {
                key,
                scope: "col",
                "aria-label": unref(t)("el.datepicker.weeksFull." + week)
              }, toDisplayString(unref(t)("el.datepicker.weeks." + week)), 9, _hoisted_3$8);
            }), 128))
          ]),
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, rowKey) => {
            return openBlock(), createElementBlock("tr", {
              key: rowKey,
              class: normalizeClass([unref(ns2).e("row"), { current: isWeekActive(row[1]) }])
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, columnKey) => {
                return openBlock(), createElementBlock("td", {
                  key: `${rowKey}.${columnKey}`,
                  ref_for: true,
                  ref: (el) => {
                    isSelectedCell(cell) && (currentCellRef.value = el);
                  },
                  class: normalizeClass(getCellClasses(cell)),
                  "aria-current": cell.isCurrent ? "date" : void 0,
                  "aria-selected": cell.isCurrent,
                  tabindex: isSelectedCell(cell) ? 0 : -1,
                  onFocus: handleFocus
                }, [
                  createVNode(unref(ElDatePickerCell), { cell }, null, 8, ["cell"])
                ], 42, _hoisted_4$6);
              }), 128))
            ], 2);
          }), 128))
        ], 512)
      ], 42, _hoisted_1$c);
    };
  }
});
var DateTable = /* @__PURE__ */ _export_sfc$1(_sfc_main$f, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-date-table.vue"]]);
const basicMonthTableProps = buildProps(__spreadProps(__spreadValues({}, datePickerSharedProps), {
  selectionMode: selectionModeWithDefault("month")
}));
const _hoisted_1$b = ["aria-label"];
const _hoisted_2$b = ["aria-selected", "aria-label", "tabindex", "onKeydown"];
const _hoisted_3$7 = { class: "cell" };
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  __name: "basic-month-table",
  props: basicMonthTableProps,
  emits: ["changerange", "pick", "select"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const datesInMonth = (year, month, lang2) => {
      const firstDay = dayjs().locale(lang2).startOf("month").month(month).year(year);
      const numOfDays = firstDay.daysInMonth();
      return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
    };
    const ns2 = useNamespace("month-table");
    const { t, lang } = useLocale();
    const tbodyRef = ref();
    const currentCellRef = ref();
    const months = ref(props.date.locale("en").localeData().monthsShort().map((_) => _.toLowerCase()));
    const tableRows = ref([
      [],
      [],
      []
    ]);
    const lastRow = ref();
    const lastColumn = ref();
    const rows = computed(() => {
      var _a2, _b;
      const rows2 = tableRows.value;
      const now2 = dayjs().locale(lang.value).startOf("month");
      for (let i = 0; i < 3; i++) {
        const row = rows2[i];
        for (let j = 0; j < 4; j++) {
          const cell = row[j] || (row[j] = {
            row: i,
            column: j,
            type: "normal",
            inRange: false,
            start: false,
            end: false,
            text: -1,
            disabled: false
          });
          cell.type = "normal";
          const index2 = i * 4 + j;
          const calTime = props.date.startOf("year").month(index2);
          const calEndDate = props.rangeState.endDate || props.maxDate || props.rangeState.selecting && props.minDate || null;
          cell.inRange = !!(props.minDate && calTime.isSameOrAfter(props.minDate, "month") && calEndDate && calTime.isSameOrBefore(calEndDate, "month")) || !!(props.minDate && calTime.isSameOrBefore(props.minDate, "month") && calEndDate && calTime.isSameOrAfter(calEndDate, "month"));
          if ((_a2 = props.minDate) == null ? void 0 : _a2.isSameOrAfter(calEndDate)) {
            cell.start = !!(calEndDate && calTime.isSame(calEndDate, "month"));
            cell.end = props.minDate && calTime.isSame(props.minDate, "month");
          } else {
            cell.start = !!(props.minDate && calTime.isSame(props.minDate, "month"));
            cell.end = !!(calEndDate && calTime.isSame(calEndDate, "month"));
          }
          const isToday = now2.isSame(calTime);
          if (isToday) {
            cell.type = "today";
          }
          cell.text = index2;
          cell.disabled = ((_b = props.disabledDate) == null ? void 0 : _b.call(props, calTime.toDate())) || false;
        }
      }
      return rows2;
    });
    const focus = () => {
      var _a2;
      (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
    };
    const getCellStyle = (cell) => {
      const style = {};
      const year = props.date.year();
      const today = new Date();
      const month = cell.text;
      style.disabled = props.disabledDate ? datesInMonth(year, month, lang.value).every(props.disabledDate) : false;
      style.current = castArray(props.parsedValue).findIndex((date2) => dayjs.isDayjs(date2) && date2.year() === year && date2.month() === month) >= 0;
      style.today = today.getFullYear() === year && today.getMonth() === month;
      if (cell.inRange) {
        style["in-range"] = true;
        if (cell.start) {
          style["start-date"] = true;
        }
        if (cell.end) {
          style["end-date"] = true;
        }
      }
      return style;
    };
    const isSelectedCell = (cell) => {
      const year = props.date.year();
      const month = cell.text;
      return castArray(props.date).findIndex((date2) => date2.year() === year && date2.month() === month) >= 0;
    };
    const handleMouseMove = (event) => {
      var _a2;
      if (!props.rangeState.selecting)
        return;
      let target = event.target;
      if (target.tagName === "A") {
        target = (_a2 = target.parentNode) == null ? void 0 : _a2.parentNode;
      }
      if (target.tagName === "DIV") {
        target = target.parentNode;
      }
      if (target.tagName !== "TD")
        return;
      const row = target.parentNode.rowIndex;
      const column = target.cellIndex;
      if (rows.value[row][column].disabled)
        return;
      if (row !== lastRow.value || column !== lastColumn.value) {
        lastRow.value = row;
        lastColumn.value = column;
        emit("changerange", {
          selecting: true,
          endDate: props.date.startOf("year").month(row * 4 + column)
        });
      }
    };
    const handleMonthTableClick = (event) => {
      var _a2;
      const target = (_a2 = event.target) == null ? void 0 : _a2.closest("td");
      if ((target == null ? void 0 : target.tagName) !== "TD")
        return;
      if (hasClass(target, "disabled"))
        return;
      const column = target.cellIndex;
      const row = target.parentNode.rowIndex;
      const month = row * 4 + column;
      const newDate = props.date.startOf("year").month(month);
      if (props.selectionMode === "range") {
        if (!props.rangeState.selecting) {
          emit("pick", { minDate: newDate, maxDate: null });
          emit("select", true);
        } else {
          if (props.minDate && newDate >= props.minDate) {
            emit("pick", { minDate: props.minDate, maxDate: newDate });
          } else {
            emit("pick", { minDate: newDate, maxDate: props.minDate });
          }
          emit("select", false);
        }
      } else {
        emit("pick", month);
      }
    };
    watch(() => props.date, async () => {
      var _a2, _b;
      if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
        await nextTick();
        (_b = currentCellRef.value) == null ? void 0 : _b.focus();
      }
    });
    expose({
      focus
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("table", {
        role: "grid",
        "aria-label": unref(t)("el.datepicker.monthTablePrompt"),
        class: normalizeClass(unref(ns2).b()),
        onClick: handleMonthTableClick,
        onMousemove: handleMouseMove
      }, [
        createBaseVNode("tbody", {
          ref_key: "tbodyRef",
          ref: tbodyRef
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(rows), (row, key) => {
            return openBlock(), createElementBlock("tr", { key }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(row, (cell, key_) => {
                return openBlock(), createElementBlock("td", {
                  key: key_,
                  ref_for: true,
                  ref: (el) => isSelectedCell(cell) && (currentCellRef.value = el),
                  class: normalizeClass(getCellStyle(cell)),
                  "aria-selected": `${isSelectedCell(cell)}`,
                  "aria-label": unref(t)(`el.datepicker.month${+cell.text + 1}`),
                  tabindex: isSelectedCell(cell) ? 0 : -1,
                  onKeydown: [
                    withKeys(withModifiers(handleMonthTableClick, ["prevent", "stop"]), ["space"]),
                    withKeys(withModifiers(handleMonthTableClick, ["prevent", "stop"]), ["enter"])
                  ]
                }, [
                  createBaseVNode("div", null, [
                    createBaseVNode("span", _hoisted_3$7, toDisplayString(unref(t)("el.datepicker.months." + months.value[cell.text])), 1)
                  ])
                ], 42, _hoisted_2$b);
              }), 128))
            ]);
          }), 128))
        ], 512)
      ], 42, _hoisted_1$b);
    };
  }
});
var MonthTable = /* @__PURE__ */ _export_sfc$1(_sfc_main$e, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-month-table.vue"]]);
const { date, disabledDate, parsedValue } = datePickerSharedProps;
const basicYearTableProps = buildProps({
  date,
  disabledDate,
  parsedValue
});
const _hoisted_1$a = ["aria-label"];
const _hoisted_2$a = ["aria-selected", "tabindex", "onKeydown"];
const _hoisted_3$6 = { class: "cell" };
const _hoisted_4$5 = { key: 1 };
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  __name: "basic-year-table",
  props: basicYearTableProps,
  emits: ["pick"],
  setup(__props, { expose, emit }) {
    const props = __props;
    const datesInYear = (year, lang2) => {
      const firstDay = dayjs(String(year)).locale(lang2).startOf("year");
      const lastDay = firstDay.endOf("year");
      const numOfDays = lastDay.dayOfYear();
      return rangeArr(numOfDays).map((n) => firstDay.add(n, "day").toDate());
    };
    const ns2 = useNamespace("year-table");
    const { t, lang } = useLocale();
    const tbodyRef = ref();
    const currentCellRef = ref();
    const startYear = computed(() => {
      return Math.floor(props.date.year() / 10) * 10;
    });
    const focus = () => {
      var _a2;
      (_a2 = currentCellRef.value) == null ? void 0 : _a2.focus();
    };
    const getCellKls = (year) => {
      const kls = {};
      const today = dayjs().locale(lang.value);
      kls.disabled = props.disabledDate ? datesInYear(year, lang.value).every(props.disabledDate) : false;
      kls.current = castArray(props.parsedValue).findIndex((d) => d.year() === year) >= 0;
      kls.today = today.year() === year;
      return kls;
    };
    const isSelectedCell = (year) => {
      return year === startYear.value && props.date.year() < startYear.value && props.date.year() > startYear.value + 9 || castArray(props.date).findIndex((date2) => date2.year() === year) >= 0;
    };
    const handleYearTableClick = (event) => {
      const clickTarget = event.target;
      const target = clickTarget.closest("td");
      if (target) {
        if (hasClass(target.parentNode, "disabled"))
          return;
        const year = target.textContent || target.innerText;
        emit("pick", Number(year));
      }
    };
    watch(() => props.date, async () => {
      var _a2, _b;
      if ((_a2 = tbodyRef.value) == null ? void 0 : _a2.contains(document.activeElement)) {
        await nextTick();
        (_b = currentCellRef.value) == null ? void 0 : _b.focus();
      }
    });
    expose({
      focus
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("table", {
        role: "grid",
        "aria-label": unref(t)("el.datepicker.yearTablePrompt"),
        class: normalizeClass(unref(ns2).b()),
        onClick: handleYearTableClick
      }, [
        createBaseVNode("tbody", {
          ref_key: "tbodyRef",
          ref: tbodyRef
        }, [
          (openBlock(), createElementBlock(Fragment, null, renderList(3, (_, i) => {
            return createBaseVNode("tr", { key: i }, [
              (openBlock(), createElementBlock(Fragment, null, renderList(4, (__, j) => {
                return openBlock(), createElementBlock(Fragment, {
                  key: i + "_" + j
                }, [
                  i * 4 + j < 10 ? (openBlock(), createElementBlock("td", {
                    key: 0,
                    ref_for: true,
                    ref: (el) => isSelectedCell(unref(startYear) + i * 4 + j) && (currentCellRef.value = el),
                    class: normalizeClass(["available", getCellKls(unref(startYear) + i * 4 + j)]),
                    "aria-selected": `${isSelectedCell(unref(startYear) + i * 4 + j)}`,
                    tabindex: isSelectedCell(unref(startYear) + i * 4 + j) ? 0 : -1,
                    onKeydown: [
                      withKeys(withModifiers(handleYearTableClick, ["prevent", "stop"]), ["space"]),
                      withKeys(withModifiers(handleYearTableClick, ["prevent", "stop"]), ["enter"])
                    ]
                  }, [
                    createBaseVNode("span", _hoisted_3$6, toDisplayString(unref(startYear) + i * 4 + j), 1)
                  ], 42, _hoisted_2$a)) : (openBlock(), createElementBlock("td", _hoisted_4$5))
                ], 64);
              }), 64))
            ]);
          }), 64))
        ], 512)
      ], 10, _hoisted_1$a);
    };
  }
});
var YearTable = /* @__PURE__ */ _export_sfc$1(_sfc_main$d, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/basic-year-table.vue"]]);
const _hoisted_1$9 = ["onClick"];
const _hoisted_2$9 = ["aria-label"];
const _hoisted_3$5 = ["aria-label"];
const _hoisted_4$4 = ["aria-label"];
const _hoisted_5$4 = ["aria-label"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  __name: "panel-date-pick",
  props: panelDatePickProps,
  emits: ["pick", "set-picker-option", "panel-change"],
  setup(__props, { emit: contextEmit }) {
    const props = __props;
    const timeWithinRange = (_, __, ___) => true;
    const ppNs = useNamespace("picker-panel");
    const dpNs = useNamespace("date-picker");
    const attrs = useAttrs$1();
    const slots = useSlots();
    const { t, lang } = useLocale();
    const pickerBase = inject("EP_PICKER_BASE");
    const popper2 = inject(TOOLTIP_INJECTION_KEY);
    const { shortcuts, disabledDate: disabledDate2, cellClassName, defaultTime, arrowControl } = pickerBase.props;
    const defaultValue = toRef(pickerBase.props, "defaultValue");
    const currentViewRef = ref();
    const innerDate = ref(dayjs().locale(lang.value));
    const defaultTimeD = computed(() => {
      return dayjs(defaultTime).locale(lang.value);
    });
    const month = computed(() => {
      return innerDate.value.month();
    });
    const year = computed(() => {
      return innerDate.value.year();
    });
    const selectableRange = ref([]);
    const userInputDate = ref(null);
    const userInputTime = ref(null);
    const checkDateWithinRange = (date2) => {
      return selectableRange.value.length > 0 ? timeWithinRange(date2, selectableRange.value, props.format || "HH:mm:ss") : true;
    };
    const formatEmit = (emitDayjs) => {
      if (defaultTime && !visibleTime.value) {
        return defaultTimeD.value.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      if (showTime.value)
        return emitDayjs.millisecond(0);
      return emitDayjs.startOf("day");
    };
    const emit = (value, ...args) => {
      if (!value) {
        contextEmit("pick", value, ...args);
      } else if (isArray$2(value)) {
        const dates = value.map(formatEmit);
        contextEmit("pick", dates, ...args);
      } else {
        contextEmit("pick", formatEmit(value), ...args);
      }
      userInputDate.value = null;
      userInputTime.value = null;
    };
    const handleDatePick = (value, keepOpen) => {
      if (selectionMode.value === "date") {
        value = value;
        let newDate = props.parsedValue ? props.parsedValue.year(value.year()).month(value.month()).date(value.date()) : value;
        if (!checkDateWithinRange(newDate)) {
          newDate = selectableRange.value[0][0].year(value.year()).month(value.month()).date(value.date());
        }
        innerDate.value = newDate;
        emit(newDate, showTime.value || keepOpen);
      } else if (selectionMode.value === "week") {
        emit(value.date);
      } else if (selectionMode.value === "dates") {
        emit(value, true);
      }
    };
    const moveByMonth = (forward) => {
      const action = forward ? "add" : "subtract";
      innerDate.value = innerDate.value[action](1, "month");
      handlePanelChange("month");
    };
    const moveByYear = (forward) => {
      const currentDate = innerDate.value;
      const action = forward ? "add" : "subtract";
      innerDate.value = currentView.value === "year" ? currentDate[action](10, "year") : currentDate[action](1, "year");
      handlePanelChange("year");
    };
    const currentView = ref("date");
    const yearLabel = computed(() => {
      const yearTranslation = t("el.datepicker.year");
      if (currentView.value === "year") {
        const startYear = Math.floor(year.value / 10) * 10;
        if (yearTranslation) {
          return `${startYear} ${yearTranslation} - ${startYear + 9} ${yearTranslation}`;
        }
        return `${startYear} - ${startYear + 9}`;
      }
      return `${year.value} ${yearTranslation}`;
    });
    const handleShortcutClick = (shortcut) => {
      const shortcutValue = isFunction$1(shortcut.value) ? shortcut.value() : shortcut.value;
      if (shortcutValue) {
        emit(dayjs(shortcutValue).locale(lang.value));
        return;
      }
      if (shortcut.onClick) {
        shortcut.onClick({
          attrs,
          slots,
          emit: contextEmit
        });
      }
    };
    const selectionMode = computed(() => {
      const { type } = props;
      if (["week", "month", "year", "dates"].includes(type))
        return type;
      return "date";
    });
    const keyboardMode = computed(() => {
      return selectionMode.value === "date" ? currentView.value : selectionMode.value;
    });
    const hasShortcuts = computed(() => !!shortcuts.length);
    const handleMonthPick = async (month2) => {
      innerDate.value = innerDate.value.startOf("month").month(month2);
      if (selectionMode.value === "month") {
        emit(innerDate.value, false);
      } else {
        currentView.value = "date";
        if (["month", "year", "date", "week"].includes(selectionMode.value)) {
          emit(innerDate.value, true);
          await nextTick();
          handleFocusPicker();
        }
      }
      handlePanelChange("month");
    };
    const handleYearPick = async (year2) => {
      if (selectionMode.value === "year") {
        innerDate.value = innerDate.value.startOf("year").year(year2);
        emit(innerDate.value, false);
      } else {
        innerDate.value = innerDate.value.year(year2);
        currentView.value = "month";
        if (["month", "year", "date", "week"].includes(selectionMode.value)) {
          emit(innerDate.value, true);
          await nextTick();
          handleFocusPicker();
        }
      }
      handlePanelChange("year");
    };
    const showPicker = async (view) => {
      currentView.value = view;
      await nextTick();
      handleFocusPicker();
    };
    const showTime = computed(() => props.type === "datetime" || props.type === "datetimerange");
    const footerVisible = computed(() => {
      return showTime.value || selectionMode.value === "dates";
    });
    const onConfirm = () => {
      if (selectionMode.value === "dates") {
        emit(props.parsedValue);
      } else {
        let result = props.parsedValue;
        if (!result) {
          const defaultTimeD2 = dayjs(defaultTime).locale(lang.value);
          const defaultValueD = getDefaultValue2();
          result = defaultTimeD2.year(defaultValueD.year()).month(defaultValueD.month()).date(defaultValueD.date());
        }
        innerDate.value = result;
        emit(result);
      }
    };
    const changeToNow = () => {
      const now2 = dayjs().locale(lang.value);
      const nowDate = now2.toDate();
      if ((!disabledDate2 || !disabledDate2(nowDate)) && checkDateWithinRange(nowDate)) {
        innerDate.value = dayjs().locale(lang.value);
        emit(innerDate.value);
      }
    };
    const timeFormat = computed(() => {
      return extractTimeFormat(props.format);
    });
    const dateFormat = computed(() => {
      return extractDateFormat(props.format);
    });
    const visibleTime = computed(() => {
      if (userInputTime.value)
        return userInputTime.value;
      if (!props.parsedValue && !defaultValue.value)
        return;
      return (props.parsedValue || innerDate.value).format(timeFormat.value);
    });
    const visibleDate = computed(() => {
      if (userInputDate.value)
        return userInputDate.value;
      if (!props.parsedValue && !defaultValue.value)
        return;
      return (props.parsedValue || innerDate.value).format(dateFormat.value);
    });
    const timePickerVisible = ref(false);
    const onTimePickerInputFocus = () => {
      timePickerVisible.value = true;
    };
    const handleTimePickClose = () => {
      timePickerVisible.value = false;
    };
    const getUnits = (date2) => {
      return {
        hour: date2.hour(),
        minute: date2.minute(),
        second: date2.second(),
        year: date2.year(),
        month: date2.month(),
        date: date2.date()
      };
    };
    const handleTimePick = (value, visible, first) => {
      const { hour, minute, second } = getUnits(value);
      const newDate = props.parsedValue ? props.parsedValue.hour(hour).minute(minute).second(second) : value;
      innerDate.value = newDate;
      emit(innerDate.value, true);
      if (!first) {
        timePickerVisible.value = visible;
      }
    };
    const handleVisibleTimeChange = (value) => {
      const newDate = dayjs(value, timeFormat.value).locale(lang.value);
      if (newDate.isValid() && checkDateWithinRange(newDate)) {
        const { year: year2, month: month2, date: date2 } = getUnits(innerDate.value);
        innerDate.value = newDate.year(year2).month(month2).date(date2);
        userInputTime.value = null;
        timePickerVisible.value = false;
        emit(innerDate.value, true);
      }
    };
    const handleVisibleDateChange = (value) => {
      const newDate = dayjs(value, dateFormat.value).locale(lang.value);
      if (newDate.isValid()) {
        if (disabledDate2 && disabledDate2(newDate.toDate())) {
          return;
        }
        const { hour, minute, second } = getUnits(innerDate.value);
        innerDate.value = newDate.hour(hour).minute(minute).second(second);
        userInputDate.value = null;
        emit(innerDate.value, true);
      }
    };
    const isValidValue = (date2) => {
      return dayjs.isDayjs(date2) && date2.isValid() && (disabledDate2 ? !disabledDate2(date2.toDate()) : true);
    };
    const formatToString = (value) => {
      if (selectionMode.value === "dates") {
        return value.map((_) => _.format(props.format));
      }
      return value.format(props.format);
    };
    const parseUserInput = (value) => {
      return dayjs(value, props.format).locale(lang.value);
    };
    const getDefaultValue2 = () => {
      const parseDate2 = dayjs(defaultValue.value).locale(lang.value);
      if (!defaultValue.value) {
        const defaultTimeDValue = defaultTimeD.value;
        return dayjs().hour(defaultTimeDValue.hour()).minute(defaultTimeDValue.minute()).second(defaultTimeDValue.second()).locale(lang.value);
      }
      return parseDate2;
    };
    const handleFocusPicker = async () => {
      var _a2;
      if (["week", "month", "year", "date"].includes(selectionMode.value)) {
        (_a2 = currentViewRef.value) == null ? void 0 : _a2.focus();
        if (selectionMode.value === "week") {
          handleKeyControl(EVENT_CODE.down);
        }
      }
    };
    const handleKeydownTable = (event) => {
      const { code } = event;
      const validCode = [
        EVENT_CODE.up,
        EVENT_CODE.down,
        EVENT_CODE.left,
        EVENT_CODE.right,
        EVENT_CODE.home,
        EVENT_CODE.end,
        EVENT_CODE.pageUp,
        EVENT_CODE.pageDown
      ];
      if (validCode.includes(code)) {
        handleKeyControl(code);
        event.stopPropagation();
        event.preventDefault();
      }
      if ([EVENT_CODE.enter, EVENT_CODE.space].includes(code) && userInputDate.value === null && userInputTime.value === null) {
        event.preventDefault();
        emit(innerDate.value, false);
      }
    };
    const handleKeyControl = (code) => {
      var _a2;
      const { up, down, left, right, home, end, pageUp, pageDown } = EVENT_CODE;
      const mapping = {
        year: {
          [up]: -4,
          [down]: 4,
          [left]: -1,
          [right]: 1,
          offset: (date2, step) => date2.setFullYear(date2.getFullYear() + step)
        },
        month: {
          [up]: -4,
          [down]: 4,
          [left]: -1,
          [right]: 1,
          offset: (date2, step) => date2.setMonth(date2.getMonth() + step)
        },
        week: {
          [up]: -1,
          [down]: 1,
          [left]: -1,
          [right]: 1,
          offset: (date2, step) => date2.setDate(date2.getDate() + step * 7)
        },
        date: {
          [up]: -7,
          [down]: 7,
          [left]: -1,
          [right]: 1,
          [home]: (date2) => -date2.getDay(),
          [end]: (date2) => -date2.getDay() + 6,
          [pageUp]: (date2) => -new Date(date2.getFullYear(), date2.getMonth(), 0).getDate(),
          [pageDown]: (date2) => new Date(date2.getFullYear(), date2.getMonth() + 1, 0).getDate(),
          offset: (date2, step) => date2.setDate(date2.getDate() + step)
        }
      };
      const newDate = innerDate.value.toDate();
      while (Math.abs(innerDate.value.diff(newDate, "year", true)) < 1) {
        const map = mapping[keyboardMode.value];
        if (!map)
          return;
        map.offset(newDate, isFunction$1(map[code]) ? map[code](newDate) : (_a2 = map[code]) != null ? _a2 : 0);
        if (disabledDate2 && disabledDate2(newDate)) {
          break;
        }
        const result = dayjs(newDate).locale(lang.value);
        innerDate.value = result;
        contextEmit("pick", result, true);
        break;
      }
    };
    const handlePanelChange = (mode) => {
      contextEmit("panel-change", innerDate.value.toDate(), mode, currentView.value);
    };
    watch(() => selectionMode.value, (val) => {
      if (["month", "year"].includes(val)) {
        currentView.value = val;
        return;
      }
      currentView.value = "date";
    }, { immediate: true });
    watch(() => currentView.value, () => {
      popper2 == null ? void 0 : popper2.updatePopper();
    });
    watch(() => defaultValue.value, (val) => {
      if (val) {
        innerDate.value = getDefaultValue2();
      }
    }, { immediate: true });
    watch(() => props.parsedValue, (val) => {
      if (val) {
        if (selectionMode.value === "dates")
          return;
        if (Array.isArray(val))
          return;
        innerDate.value = val;
      } else {
        innerDate.value = getDefaultValue2();
      }
    }, { immediate: true });
    contextEmit("set-picker-option", ["isValidValue", isValidValue]);
    contextEmit("set-picker-option", ["formatToString", formatToString]);
    contextEmit("set-picker-option", ["parseUserInput", parseUserInput]);
    contextEmit("set-picker-option", ["handleFocusPicker", handleFocusPicker]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          unref(ppNs).b(),
          unref(dpNs).b(),
          {
            "has-sidebar": _ctx.$slots.sidebar || unref(hasShortcuts),
            "has-time": unref(showTime)
          }
        ])
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref(ppNs).e("body-wrapper"))
        }, [
          renderSlot(_ctx.$slots, "sidebar", {
            class: normalizeClass(unref(ppNs).e("sidebar"))
          }),
          unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(ppNs).e("sidebar"))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
              return openBlock(), createElementBlock("button", {
                key,
                type: "button",
                class: normalizeClass(unref(ppNs).e("shortcut")),
                onClick: ($event) => handleShortcutClick(shortcut)
              }, toDisplayString(shortcut.text), 11, _hoisted_1$9);
            }), 128))
          ], 2)) : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            class: normalizeClass(unref(ppNs).e("body"))
          }, [
            unref(showTime) ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(dpNs).e("time-header"))
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(dpNs).e("editor-wrap"))
              }, [
                createVNode(unref(ElInput), {
                  placeholder: unref(t)("el.datepicker.selectDate"),
                  "model-value": unref(visibleDate),
                  size: "small",
                  onInput: _cache[0] || (_cache[0] = (val) => userInputDate.value = val),
                  onChange: handleVisibleDateChange
                }, null, 8, ["placeholder", "model-value"])
              ], 2),
              withDirectives((openBlock(), createElementBlock("span", {
                class: normalizeClass(unref(dpNs).e("editor-wrap"))
              }, [
                createVNode(unref(ElInput), {
                  placeholder: unref(t)("el.datepicker.selectTime"),
                  "model-value": unref(visibleTime),
                  size: "small",
                  onFocus: onTimePickerInputFocus,
                  onInput: _cache[1] || (_cache[1] = (val) => userInputTime.value = val),
                  onChange: handleVisibleTimeChange
                }, null, 8, ["placeholder", "model-value"]),
                createVNode(unref(TimePickPanel), {
                  visible: timePickerVisible.value,
                  format: unref(timeFormat),
                  "time-arrow-control": unref(arrowControl),
                  "parsed-value": innerDate.value,
                  onPick: handleTimePick
                }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
              ], 2)), [
                [unref(ClickOutside), handleTimePickClose]
              ])
            ], 2)) : createCommentVNode("v-if", true),
            withDirectives(createBaseVNode("div", {
              class: normalizeClass([
                unref(dpNs).e("header"),
                (currentView.value === "year" || currentView.value === "month") && unref(dpNs).e("header--bordered")
              ])
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(dpNs).e("prev-btn"))
              }, [
                createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)(`el.datepicker.prevYear`),
                  class: normalizeClass(["d-arrow-left", unref(ppNs).e("icon-btn")]),
                  onClick: _cache[2] || (_cache[2] = ($event) => moveByYear(false))
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_2$9),
                withDirectives(createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)(`el.datepicker.prevMonth`),
                  class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-left"]),
                  onClick: _cache[3] || (_cache[3] = ($event) => moveByMonth(false))
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_3$5), [
                  [vShow, currentView.value === "date"]
                ])
              ], 2),
              createBaseVNode("span", {
                role: "button",
                class: normalizeClass(unref(dpNs).e("header-label")),
                "aria-live": "polite",
                tabindex: "0",
                onKeydown: _cache[4] || (_cache[4] = withKeys(($event) => showPicker("year"), ["enter"])),
                onClick: _cache[5] || (_cache[5] = ($event) => showPicker("year"))
              }, toDisplayString(unref(yearLabel)), 35),
              withDirectives(createBaseVNode("span", {
                role: "button",
                "aria-live": "polite",
                tabindex: "0",
                class: normalizeClass([
                  unref(dpNs).e("header-label"),
                  { active: currentView.value === "month" }
                ]),
                onKeydown: _cache[6] || (_cache[6] = withKeys(($event) => showPicker("month"), ["enter"])),
                onClick: _cache[7] || (_cache[7] = ($event) => showPicker("month"))
              }, toDisplayString(unref(t)(`el.datepicker.month${unref(month) + 1}`)), 35), [
                [vShow, currentView.value === "date"]
              ]),
              createBaseVNode("span", {
                class: normalizeClass(unref(dpNs).e("next-btn"))
              }, [
                withDirectives(createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)(`el.datepicker.nextMonth`),
                  class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-right"]),
                  onClick: _cache[8] || (_cache[8] = ($event) => moveByMonth(true))
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_4$4), [
                  [vShow, currentView.value === "date"]
                ]),
                createBaseVNode("button", {
                  type: "button",
                  "aria-label": unref(t)(`el.datepicker.nextYear`),
                  class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                  onClick: _cache[9] || (_cache[9] = ($event) => moveByYear(true))
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_5$4)
              ], 2)
            ], 2), [
              [vShow, currentView.value !== "time"]
            ]),
            createBaseVNode("div", {
              class: normalizeClass(unref(ppNs).e("content")),
              onKeydown: handleKeydownTable
            }, [
              currentView.value === "date" ? (openBlock(), createBlock(DateTable, {
                key: 0,
                ref_key: "currentViewRef",
                ref: currentViewRef,
                "selection-mode": unref(selectionMode),
                date: innerDate.value,
                "parsed-value": _ctx.parsedValue,
                "disabled-date": unref(disabledDate2),
                "cell-class-name": unref(cellClassName),
                onPick: handleDatePick
              }, null, 8, ["selection-mode", "date", "parsed-value", "disabled-date", "cell-class-name"])) : createCommentVNode("v-if", true),
              currentView.value === "year" ? (openBlock(), createBlock(YearTable, {
                key: 1,
                ref_key: "currentViewRef",
                ref: currentViewRef,
                date: innerDate.value,
                "disabled-date": unref(disabledDate2),
                "parsed-value": _ctx.parsedValue,
                onPick: handleYearPick
              }, null, 8, ["date", "disabled-date", "parsed-value"])) : createCommentVNode("v-if", true),
              currentView.value === "month" ? (openBlock(), createBlock(MonthTable, {
                key: 2,
                ref_key: "currentViewRef",
                ref: currentViewRef,
                date: innerDate.value,
                "parsed-value": _ctx.parsedValue,
                "disabled-date": unref(disabledDate2),
                onPick: handleMonthPick
              }, null, 8, ["date", "parsed-value", "disabled-date"])) : createCommentVNode("v-if", true)
            ], 34)
          ], 2)
        ], 2),
        withDirectives(createBaseVNode("div", {
          class: normalizeClass(unref(ppNs).e("footer"))
        }, [
          withDirectives(createVNode(unref(ElButton), {
            text: "",
            size: "small",
            class: normalizeClass(unref(ppNs).e("link-btn")),
            onClick: changeToNow
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(t)("el.datepicker.now")), 1)
            ]),
            _: 1
          }, 8, ["class"]), [
            [vShow, unref(selectionMode) !== "dates"]
          ]),
          createVNode(unref(ElButton), {
            plain: "",
            size: "small",
            class: normalizeClass(unref(ppNs).e("link-btn")),
            onClick: onConfirm
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(t)("el.datepicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["class"])
        ], 2), [
          [vShow, unref(footerVisible) && currentView.value === "date"]
        ])
      ], 2);
    };
  }
});
var DatePickPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$c, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-pick.vue"]]);
const panelDateRangeProps = buildProps(__spreadValues(__spreadValues({}, panelSharedProps), panelRangeSharedProps));
const useShortcut = (lang) => {
  const { emit } = getCurrentInstance();
  const attrs = useAttrs$1();
  const slots = useSlots();
  const handleShortcutClick = (shortcut) => {
    const shortcutValues = isFunction$1(shortcut.value) ? shortcut.value() : shortcut.value;
    if (shortcutValues) {
      emit("pick", [
        dayjs(shortcutValues[0]).locale(lang.value),
        dayjs(shortcutValues[1]).locale(lang.value)
      ]);
      return;
    }
    if (shortcut.onClick) {
      shortcut.onClick({
        attrs,
        slots,
        emit
      });
    }
  };
  return handleShortcutClick;
};
const useRangePicker = (props, {
  defaultValue,
  leftDate,
  rightDate,
  unit,
  onParsedValueChanged
}) => {
  const { emit } = getCurrentInstance();
  const { pickerNs } = inject(ROOT_PICKER_INJECTION_KEY);
  const drpNs = useNamespace("date-range-picker");
  const { t, lang } = useLocale();
  const handleShortcutClick = useShortcut(lang);
  const minDate = ref();
  const maxDate = ref();
  const rangeState = ref({
    endDate: null,
    selecting: false
  });
  const handleChangeRange = (val) => {
    rangeState.value = val;
  };
  const handleRangeConfirm = (visible = false) => {
    const _minDate = unref(minDate);
    const _maxDate = unref(maxDate);
    if (isValidRange([_minDate, _maxDate])) {
      emit("pick", [_minDate, _maxDate], visible);
    }
  };
  const onSelect = (selecting) => {
    rangeState.value.selecting = selecting;
    if (!selecting) {
      rangeState.value.endDate = null;
    }
  };
  const restoreDefault = () => {
    const [start, end] = getDefaultValue(unref(defaultValue), {
      lang: unref(lang),
      unit,
      unlinkPanels: props.unlinkPanels
    });
    minDate.value = void 0;
    maxDate.value = void 0;
    leftDate.value = start;
    rightDate.value = end;
  };
  watch(defaultValue, (val) => {
    if (val) {
      restoreDefault();
    }
  }, { immediate: true });
  watch(() => props.parsedValue, (parsedValue2) => {
    if (isArray$2(parsedValue2) && parsedValue2.length === 2) {
      const [start, end] = parsedValue2;
      minDate.value = start;
      leftDate.value = start;
      maxDate.value = end;
      onParsedValueChanged(unref(minDate), unref(maxDate));
    } else {
      restoreDefault();
    }
  }, { immediate: true });
  return {
    minDate,
    maxDate,
    rangeState,
    lang,
    ppNs: pickerNs,
    drpNs,
    handleChangeRange,
    handleRangeConfirm,
    handleShortcutClick,
    onSelect,
    t
  };
};
const _hoisted_1$8 = ["onClick"];
const _hoisted_2$8 = ["disabled"];
const _hoisted_3$4 = ["disabled"];
const _hoisted_4$3 = ["disabled"];
const _hoisted_5$3 = ["disabled"];
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  __name: "panel-date-range",
  props: panelDateRangeProps,
  emits: [
    "pick",
    "set-picker-option",
    "calendar-change",
    "panel-change"
  ],
  setup(__props, { emit }) {
    const props = __props;
    const unit = "month";
    const pickerBase = inject("EP_PICKER_BASE");
    const {
      disabledDate: disabledDate2,
      cellClassName,
      format,
      defaultTime,
      arrowControl,
      clearable
    } = pickerBase.props;
    const shortcuts = toRef(pickerBase.props, "shortcuts");
    const defaultValue = toRef(pickerBase.props, "defaultValue");
    const { lang } = useLocale();
    const leftDate = ref(dayjs().locale(lang.value));
    const rightDate = ref(dayjs().locale(lang.value).add(1, unit));
    const {
      minDate,
      maxDate,
      rangeState,
      ppNs,
      drpNs,
      handleChangeRange,
      handleRangeConfirm,
      handleShortcutClick,
      onSelect,
      t
    } = useRangePicker(props, {
      defaultValue,
      leftDate,
      rightDate,
      unit,
      onParsedValueChanged
    });
    const dateUserInput = ref({
      min: null,
      max: null
    });
    const timeUserInput = ref({
      min: null,
      max: null
    });
    const leftLabel = computed(() => {
      return `${leftDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${leftDate.value.month() + 1}`)}`;
    });
    const rightLabel = computed(() => {
      return `${rightDate.value.year()} ${t("el.datepicker.year")} ${t(`el.datepicker.month${rightDate.value.month() + 1}`)}`;
    });
    const leftYear = computed(() => {
      return leftDate.value.year();
    });
    const leftMonth = computed(() => {
      return leftDate.value.month();
    });
    const rightYear = computed(() => {
      return rightDate.value.year();
    });
    const rightMonth = computed(() => {
      return rightDate.value.month();
    });
    const hasShortcuts = computed(() => !!shortcuts.value.length);
    const minVisibleDate = computed(() => {
      if (dateUserInput.value.min !== null)
        return dateUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(dateFormat.value);
      return "";
    });
    const maxVisibleDate = computed(() => {
      if (dateUserInput.value.max !== null)
        return dateUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(dateFormat.value);
      return "";
    });
    const minVisibleTime = computed(() => {
      if (timeUserInput.value.min !== null)
        return timeUserInput.value.min;
      if (minDate.value)
        return minDate.value.format(timeFormat.value);
      return "";
    });
    const maxVisibleTime = computed(() => {
      if (timeUserInput.value.max !== null)
        return timeUserInput.value.max;
      if (maxDate.value || minDate.value)
        return (maxDate.value || minDate.value).format(timeFormat.value);
      return "";
    });
    const timeFormat = computed(() => {
      return extractTimeFormat(format);
    });
    const dateFormat = computed(() => {
      return extractDateFormat(format);
    });
    const leftPrevYear = () => {
      leftDate.value = leftDate.value.subtract(1, "year");
      if (!props.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
      handlePanelChange("year");
    };
    const leftPrevMonth = () => {
      leftDate.value = leftDate.value.subtract(1, "month");
      if (!props.unlinkPanels) {
        rightDate.value = leftDate.value.add(1, "month");
      }
      handlePanelChange("month");
    };
    const rightNextYear = () => {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "year");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "year");
      }
      handlePanelChange("year");
    };
    const rightNextMonth = () => {
      if (!props.unlinkPanels) {
        leftDate.value = leftDate.value.add(1, "month");
        rightDate.value = leftDate.value.add(1, "month");
      } else {
        rightDate.value = rightDate.value.add(1, "month");
      }
      handlePanelChange("month");
    };
    const leftNextYear = () => {
      leftDate.value = leftDate.value.add(1, "year");
      handlePanelChange("year");
    };
    const leftNextMonth = () => {
      leftDate.value = leftDate.value.add(1, "month");
      handlePanelChange("month");
    };
    const rightPrevYear = () => {
      rightDate.value = rightDate.value.subtract(1, "year");
      handlePanelChange("year");
    };
    const rightPrevMonth = () => {
      rightDate.value = rightDate.value.subtract(1, "month");
      handlePanelChange("month");
    };
    const handlePanelChange = (mode) => {
      emit("panel-change", [leftDate.value.toDate(), rightDate.value.toDate()], mode);
    };
    const enableMonthArrow = computed(() => {
      const nextMonth = (leftMonth.value + 1) % 12;
      const yearOffset = leftMonth.value + 1 >= 12 ? 1 : 0;
      return props.unlinkPanels && new Date(leftYear.value + yearOffset, nextMonth) < new Date(rightYear.value, rightMonth.value);
    });
    const enableYearArrow = computed(() => {
      return props.unlinkPanels && rightYear.value * 12 + rightMonth.value - (leftYear.value * 12 + leftMonth.value + 1) >= 12;
    });
    const btnDisabled = computed(() => {
      return !(minDate.value && maxDate.value && !rangeState.value.selecting && isValidRange([minDate.value, maxDate.value]));
    });
    const showTime = computed(() => props.type === "datetime" || props.type === "datetimerange");
    const formatEmit = (emitDayjs, index2) => {
      if (!emitDayjs)
        return;
      if (defaultTime) {
        const defaultTimeD = dayjs(defaultTime[index2] || defaultTime).locale(lang.value);
        return defaultTimeD.year(emitDayjs.year()).month(emitDayjs.month()).date(emitDayjs.date());
      }
      return emitDayjs;
    };
    const handleRangePick = (val, close2 = true) => {
      const min_ = val.minDate;
      const max_ = val.maxDate;
      const minDate_ = formatEmit(min_, 0);
      const maxDate_ = formatEmit(max_, 1);
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      emit("calendar-change", [min_.toDate(), max_ && max_.toDate()]);
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2 || showTime.value)
        return;
      handleRangeConfirm();
    };
    const minTimePickerVisible = ref(false);
    const maxTimePickerVisible = ref(false);
    const handleMinTimeClose = () => {
      minTimePickerVisible.value = false;
    };
    const handleMaxTimeClose = () => {
      maxTimePickerVisible.value = false;
    };
    const handleDateInput = (value, type) => {
      dateUserInput.value[type] = value;
      const parsedValueD = dayjs(value, dateFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (disabledDate2 && disabledDate2(parsedValueD.toDate())) {
          return;
        }
        if (type === "min") {
          leftDate.value = parsedValueD;
          minDate.value = (minDate.value || leftDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props.unlinkPanels) {
            rightDate.value = parsedValueD.add(1, "month");
            maxDate.value = minDate.value.add(1, "month");
          }
        } else {
          rightDate.value = parsedValueD;
          maxDate.value = (maxDate.value || rightDate.value).year(parsedValueD.year()).month(parsedValueD.month()).date(parsedValueD.date());
          if (!props.unlinkPanels) {
            leftDate.value = parsedValueD.subtract(1, "month");
            minDate.value = maxDate.value.subtract(1, "month");
          }
        }
      }
    };
    const handleDateChange = (_, type) => {
      dateUserInput.value[type] = null;
    };
    const handleTimeInput = (value, type) => {
      timeUserInput.value[type] = value;
      const parsedValueD = dayjs(value, timeFormat.value).locale(lang.value);
      if (parsedValueD.isValid()) {
        if (type === "min") {
          minTimePickerVisible.value = true;
          minDate.value = (minDate.value || leftDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
            maxDate.value = minDate.value;
          }
        } else {
          maxTimePickerVisible.value = true;
          maxDate.value = (maxDate.value || rightDate.value).hour(parsedValueD.hour()).minute(parsedValueD.minute()).second(parsedValueD.second());
          rightDate.value = maxDate.value;
          if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
            minDate.value = maxDate.value;
          }
        }
      }
    };
    const handleTimeChange = (value, type) => {
      timeUserInput.value[type] = null;
      if (type === "min") {
        leftDate.value = minDate.value;
        minTimePickerVisible.value = false;
      } else {
        rightDate.value = maxDate.value;
        maxTimePickerVisible.value = false;
      }
    };
    const handleMinTimePick = (value, visible, first) => {
      if (timeUserInput.value.min)
        return;
      if (value) {
        leftDate.value = value;
        minDate.value = (minDate.value || leftDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }
      if (!first) {
        minTimePickerVisible.value = visible;
      }
      if (!maxDate.value || maxDate.value.isBefore(minDate.value)) {
        maxDate.value = minDate.value;
        rightDate.value = value;
      }
    };
    const handleMaxTimePick = (value, visible, first) => {
      if (timeUserInput.value.max)
        return;
      if (value) {
        rightDate.value = value;
        maxDate.value = (maxDate.value || rightDate.value).hour(value.hour()).minute(value.minute()).second(value.second());
      }
      if (!first) {
        maxTimePickerVisible.value = visible;
      }
      if (maxDate.value && maxDate.value.isBefore(minDate.value)) {
        minDate.value = maxDate.value;
      }
    };
    const handleClear = () => {
      leftDate.value = getDefaultValue(unref(defaultValue), {
        lang: unref(lang),
        unit: "month",
        unlinkPanels: props.unlinkPanels
      })[0];
      rightDate.value = leftDate.value.add(1, "month");
      emit("pick", null);
    };
    const formatToString = (value) => {
      return isArray$2(value) ? value.map((_) => _.format(format)) : value.format(format);
    };
    const parseUserInput = (value) => {
      return isArray$2(value) ? value.map((_) => dayjs(_, format).locale(lang.value)) : dayjs(value, format).locale(lang.value);
    };
    function onParsedValueChanged(minDate2, maxDate2) {
      if (props.unlinkPanels && maxDate2) {
        const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
        const minDateMonth = (minDate2 == null ? void 0 : minDate2.month()) || 0;
        const maxDateYear = maxDate2.year();
        const maxDateMonth = maxDate2.month();
        rightDate.value = minDateYear === maxDateYear && minDateMonth === maxDateMonth ? maxDate2.add(1, unit) : maxDate2;
      } else {
        rightDate.value = leftDate.value.add(1, unit);
        if (maxDate2) {
          rightDate.value = rightDate.value.hour(maxDate2.hour()).minute(maxDate2.minute()).second(maxDate2.second());
        }
      }
    }
    emit("set-picker-option", ["isValidRange", isValidRange]);
    emit("set-picker-option", ["parseUserInput", parseUserInput]);
    emit("set-picker-option", ["formatToString", formatToString]);
    emit("set-picker-option", ["handleClear", handleClear]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          unref(ppNs).b(),
          unref(drpNs).b(),
          {
            "has-sidebar": _ctx.$slots.sidebar || unref(hasShortcuts),
            "has-time": unref(showTime)
          }
        ])
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref(ppNs).e("body-wrapper"))
        }, [
          renderSlot(_ctx.$slots, "sidebar", {
            class: normalizeClass(unref(ppNs).e("sidebar"))
          }),
          unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(ppNs).e("sidebar"))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
              return openBlock(), createElementBlock("button", {
                key,
                type: "button",
                class: normalizeClass(unref(ppNs).e("shortcut")),
                onClick: ($event) => unref(handleShortcutClick)(shortcut)
              }, toDisplayString(shortcut.text), 11, _hoisted_1$8);
            }), 128))
          ], 2)) : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            class: normalizeClass(unref(ppNs).e("body"))
          }, [
            unref(showTime) ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(unref(drpNs).e("time-header"))
            }, [
              createBaseVNode("span", {
                class: normalizeClass(unref(drpNs).e("editors-wrap"))
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                }, [
                  createVNode(unref(ElInput), {
                    size: "small",
                    disabled: unref(rangeState).selecting,
                    placeholder: unref(t)("el.datepicker.startDate"),
                    class: normalizeClass(unref(drpNs).e("editor")),
                    "model-value": unref(minVisibleDate),
                    onInput: _cache[0] || (_cache[0] = (val) => handleDateInput(val, "min")),
                    onChange: _cache[1] || (_cache[1] = (val) => handleDateChange(val, "min"))
                  }, null, 8, ["disabled", "placeholder", "class", "model-value"])
                ], 2),
                withDirectives((openBlock(), createElementBlock("span", {
                  class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                }, [
                  createVNode(unref(ElInput), {
                    size: "small",
                    class: normalizeClass(unref(drpNs).e("editor")),
                    disabled: unref(rangeState).selecting,
                    placeholder: unref(t)("el.datepicker.startTime"),
                    "model-value": unref(minVisibleTime),
                    onFocus: _cache[2] || (_cache[2] = ($event) => minTimePickerVisible.value = true),
                    onInput: _cache[3] || (_cache[3] = (val) => handleTimeInput(val, "min")),
                    onChange: _cache[4] || (_cache[4] = (val) => handleTimeChange(val, "min"))
                  }, null, 8, ["class", "disabled", "placeholder", "model-value"]),
                  createVNode(unref(TimePickPanel), {
                    visible: minTimePickerVisible.value,
                    format: unref(timeFormat),
                    "datetime-role": "start",
                    "time-arrow-control": unref(arrowControl),
                    "parsed-value": leftDate.value,
                    onPick: handleMinTimePick
                  }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
                ], 2)), [
                  [unref(ClickOutside), handleMinTimeClose]
                ])
              ], 2),
              createBaseVNode("span", null, [
                createVNode(unref(ElIcon), null, {
                  default: withCtx(() => [
                    createVNode(unref(arrow_right_default))
                  ]),
                  _: 1
                })
              ]),
              createBaseVNode("span", {
                class: normalizeClass([unref(drpNs).e("editors-wrap"), "is-right"])
              }, [
                createBaseVNode("span", {
                  class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                }, [
                  createVNode(unref(ElInput), {
                    size: "small",
                    class: normalizeClass(unref(drpNs).e("editor")),
                    disabled: unref(rangeState).selecting,
                    placeholder: unref(t)("el.datepicker.endDate"),
                    "model-value": unref(maxVisibleDate),
                    readonly: !unref(minDate),
                    onInput: _cache[5] || (_cache[5] = (val) => handleDateInput(val, "max")),
                    onChange: _cache[6] || (_cache[6] = (val) => handleDateChange(val, "max"))
                  }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"])
                ], 2),
                withDirectives((openBlock(), createElementBlock("span", {
                  class: normalizeClass(unref(drpNs).e("time-picker-wrap"))
                }, [
                  createVNode(unref(ElInput), {
                    size: "small",
                    class: normalizeClass(unref(drpNs).e("editor")),
                    disabled: unref(rangeState).selecting,
                    placeholder: unref(t)("el.datepicker.endTime"),
                    "model-value": unref(maxVisibleTime),
                    readonly: !unref(minDate),
                    onFocus: _cache[7] || (_cache[7] = ($event) => unref(minDate) && (maxTimePickerVisible.value = true)),
                    onInput: _cache[8] || (_cache[8] = (val) => handleTimeInput(val, "max")),
                    onChange: _cache[9] || (_cache[9] = (val) => handleTimeChange(val, "max"))
                  }, null, 8, ["class", "disabled", "placeholder", "model-value", "readonly"]),
                  createVNode(unref(TimePickPanel), {
                    "datetime-role": "end",
                    visible: maxTimePickerVisible.value,
                    format: unref(timeFormat),
                    "time-arrow-control": unref(arrowControl),
                    "parsed-value": rightDate.value,
                    onPick: handleMaxTimePick
                  }, null, 8, ["visible", "format", "time-arrow-control", "parsed-value"])
                ], 2)), [
                  [unref(ClickOutside), handleMaxTimeClose]
                ])
              ], 2)
            ], 2)) : createCommentVNode("v-if", true),
            createBaseVNode("div", {
              class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-left"])
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(drpNs).e("header"))
              }, [
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-left"]),
                  onClick: leftPrevYear
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 2),
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-left"]),
                  onClick: leftPrevMonth
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 2),
                _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  disabled: !unref(enableYearArrow),
                  class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-right"]),
                  onClick: leftNextYear
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_2$8)) : createCommentVNode("v-if", true),
                _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  type: "button",
                  disabled: !unref(enableMonthArrow),
                  class: normalizeClass([[
                    unref(ppNs).e("icon-btn"),
                    { "is-disabled": !unref(enableMonthArrow) }
                  ], "arrow-right"]),
                  onClick: leftNextMonth
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_3$4)) : createCommentVNode("v-if", true),
                createBaseVNode("div", null, toDisplayString(unref(leftLabel)), 1)
              ], 2),
              createVNode(DateTable, {
                "selection-mode": "range",
                date: leftDate.value,
                "min-date": unref(minDate),
                "max-date": unref(maxDate),
                "range-state": unref(rangeState),
                "disabled-date": unref(disabledDate2),
                "cell-class-name": unref(cellClassName),
                onChangerange: unref(handleChangeRange),
                onPick: handleRangePick,
                onSelect: unref(onSelect)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-right"])
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(drpNs).e("header"))
              }, [
                _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  disabled: !unref(enableYearArrow),
                  class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-left"]),
                  onClick: rightPrevYear
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_4$3)) : createCommentVNode("v-if", true),
                _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  type: "button",
                  disabled: !unref(enableMonthArrow),
                  class: normalizeClass([[
                    unref(ppNs).e("icon-btn"),
                    { "is-disabled": !unref(enableMonthArrow) }
                  ], "arrow-left"]),
                  onClick: rightPrevMonth
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_5$3)) : createCommentVNode("v-if", true),
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                  onClick: rightNextYear
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 2),
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(ppNs).e("icon-btn"), "arrow-right"]),
                  onClick: rightNextMonth
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 2),
                createBaseVNode("div", null, toDisplayString(unref(rightLabel)), 1)
              ], 2),
              createVNode(DateTable, {
                "selection-mode": "range",
                date: rightDate.value,
                "min-date": unref(minDate),
                "max-date": unref(maxDate),
                "range-state": unref(rangeState),
                "disabled-date": unref(disabledDate2),
                "cell-class-name": unref(cellClassName),
                onChangerange: unref(handleChangeRange),
                onPick: handleRangePick,
                onSelect: unref(onSelect)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "cell-class-name", "onChangerange", "onSelect"])
            ], 2)
          ], 2)
        ], 2),
        unref(showTime) ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(ppNs).e("footer"))
        }, [
          unref(clearable) ? (openBlock(), createBlock(unref(ElButton), {
            key: 0,
            text: "",
            size: "small",
            class: normalizeClass(unref(ppNs).e("link-btn")),
            onClick: handleClear
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(t)("el.datepicker.clear")), 1)
            ]),
            _: 1
          }, 8, ["class"])) : createCommentVNode("v-if", true),
          createVNode(unref(ElButton), {
            plain: "",
            size: "small",
            class: normalizeClass(unref(ppNs).e("link-btn")),
            disabled: unref(btnDisabled),
            onClick: _cache[10] || (_cache[10] = ($event) => unref(handleRangeConfirm)(false))
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(unref(t)("el.datepicker.confirm")), 1)
            ]),
            _: 1
          }, 8, ["class", "disabled"])
        ], 2)) : createCommentVNode("v-if", true)
      ], 2);
    };
  }
});
var DateRangePickPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$b, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-date-range.vue"]]);
const panelMonthRangeProps = buildProps(__spreadValues({}, panelRangeSharedProps));
const panelMonthRangeEmits = ["pick", "set-picker-option"];
const useMonthRangeHeader = ({
  unlinkPanels,
  leftDate,
  rightDate
}) => {
  const { t } = useLocale();
  const leftPrevYear = () => {
    leftDate.value = leftDate.value.subtract(1, "year");
    if (!unlinkPanels) {
      rightDate.value = rightDate.value.subtract(1, "year");
    }
  };
  const rightNextYear = () => {
    if (!unlinkPanels) {
      leftDate.value = leftDate.value.add(1, "year");
    }
    rightDate.value = rightDate.value.add(1, "year");
  };
  const leftNextYear = () => {
    leftDate.value = leftDate.value.add(1, "year");
  };
  const rightPrevYear = () => {
    rightDate.value = rightDate.value.subtract(1, "year");
  };
  const leftLabel = computed(() => {
    return `${leftDate.value.year()} ${t("el.datepicker.year")}`;
  });
  const rightLabel = computed(() => {
    return `${rightDate.value.year()} ${t("el.datepicker.year")}`;
  });
  const leftYear = computed(() => {
    return leftDate.value.year();
  });
  const rightYear = computed(() => {
    return rightDate.value.year() === leftDate.value.year() ? leftDate.value.year() + 1 : rightDate.value.year();
  });
  return {
    leftPrevYear,
    rightNextYear,
    leftNextYear,
    rightPrevYear,
    leftLabel,
    rightLabel,
    leftYear,
    rightYear
  };
};
const _hoisted_1$7 = ["onClick"];
const _hoisted_2$7 = ["disabled"];
const _hoisted_3$3 = ["disabled"];
const __default__ = {
  name: "DatePickerMonthRange"
};
const _sfc_main$a = /* @__PURE__ */ defineComponent(__spreadProps(__spreadValues({}, __default__), {
  props: panelMonthRangeProps,
  emits: panelMonthRangeEmits,
  setup(__props, { emit }) {
    const props = __props;
    const unit = "year";
    const { lang } = useLocale();
    const pickerBase = inject("EP_PICKER_BASE");
    const { shortcuts, disabledDate: disabledDate2, format } = pickerBase.props;
    const defaultValue = toRef(pickerBase.props, "defaultValue");
    const leftDate = ref(dayjs().locale(lang.value));
    const rightDate = ref(dayjs().locale(lang.value).add(1, unit));
    const {
      minDate,
      maxDate,
      rangeState,
      ppNs,
      drpNs,
      handleChangeRange,
      handleRangeConfirm,
      handleShortcutClick,
      onSelect
    } = useRangePicker(props, {
      defaultValue,
      leftDate,
      rightDate,
      unit,
      onParsedValueChanged
    });
    const hasShortcuts = computed(() => !!shortcuts.length);
    const {
      leftPrevYear,
      rightNextYear,
      leftNextYear,
      rightPrevYear,
      leftLabel,
      rightLabel,
      leftYear,
      rightYear
    } = useMonthRangeHeader({
      unlinkPanels: toRef(props, "unlinkPanels"),
      leftDate,
      rightDate
    });
    const enableYearArrow = computed(() => {
      return props.unlinkPanels && rightYear.value > leftYear.value + 1;
    });
    const handleRangePick = (val, close2 = true) => {
      const minDate_ = val.minDate;
      const maxDate_ = val.maxDate;
      if (maxDate.value === maxDate_ && minDate.value === minDate_) {
        return;
      }
      maxDate.value = maxDate_;
      minDate.value = minDate_;
      if (!close2)
        return;
      handleRangeConfirm();
    };
    const formatToString = (days) => {
      return days.map((day) => day.format(format));
    };
    function onParsedValueChanged(minDate2, maxDate2) {
      if (props.unlinkPanels && maxDate2) {
        const minDateYear = (minDate2 == null ? void 0 : minDate2.year()) || 0;
        const maxDateYear = maxDate2.year();
        rightDate.value = minDateYear === maxDateYear ? maxDate2.add(1, unit) : maxDate2;
      } else {
        rightDate.value = leftDate.value.add(1, unit);
      }
    }
    emit("set-picker-option", ["formatToString", formatToString]);
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          unref(ppNs).b(),
          unref(drpNs).b(),
          {
            "has-sidebar": Boolean(_ctx.$slots.sidebar) || unref(hasShortcuts)
          }
        ])
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref(ppNs).e("body-wrapper"))
        }, [
          renderSlot(_ctx.$slots, "sidebar", {
            class: normalizeClass(unref(ppNs).e("sidebar"))
          }),
          unref(hasShortcuts) ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(unref(ppNs).e("sidebar"))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(unref(shortcuts), (shortcut, key) => {
              return openBlock(), createElementBlock("button", {
                key,
                type: "button",
                class: normalizeClass(unref(ppNs).e("shortcut")),
                onClick: ($event) => unref(handleShortcutClick)(shortcut)
              }, toDisplayString(shortcut.text), 11, _hoisted_1$7);
            }), 128))
          ], 2)) : createCommentVNode("v-if", true),
          createBaseVNode("div", {
            class: normalizeClass(unref(ppNs).e("body"))
          }, [
            createBaseVNode("div", {
              class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-left"])
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(drpNs).e("header"))
              }, [
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-left"]),
                  onClick: _cache[0] || (_cache[0] = (...args) => unref(leftPrevYear) && unref(leftPrevYear)(...args))
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 2),
                _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  disabled: !unref(enableYearArrow),
                  class: normalizeClass([[
                    unref(ppNs).e("icon-btn"),
                    { [unref(ppNs).is("disabled")]: !unref(enableYearArrow) }
                  ], "d-arrow-right"]),
                  onClick: _cache[1] || (_cache[1] = (...args) => unref(leftNextYear) && unref(leftNextYear)(...args))
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_2$7)) : createCommentVNode("v-if", true),
                createBaseVNode("div", null, toDisplayString(unref(leftLabel)), 1)
              ], 2),
              createVNode(MonthTable, {
                "selection-mode": "range",
                date: leftDate.value,
                "min-date": unref(minDate),
                "max-date": unref(maxDate),
                "range-state": unref(rangeState),
                "disabled-date": unref(disabledDate2),
                onChangerange: unref(handleChangeRange),
                onPick: handleRangePick,
                onSelect: unref(onSelect)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
            ], 2),
            createBaseVNode("div", {
              class: normalizeClass([[unref(ppNs).e("content"), unref(drpNs).e("content")], "is-right"])
            }, [
              createBaseVNode("div", {
                class: normalizeClass(unref(drpNs).e("header"))
              }, [
                _ctx.unlinkPanels ? (openBlock(), createElementBlock("button", {
                  key: 0,
                  type: "button",
                  disabled: !unref(enableYearArrow),
                  class: normalizeClass([[unref(ppNs).e("icon-btn"), { "is-disabled": !unref(enableYearArrow) }], "d-arrow-left"]),
                  onClick: _cache[2] || (_cache[2] = (...args) => unref(rightPrevYear) && unref(rightPrevYear)(...args))
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_left_default))
                    ]),
                    _: 1
                  })
                ], 10, _hoisted_3$3)) : createCommentVNode("v-if", true),
                createBaseVNode("button", {
                  type: "button",
                  class: normalizeClass([unref(ppNs).e("icon-btn"), "d-arrow-right"]),
                  onClick: _cache[3] || (_cache[3] = (...args) => unref(rightNextYear) && unref(rightNextYear)(...args))
                }, [
                  createVNode(unref(ElIcon), null, {
                    default: withCtx(() => [
                      createVNode(unref(d_arrow_right_default))
                    ]),
                    _: 1
                  })
                ], 2),
                createBaseVNode("div", null, toDisplayString(unref(rightLabel)), 1)
              ], 2),
              createVNode(MonthTable, {
                "selection-mode": "range",
                date: rightDate.value,
                "min-date": unref(minDate),
                "max-date": unref(maxDate),
                "range-state": unref(rangeState),
                "disabled-date": unref(disabledDate2),
                onChangerange: unref(handleChangeRange),
                onPick: handleRangePick,
                onSelect: unref(onSelect)
              }, null, 8, ["date", "min-date", "max-date", "range-state", "disabled-date", "onChangerange", "onSelect"])
            ], 2)
          ], 2)
        ], 2)
      ], 2);
    };
  }
}));
var MonthRangePickPanel = /* @__PURE__ */ _export_sfc$1(_sfc_main$a, [["__file", "/home/runner/work/element-plus/element-plus/packages/components/date-picker/src/date-picker-com/panel-month-range.vue"]]);
const getPanel = function(type) {
  switch (type) {
    case "daterange":
    case "datetimerange": {
      return DateRangePickPanel;
    }
    case "monthrange": {
      return MonthRangePickPanel;
    }
    default: {
      return DatePickPanel;
    }
  }
};
dayjs.extend(localeData);
dayjs.extend(advancedFormat);
dayjs.extend(customParseFormat);
dayjs.extend(weekOfYear);
dayjs.extend(weekYear);
dayjs.extend(dayOfYear);
dayjs.extend(isSameOrAfter);
dayjs.extend(isSameOrBefore);
var DatePicker = defineComponent({
  name: "ElDatePicker",
  install: null,
  props: __spreadValues(__spreadValues({}, timePickerDefaultProps), datePickerProps),
  emits: ["update:modelValue"],
  setup(props, {
    expose,
    emit,
    slots
  }) {
    const ns2 = useNamespace("picker-panel");
    provide("ElPopperOptions", reactive(toRef(props, "popperOptions")));
    provide(ROOT_PICKER_INJECTION_KEY, {
      slots,
      pickerNs: ns2
    });
    const commonPicker = ref();
    const refProps = {
      focus: (focusStartInput = true) => {
        var _a2;
        (_a2 = commonPicker.value) == null ? void 0 : _a2.focus(focusStartInput);
      }
    };
    expose(refProps);
    const onModelValueUpdated = (val) => {
      emit("update:modelValue", val);
    };
    return () => {
      var _a2;
      const format = (_a2 = props.format) != null ? _a2 : DEFAULT_FORMATS_DATEPICKER[props.type] || DEFAULT_FORMATS_DATE;
      const Component = getPanel(props.type);
      return createVNode(CommonPicker, mergeProps(props, {
        "format": format,
        "type": props.type,
        "ref": commonPicker,
        "onUpdate:modelValue": onModelValueUpdated
      }), {
        default: (scopedProps) => createVNode(Component, scopedProps, null),
        "range-separator": slots["range-separator"]
      });
    };
  }
});
const _DatePicker = DatePicker;
_DatePicker.install = (app) => {
  app.component(_DatePicker.name, _DatePicker);
};
const ElDatePicker = _DatePicker;
class SubMenu$1 {
  constructor(parent, domNode) {
    this.parent = parent;
    this.domNode = domNode;
    this.subIndex = 0;
    this.subIndex = 0;
    this.init();
  }
  init() {
    this.subMenuItems = this.domNode.querySelectorAll("li");
    this.addListeners();
  }
  gotoSubIndex(idx) {
    if (idx === this.subMenuItems.length) {
      idx = 0;
    } else if (idx < 0) {
      idx = this.subMenuItems.length - 1;
    }
    this.subMenuItems[idx].focus();
    this.subIndex = idx;
  }
  addListeners() {
    const parentNode = this.parent.domNode;
    Array.prototype.forEach.call(this.subMenuItems, (el) => {
      el.addEventListener("keydown", (event) => {
        let prevDef = false;
        switch (event.code) {
          case EVENT_CODE.down: {
            this.gotoSubIndex(this.subIndex + 1);
            prevDef = true;
            break;
          }
          case EVENT_CODE.up: {
            this.gotoSubIndex(this.subIndex - 1);
            prevDef = true;
            break;
          }
          case EVENT_CODE.tab: {
            triggerEvent(parentNode, "mouseleave");
            break;
          }
          case EVENT_CODE.enter:
          case EVENT_CODE.space: {
            prevDef = true;
            event.currentTarget.click();
            break;
          }
        }
        if (prevDef) {
          event.preventDefault();
          event.stopPropagation();
        }
        return false;
      });
    });
  }
}
class MenuItem$1 {
  constructor(domNode, namespace) {
    this.domNode = domNode;
    this.submenu = null;
    this.submenu = null;
    this.init(namespace);
  }
  init(namespace) {
    this.domNode.setAttribute("tabindex", "0");
    const menuChild = this.domNode.querySelector(`.${namespace}-menu`);
    if (menuChild) {
      this.submenu = new SubMenu$1(this, menuChild);
    }
    this.addListeners();
  }
  addListeners() {
    this.domNode.addEventListener("keydown", (event) => {
      let prevDef = false;
      switch (event.code) {
        case EVENT_CODE.down: {
          triggerEvent(event.currentTarget, "mouseenter");
          this.submenu && this.submenu.gotoSubIndex(0);
          prevDef = true;
          break;
        }
        case EVENT_CODE.up: {
          triggerEvent(event.currentTarget, "mouseenter");
          this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
          prevDef = true;
          break;
        }
        case EVENT_CODE.tab: {
          triggerEvent(event.currentTarget, "mouseleave");
          break;
        }
        case EVENT_CODE.enter:
        case EVENT_CODE.space: {
          prevDef = true;
          event.currentTarget.click();
          break;
        }
      }
      if (prevDef) {
        event.preventDefault();
      }
    });
  }
}
class Menu$1 {
  constructor(domNode, namespace) {
    this.domNode = domNode;
    this.init(namespace);
  }
  init(namespace) {
    const menuChildren = this.domNode.childNodes;
    Array.from(menuChildren).forEach((child) => {
      if (child.nodeType === 1) {
        new MenuItem$1(child, namespace);
      }
    });
  }
}
const _sfc_main$9 = defineComponent({
  name: "ElMenuCollapseTransition",
  setup() {
    const ns2 = useNamespace("menu");
    const listeners = {
      onBeforeEnter: (el) => el.style.opacity = "0.2",
      onEnter(el, done) {
        addClass(el, `${ns2.namespace.value}-opacity-transition`);
        el.style.opacity = "1";
        done();
      },
      onAfterEnter(el) {
        removeClass(el, `${ns2.namespace.value}-opacity-transition`);
        el.style.opacity = "";
      },
      onBeforeLeave(el) {
        if (!el.dataset) {
          el.dataset = {};
        }
        if (hasClass(el, ns2.m("collapse"))) {
          removeClass(el, ns2.m("collapse"));
          el.dataset.oldOverflow = el.style.overflow;
          el.dataset.scrollWidth = el.clientWidth.toString();
          addClass(el, ns2.m("collapse"));
        } else {
          addClass(el, ns2.m("collapse"));
          el.dataset.oldOverflow = el.style.overflow;
          el.dataset.scrollWidth = el.clientWidth.toString();
          removeClass(el, ns2.m("collapse"));
        }
        el.style.width = `${el.scrollWidth}px`;
        el.style.overflow = "hidden";
      },
      onLeave(el) {
        addClass(el, "horizontal-collapse-transition");
        el.style.width = `${el.dataset.scrollWidth}px`;
      }
    };
    return {
      listeners
    };
  }
});
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, mergeProps({ mode: "out-in" }, _ctx.listeners), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16);
}
var ElMenuCollapseTransition = /* @__PURE__ */ _export_sfc$1(_sfc_main$9, [["render", _sfc_render$4], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-collapse-transition.vue"]]);
function useMenu(instance, currentIndex) {
  const indexPath = computed(() => {
    let parent = instance.parent;
    const path = [currentIndex.value];
    while (parent.type.name !== "ElMenu") {
      if (parent.props.index) {
        path.unshift(parent.props.index);
      }
      parent = parent.parent;
    }
    return path;
  });
  const parentMenu = computed(() => {
    let parent = instance.parent;
    while (parent && !["ElMenu", "ElSubMenu"].includes(parent.type.name)) {
      parent = parent.parent;
    }
    return parent;
  });
  return {
    parentMenu,
    indexPath
  };
}
function useMenuColor(props) {
  const menuBarColor = computed(() => {
    const color = props.backgroundColor;
    if (!color) {
      return "";
    } else {
      return new TinyColor(color).shade(20).toString();
    }
  });
  return menuBarColor;
}
const useMenuCssVar = (props, level) => {
  const ns2 = useNamespace("menu");
  return computed(() => {
    return ns2.cssVarBlock({
      "text-color": props.textColor || "",
      "hover-text-color": props.textColor || "",
      "bg-color": props.backgroundColor || "",
      "hover-bg-color": useMenuColor(props).value || "",
      "active-color": props.activeTextColor || "",
      level: `${level}`
    });
  });
};
const subMenuProps = buildProps({
  index: {
    type: String,
    required: true
  },
  showTimeout: {
    type: Number,
    default: 300
  },
  hideTimeout: {
    type: Number,
    default: 300
  },
  popperClass: String,
  disabled: Boolean,
  popperAppendToBody: {
    type: Boolean,
    default: void 0
  },
  popperOffset: {
    type: Number,
    default: 6
  }
});
const COMPONENT_NAME$2 = "ElSubMenu";
var SubMenu = defineComponent({
  name: COMPONENT_NAME$2,
  props: subMenuProps,
  setup(props, { slots, expose }) {
    const instance = getCurrentInstance();
    const { indexPath, parentMenu } = useMenu(instance, computed(() => props.index));
    const nsMenu = useNamespace("menu");
    const nsSubMenu = useNamespace("sub-menu");
    const rootMenu = inject("rootMenu");
    if (!rootMenu)
      throwError(COMPONENT_NAME$2, "can not inject root menu");
    const subMenu2 = inject(`subMenu:${parentMenu.value.uid}`);
    if (!subMenu2)
      throwError(COMPONENT_NAME$2, "can not inject sub menu");
    const items = ref({});
    const subMenus = ref({});
    let timeout;
    const mouseInChild = ref(false);
    const verticalTitleRef = ref();
    const vPopper = ref(null);
    const currentPlacement = computed(() => mode.value === "horizontal" && isFirstLevel.value ? "bottom-start" : "right-start");
    const subMenuTitleIcon = computed(() => {
      return mode.value === "horizontal" && isFirstLevel.value || mode.value === "vertical" && !rootMenu.props.collapse ? arrow_down_default : arrow_right_default;
    });
    const isFirstLevel = computed(() => {
      return subMenu2.level === 0;
    });
    const appendToBody = computed(() => {
      return props.popperAppendToBody === void 0 ? isFirstLevel.value : Boolean(props.popperAppendToBody);
    });
    const menuTransitionName = computed(() => rootMenu.props.collapse ? `${nsMenu.namespace.value}-zoom-in-left` : `${nsMenu.namespace.value}-zoom-in-top`);
    const fallbackPlacements = computed(() => mode.value === "horizontal" && isFirstLevel.value ? [
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end",
      "right-start",
      "left-start"
    ] : [
      "right-start",
      "left-start",
      "bottom-start",
      "bottom-end",
      "top-start",
      "top-end"
    ]);
    const opened = computed(() => rootMenu.openedMenus.includes(props.index));
    const active = computed(() => {
      let isActive = false;
      Object.values(items.value).forEach((item2) => {
        if (item2.active) {
          isActive = true;
        }
      });
      Object.values(subMenus.value).forEach((subItem) => {
        if (subItem.active) {
          isActive = true;
        }
      });
      return isActive;
    });
    const backgroundColor = computed(() => rootMenu.props.backgroundColor || "");
    const activeTextColor = computed(() => rootMenu.props.activeTextColor || "");
    const textColor = computed(() => rootMenu.props.textColor || "");
    const mode = computed(() => rootMenu.props.mode);
    const item = reactive({
      index: props.index,
      indexPath,
      active
    });
    const titleStyle = computed(() => {
      if (mode.value !== "horizontal") {
        return {
          color: textColor.value
        };
      }
      return {
        borderBottomColor: active.value ? rootMenu.props.activeTextColor ? activeTextColor.value : "" : "transparent",
        color: active.value ? activeTextColor.value : textColor.value
      };
    });
    const doDestroy = () => {
      var _a2, _b, _c;
      return (_c = (_b = (_a2 = vPopper.value) == null ? void 0 : _a2.popperRef) == null ? void 0 : _b.popperInstanceRef) == null ? void 0 : _c.destroy();
    };
    const handleCollapseToggle = (value) => {
      if (!value) {
        doDestroy();
      }
    };
    const handleClick = () => {
      if (rootMenu.props.menuTrigger === "hover" && rootMenu.props.mode === "horizontal" || rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled)
        return;
      rootMenu.handleSubMenuClick({
        index: props.index,
        indexPath: indexPath.value,
        active: active.value
      });
    };
    const handleMouseenter = (event, showTimeout = props.showTimeout) => {
      var _a2;
      if (event.type === "focus" && !event.relatedTarget) {
        return;
      }
      if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical" || props.disabled) {
        return;
      }
      subMenu2.mouseInChild.value = true;
      timeout == null ? void 0 : timeout();
      ({ stop: timeout } = useTimeoutFn(() => {
        rootMenu.openMenu(props.index, indexPath.value);
      }, showTimeout));
      if (appendToBody.value) {
        (_a2 = parentMenu.value.vnode.el) == null ? void 0 : _a2.dispatchEvent(new MouseEvent("mouseenter"));
      }
    };
    const handleMouseleave = (deepDispatch = false) => {
      var _a2, _b;
      if (rootMenu.props.menuTrigger === "click" && rootMenu.props.mode === "horizontal" || !rootMenu.props.collapse && rootMenu.props.mode === "vertical") {
        return;
      }
      timeout == null ? void 0 : timeout();
      subMenu2.mouseInChild.value = false;
      ({ stop: timeout } = useTimeoutFn(() => !mouseInChild.value && rootMenu.closeMenu(props.index, indexPath.value), props.hideTimeout));
      if (appendToBody.value && deepDispatch) {
        if (((_a2 = instance.parent) == null ? void 0 : _a2.type.name) === "ElSubMenu") {
          (_b = subMenu2.handleMouseleave) == null ? void 0 : _b.call(subMenu2, true);
        }
      }
    };
    watch(() => rootMenu.props.collapse, (value) => handleCollapseToggle(Boolean(value)));
    {
      const addSubMenu = (item2) => {
        subMenus.value[item2.index] = item2;
      };
      const removeSubMenu = (item2) => {
        delete subMenus.value[item2.index];
      };
      provide(`subMenu:${instance.uid}`, {
        addSubMenu,
        removeSubMenu,
        handleMouseleave,
        mouseInChild,
        level: subMenu2.level + 1
      });
    }
    expose({
      opened
    });
    onMounted(() => {
      rootMenu.addSubMenu(item);
      subMenu2.addSubMenu(item);
    });
    onBeforeUnmount(() => {
      subMenu2.removeSubMenu(item);
      rootMenu.removeSubMenu(item);
    });
    return () => {
      var _a2;
      const titleTag = [
        (_a2 = slots.title) == null ? void 0 : _a2.call(slots),
        h(ElIcon, {
          class: nsSubMenu.e("icon-arrow")
        }, { default: () => h(subMenuTitleIcon.value) })
      ];
      const ulStyle = useMenuCssVar(rootMenu.props, subMenu2.level + 1);
      const child = rootMenu.isMenuPopup ? h(ElTooltip, {
        ref: vPopper,
        visible: opened.value,
        effect: "light",
        pure: true,
        offset: props.popperOffset,
        showArrow: false,
        persistent: true,
        popperClass: props.popperClass,
        placement: currentPlacement.value,
        teleported: appendToBody.value,
        fallbackPlacements: fallbackPlacements.value,
        transition: menuTransitionName.value,
        gpuAcceleration: false
      }, {
        content: () => {
          var _a22;
          return h("div", {
            class: [
              nsMenu.m(mode.value),
              nsMenu.m("popup-container"),
              props.popperClass
            ],
            onMouseenter: (evt) => handleMouseenter(evt, 100),
            onMouseleave: () => handleMouseleave(true),
            onFocus: (evt) => handleMouseenter(evt, 100)
          }, [
            h("ul", {
              class: [
                nsMenu.b(),
                nsMenu.m("popup"),
                nsMenu.m(`popup-${currentPlacement.value}`)
              ],
              style: ulStyle.value
            }, [(_a22 = slots.default) == null ? void 0 : _a22.call(slots)])
          ]);
        },
        default: () => h("div", {
          class: nsSubMenu.e("title"),
          style: [
            titleStyle.value,
            { backgroundColor: backgroundColor.value }
          ],
          onClick: handleClick
        }, titleTag)
      }) : h(Fragment, {}, [
        h("div", {
          class: nsSubMenu.e("title"),
          style: [
            titleStyle.value,
            { backgroundColor: backgroundColor.value }
          ],
          ref: verticalTitleRef,
          onClick: handleClick
        }, titleTag),
        h(_CollapseTransition, {}, {
          default: () => {
            var _a22;
            return withDirectives(h("ul", {
              role: "menu",
              class: [nsMenu.b(), nsMenu.m("inline")],
              style: ulStyle.value
            }, [(_a22 = slots.default) == null ? void 0 : _a22.call(slots)]), [[vShow, opened.value]]);
          }
        })
      ]);
      return h("li", {
        class: [
          nsSubMenu.b(),
          nsSubMenu.is("active", active.value),
          nsSubMenu.is("opened", opened.value),
          nsSubMenu.is("disabled", props.disabled)
        ],
        role: "menuitem",
        ariaHaspopup: true,
        ariaExpanded: opened.value,
        onMouseenter: handleMouseenter,
        onMouseleave: () => handleMouseleave(true),
        onFocus: handleMouseenter
      }, [child]);
    };
  }
});
const menuProps = buildProps({
  mode: {
    type: String,
    values: ["horizontal", "vertical"],
    default: "vertical"
  },
  defaultActive: {
    type: String,
    default: ""
  },
  defaultOpeneds: {
    type: definePropType(Array),
    default: () => mutable([])
  },
  uniqueOpened: Boolean,
  router: Boolean,
  menuTrigger: {
    type: String,
    values: ["hover", "click"],
    default: "hover"
  },
  collapse: Boolean,
  backgroundColor: String,
  textColor: String,
  activeTextColor: String,
  collapseTransition: {
    type: Boolean,
    default: true
  },
  ellipsis: {
    type: Boolean,
    default: true
  }
});
const checkIndexPath = (indexPath) => Array.isArray(indexPath) && indexPath.every((path) => isString$1(path));
const menuEmits = {
  close: (index2, indexPath) => isString$1(index2) && checkIndexPath(indexPath),
  open: (index2, indexPath) => isString$1(index2) && checkIndexPath(indexPath),
  select: (index2, indexPath, item, routerResult) => isString$1(index2) && checkIndexPath(indexPath) && isObject$1(item) && (routerResult === void 0 || routerResult instanceof Promise)
};
var Menu = defineComponent({
  name: "ElMenu",
  props: menuProps,
  emits: menuEmits,
  setup(props, { emit, slots, expose }) {
    const instance = getCurrentInstance();
    const router = instance.appContext.config.globalProperties.$router;
    const menu2 = ref();
    const nsMenu = useNamespace("menu");
    const nsSubMenu = useNamespace("sub-menu");
    const openedMenus = ref(props.defaultOpeneds && !props.collapse ? props.defaultOpeneds.slice(0) : []);
    const activeIndex = ref(props.defaultActive);
    const items = ref({});
    const subMenus = ref({});
    const isMenuPopup = computed(() => {
      return props.mode === "horizontal" || props.mode === "vertical" && props.collapse;
    });
    const initMenu = () => {
      const activeItem = activeIndex.value && items.value[activeIndex.value];
      if (!activeItem || props.mode === "horizontal" || props.collapse)
        return;
      const indexPath = activeItem.indexPath;
      indexPath.forEach((index2) => {
        const subMenu2 = subMenus.value[index2];
        subMenu2 && openMenu(index2, subMenu2.indexPath);
      });
    };
    const openMenu = (index2, indexPath) => {
      if (openedMenus.value.includes(index2))
        return;
      if (props.uniqueOpened) {
        openedMenus.value = openedMenus.value.filter((index22) => indexPath.includes(index22));
      }
      openedMenus.value.push(index2);
      emit("open", index2, indexPath);
    };
    const closeMenu = (index2, indexPath) => {
      const i = openedMenus.value.indexOf(index2);
      if (i !== -1) {
        openedMenus.value.splice(i, 1);
      }
      emit("close", index2, indexPath);
    };
    const handleSubMenuClick = ({
      index: index2,
      indexPath
    }) => {
      const isOpened = openedMenus.value.includes(index2);
      if (isOpened) {
        closeMenu(index2, indexPath);
      } else {
        openMenu(index2, indexPath);
      }
    };
    const handleMenuItemClick = (menuItem2) => {
      if (props.mode === "horizontal" || props.collapse) {
        openedMenus.value = [];
      }
      const { index: index2, indexPath } = menuItem2;
      if (index2 === void 0 || indexPath === void 0)
        return;
      if (props.router && router) {
        const route = menuItem2.route || index2;
        const routerResult = router.push(route).then((res) => {
          if (!res)
            activeIndex.value = index2;
          return res;
        });
        emit("select", index2, indexPath, { index: index2, indexPath, route }, routerResult);
      } else {
        activeIndex.value = index2;
        emit("select", index2, indexPath, { index: index2, indexPath });
      }
    };
    const updateActiveIndex = (val) => {
      const itemsInData = items.value;
      const item = itemsInData[val] || activeIndex.value && itemsInData[activeIndex.value] || itemsInData[props.defaultActive];
      if (item) {
        activeIndex.value = item.index;
        initMenu();
      } else {
        activeIndex.value = val;
      }
    };
    const handleResize = () => {
      nextTick(() => instance.proxy.$forceUpdate());
    };
    watch(() => props.defaultActive, (currentActive) => {
      if (!items.value[currentActive]) {
        activeIndex.value = "";
      }
      updateActiveIndex(currentActive);
    });
    watch(items.value, () => initMenu());
    watch(() => props.collapse, (value) => {
      if (value)
        openedMenus.value = [];
    });
    {
      const addSubMenu = (item) => {
        subMenus.value[item.index] = item;
      };
      const removeSubMenu = (item) => {
        delete subMenus.value[item.index];
      };
      const addMenuItem = (item) => {
        items.value[item.index] = item;
      };
      const removeMenuItem = (item) => {
        delete items.value[item.index];
      };
      provide("rootMenu", reactive({
        props,
        openedMenus,
        items,
        subMenus,
        activeIndex,
        isMenuPopup,
        addMenuItem,
        removeMenuItem,
        addSubMenu,
        removeSubMenu,
        openMenu,
        closeMenu,
        handleMenuItemClick,
        handleSubMenuClick
      }));
      provide(`subMenu:${instance.uid}`, {
        addSubMenu,
        removeSubMenu,
        mouseInChild: ref(false),
        level: 0
      });
    }
    onMounted(() => {
      initMenu();
      if (props.mode === "horizontal") {
        new Menu$1(instance.vnode.el, nsMenu.namespace.value);
      }
    });
    {
      const open = (index2) => {
        const { indexPath } = subMenus.value[index2];
        indexPath.forEach((i) => openMenu(i, indexPath));
      };
      expose({
        open,
        close: closeMenu,
        handleResize
      });
    }
    const flattedChildren = (children) => {
      const vnodes = Array.isArray(children) ? children : [children];
      const result = [];
      vnodes.forEach((child) => {
        if (Array.isArray(child.children)) {
          result.push(...flattedChildren(child.children));
        } else {
          result.push(child);
        }
      });
      return result;
    };
    const useVNodeResize = (vnode) => props.mode === "horizontal" ? withDirectives(vnode, [[Resize, handleResize]]) : vnode;
    return () => {
      var _a2, _b, _c, _d;
      let slot = (_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : [];
      const vShowMore = [];
      if (props.mode === "horizontal" && menu2.value) {
        const items2 = Array.from((_d = (_c = menu2.value) == null ? void 0 : _c.childNodes) != null ? _d : []).filter((item) => item.nodeName !== "#text" || item.nodeValue);
        const originalSlot = flattedChildren(slot);
        const moreItemWidth = 64;
        const paddingLeft = Number.parseInt(getComputedStyle(menu2.value).paddingLeft, 10);
        const paddingRight = Number.parseInt(getComputedStyle(menu2.value).paddingRight, 10);
        const menuWidth = menu2.value.clientWidth - paddingLeft - paddingRight;
        let calcWidth = 0;
        let sliceIndex = 0;
        items2.forEach((item, index2) => {
          calcWidth += item.offsetWidth || 0;
          if (calcWidth <= menuWidth - moreItemWidth) {
            sliceIndex = index2 + 1;
          }
        });
        const slotDefault = originalSlot.slice(0, sliceIndex);
        const slotMore = originalSlot.slice(sliceIndex);
        if ((slotMore == null ? void 0 : slotMore.length) && props.ellipsis) {
          slot = slotDefault;
          vShowMore.push(h(SubMenu, {
            index: "sub-menu-more",
            class: nsSubMenu.e("hide-arrow")
          }, {
            title: () => h(ElIcon, {
              class: nsSubMenu.e("icon-more")
            }, { default: () => h(more_default) }),
            default: () => slotMore
          }));
        }
      }
      const ulStyle = useMenuCssVar(props, 0);
      const resizeMenu = (vNode) => props.ellipsis ? useVNodeResize(vNode) : vNode;
      const vMenu = resizeMenu(h("ul", {
        key: String(props.collapse),
        role: "menubar",
        ref: menu2,
        style: ulStyle.value,
        class: {
          [nsMenu.b()]: true,
          [nsMenu.m(props.mode)]: true,
          [nsMenu.m("collapse")]: props.collapse
        }
      }, [...slot, ...vShowMore]));
      if (props.collapseTransition && props.mode === "vertical") {
        return h(ElMenuCollapseTransition, () => vMenu);
      }
      return vMenu;
    };
  }
});
const menuItemProps = buildProps({
  index: {
    type: definePropType([String, null]),
    default: null
  },
  route: {
    type: definePropType([String, Object])
  },
  disabled: Boolean
});
const menuItemEmits = {
  click: (item) => isString$1(item.index) && Array.isArray(item.indexPath)
};
const COMPONENT_NAME$1 = "ElMenuItem";
const _sfc_main$8 = defineComponent({
  name: COMPONENT_NAME$1,
  components: {
    ElTooltip
  },
  props: menuItemProps,
  emits: menuItemEmits,
  setup(props, { emit }) {
    const instance = getCurrentInstance();
    const rootMenu = inject("rootMenu");
    const nsMenu = useNamespace("menu");
    const nsMenuItem = useNamespace("menu-item");
    if (!rootMenu)
      throwError(COMPONENT_NAME$1, "can not inject root menu");
    const { parentMenu, indexPath } = useMenu(instance, toRef(props, "index"));
    const subMenu2 = inject(`subMenu:${parentMenu.value.uid}`);
    if (!subMenu2)
      throwError(COMPONENT_NAME$1, "can not inject sub menu");
    const active = computed(() => props.index === rootMenu.activeIndex);
    const item = reactive({
      index: props.index,
      indexPath,
      active
    });
    const handleClick = () => {
      if (!props.disabled) {
        rootMenu.handleMenuItemClick({
          index: props.index,
          indexPath: indexPath.value,
          route: props.route
        });
        emit("click", item);
      }
    };
    onMounted(() => {
      subMenu2.addSubMenu(item);
      rootMenu.addMenuItem(item);
    });
    onBeforeUnmount(() => {
      subMenu2.removeSubMenu(item);
      rootMenu.removeMenuItem(item);
    });
    return {
      Effect,
      parentMenu,
      rootMenu,
      active,
      nsMenu,
      nsMenuItem,
      handleClick
    };
  }
});
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass([
      _ctx.nsMenuItem.b(),
      _ctx.nsMenuItem.is("active", _ctx.active),
      _ctx.nsMenuItem.is("disabled", _ctx.disabled)
    ]),
    role: "menuitem",
    tabindex: "-1",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.parentMenu.type.name === "ElMenu" && _ctx.rootMenu.props.collapse && _ctx.$slots.title ? (openBlock(), createBlock(_component_el_tooltip, {
      key: 0,
      effect: _ctx.Effect.DARK,
      placement: "right",
      "fallback-placements": ["left"],
      persistent: ""
    }, {
      content: withCtx(() => [
        renderSlot(_ctx.$slots, "title")
      ]),
      default: withCtx(() => [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nsMenu.be("tooltip", "trigger"))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 8, ["effect"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      renderSlot(_ctx.$slots, "default"),
      renderSlot(_ctx.$slots, "title")
    ], 64))
  ], 2);
}
var MenuItem = /* @__PURE__ */ _export_sfc$1(_sfc_main$8, [["render", _sfc_render$3], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item.vue"]]);
const menuItemGroupProps = {
  title: String
};
const COMPONENT_NAME = "ElMenuItemGroup";
const _sfc_main$7 = defineComponent({
  name: COMPONENT_NAME,
  props: menuItemGroupProps,
  setup() {
    const ns2 = useNamespace("menu-item-group");
    return {
      ns: ns2
    };
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(_ctx.ns.b())
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.ns.e("title"))
    }, [
      !_ctx.$slots.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createTextVNode(toDisplayString(_ctx.title), 1)
      ], 64)) : renderSlot(_ctx.$slots, "title", { key: 1 })
    ], 2),
    createBaseVNode("ul", null, [
      renderSlot(_ctx.$slots, "default")
    ])
  ], 2);
}
var MenuItemGroup = /* @__PURE__ */ _export_sfc$1(_sfc_main$7, [["render", _sfc_render$2], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/menu/src/menu-item-group.vue"]]);
const ElMenu = withInstall(Menu, {
  MenuItem,
  MenuItemGroup,
  SubMenu
});
const ElMenuItem = withNoopInstall(MenuItem);
const ElMenuItemGroup = withNoopInstall(MenuItemGroup);
const ElSubMenu = withNoopInstall(SubMenu);
const messageTypes = ["success", "info", "warning", "error"];
const messageProps = buildProps({
  customClass: {
    type: String,
    default: ""
  },
  center: {
    type: Boolean,
    default: false
  },
  dangerouslyUseHTMLString: {
    type: Boolean,
    default: false
  },
  duration: {
    type: Number,
    default: 3e3
  },
  icon: {
    type: iconPropType,
    default: ""
  },
  id: {
    type: String,
    default: ""
  },
  message: {
    type: definePropType([
      String,
      Object,
      Function
    ]),
    default: ""
  },
  onClose: {
    type: definePropType(Function),
    required: false
  },
  showClose: {
    type: Boolean,
    default: false
  },
  type: {
    type: String,
    values: messageTypes,
    default: "info"
  },
  offset: {
    type: Number,
    default: 20
  },
  zIndex: {
    type: Number,
    default: 0
  },
  grouping: {
    type: Boolean,
    default: false
  },
  repeatNum: {
    type: Number,
    default: 1
  }
});
const messageEmits = {
  destroy: () => true
};
const _sfc_main$6 = defineComponent({
  name: "ElMessage",
  components: __spreadValues({
    ElBadge,
    ElIcon
  }, TypeComponents),
  props: messageProps,
  emits: messageEmits,
  setup(props) {
    const ns2 = useNamespace("message");
    const visible = ref(false);
    const badgeType = ref(props.type ? props.type === "error" ? "danger" : props.type : "info");
    let stopTimer = void 0;
    const typeClass = computed(() => {
      const type = props.type;
      return { [ns2.bm("icon", type)]: type && TypeComponentsMap[type] };
    });
    const iconComponent = computed(() => {
      return props.icon || TypeComponentsMap[props.type] || "";
    });
    const customStyle = computed(() => ({
      top: `${props.offset}px`,
      zIndex: props.zIndex
    }));
    function startTimer() {
      if (props.duration > 0) {
        ({ stop: stopTimer } = useTimeoutFn(() => {
          if (visible.value)
            close2();
        }, props.duration));
      }
    }
    function clearTimer() {
      stopTimer == null ? void 0 : stopTimer();
    }
    function close2() {
      visible.value = false;
    }
    function keydown({ code }) {
      if (code === EVENT_CODE.esc) {
        if (visible.value) {
          close2();
        }
      } else {
        startTimer();
      }
    }
    onMounted(() => {
      startTimer();
      visible.value = true;
    });
    watch(() => props.repeatNum, () => {
      clearTimer();
      startTimer();
    });
    useEventListener(document, "keydown", keydown);
    return {
      ns: ns2,
      typeClass,
      iconComponent,
      customStyle,
      visible,
      badgeType,
      close: close2,
      clearTimer,
      startTimer
    };
  }
});
const _hoisted_1$6 = ["id"];
const _hoisted_2$6 = ["innerHTML"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_badge = resolveComponent("el-badge");
  const _component_el_icon = resolveComponent("el-icon");
  const _component_close = resolveComponent("close");
  return openBlock(), createBlock(Transition, {
    name: _ctx.ns.b("fade"),
    onBeforeLeave: _ctx.onClose,
    onAfterLeave: _cache[2] || (_cache[2] = ($event) => _ctx.$emit("destroy")),
    persisted: ""
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        id: _ctx.id,
        class: normalizeClass([
          _ctx.ns.b(),
          { [_ctx.ns.m(_ctx.type)]: _ctx.type && !_ctx.icon },
          _ctx.ns.is("center", _ctx.center),
          _ctx.ns.is("closable", _ctx.showClose),
          _ctx.customClass
        ]),
        style: normalizeStyle(_ctx.customStyle),
        role: "alert",
        onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.clearTimer && _ctx.clearTimer(...args)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.startTimer && _ctx.startTimer(...args))
      }, [
        _ctx.repeatNum > 1 ? (openBlock(), createBlock(_component_el_badge, {
          key: 0,
          value: _ctx.repeatNum,
          type: _ctx.badgeType,
          class: normalizeClass(_ctx.ns.e("badge"))
        }, null, 8, ["value", "type", "class"])) : createCommentVNode("v-if", true),
        _ctx.iconComponent ? (openBlock(), createBlock(_component_el_icon, {
          key: 1,
          class: normalizeClass([_ctx.ns.e("icon"), _ctx.typeClass])
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(_ctx.iconComponent)))
          ]),
          _: 1
        }, 8, ["class"])) : createCommentVNode("v-if", true),
        renderSlot(_ctx.$slots, "default", {}, () => [
          !_ctx.dangerouslyUseHTMLString ? (openBlock(), createElementBlock("p", {
            key: 0,
            class: normalizeClass(_ctx.ns.e("content"))
          }, toDisplayString(_ctx.message), 3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createCommentVNode(" Caution here, message could've been compromised, never use user's input as message "),
            createBaseVNode("p", {
              class: normalizeClass(_ctx.ns.e("content")),
              innerHTML: _ctx.message
            }, null, 10, _hoisted_2$6)
          ], 2112))
        ]),
        _ctx.showClose ? (openBlock(), createBlock(_component_el_icon, {
          key: 2,
          class: normalizeClass(_ctx.ns.e("closeBtn")),
          onClick: withModifiers(_ctx.close, ["stop"])
        }, {
          default: withCtx(() => [
            createVNode(_component_close)
          ]),
          _: 1
        }, 8, ["class", "onClick"])) : createCommentVNode("v-if", true)
      ], 46, _hoisted_1$6), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  }, 8, ["name", "onBeforeLeave"]);
}
var MessageConstructor = /* @__PURE__ */ _export_sfc$1(_sfc_main$6, [["render", _sfc_render$1], ["__file", "/home/runner/work/element-plus/element-plus/packages/components/message/src/message.vue"]]);
const instances = [];
let seed = 1;
const message$1 = function(options = {}, context) {
  if (!isClient)
    return { close: () => void 0 };
  if (isNumber(messageConfig.max) && instances.length >= messageConfig.max) {
    return { close: () => void 0 };
  }
  if (!isVNode(options) && isObject$1(options) && options.grouping && !isVNode(options.message) && instances.length) {
    const tempVm = instances.find((item) => {
      var _a2, _b, _c;
      return `${(_b = (_a2 = item.vm.props) == null ? void 0 : _a2.message) != null ? _b : ""}` === `${(_c = options.message) != null ? _c : ""}`;
    });
    if (tempVm) {
      tempVm.vm.component.props.repeatNum += 1;
      tempVm.vm.component.props.type = (options == null ? void 0 : options.type) || "info";
      return {
        close: () => vm.component.proxy.visible = false
      };
    }
  }
  if (isString$1(options) || isVNode(options)) {
    options = { message: options };
  }
  let verticalOffset = options.offset || 20;
  instances.forEach(({ vm: vm2 }) => {
    var _a2;
    verticalOffset += (((_a2 = vm2.el) == null ? void 0 : _a2.offsetHeight) || 0) + 16;
  });
  verticalOffset += 16;
  const { nextZIndex } = useZIndex();
  const id = `message_${seed++}`;
  const userOnClose = options.onClose;
  const props = __spreadProps(__spreadValues({
    zIndex: nextZIndex()
  }, options), {
    offset: verticalOffset,
    id,
    onClose: () => {
      close(id, userOnClose);
    }
  });
  let appendTo = document.body;
  if (isElement(options.appendTo)) {
    appendTo = options.appendTo;
  } else if (isString$1(options.appendTo)) {
    appendTo = document.querySelector(options.appendTo);
  }
  if (!isElement(appendTo)) {
    appendTo = document.body;
  }
  const container = document.createElement("div");
  container.className = `container_${id}`;
  const messageContent = props.message;
  const vm = createVNode(MessageConstructor, props, isFunction$1(messageContent) ? { default: messageContent } : isVNode(messageContent) ? { default: () => messageContent } : null);
  vm.appContext = context || message$1._context;
  vm.props.onDestroy = () => {
    render(null, container);
  };
  render(vm, container);
  instances.push({ vm });
  appendTo.appendChild(container.firstElementChild);
  return {
    close: () => vm.component.proxy.visible = false
  };
};
messageTypes.forEach((type) => {
  message$1[type] = (options = {}, appContext) => {
    if (isString$1(options) || isVNode(options)) {
      options = {
        message: options
      };
    }
    return message$1(__spreadProps(__spreadValues({}, options), {
      type
    }), appContext);
  };
});
function close(id, userOnClose) {
  const idx = instances.findIndex(({ vm: vm2 }) => id === vm2.component.props.id);
  if (idx === -1)
    return;
  const { vm } = instances[idx];
  if (!vm)
    return;
  userOnClose == null ? void 0 : userOnClose(vm);
  const removedHeight = vm.el.offsetHeight;
  instances.splice(idx, 1);
  const len = instances.length;
  if (len < 1)
    return;
  for (let i = idx; i < len; i++) {
    const pos = Number.parseInt(instances[i].vm.el.style["top"], 10) - removedHeight - 16;
    instances[i].vm.component.props.offset = pos;
  }
}
function closeAll() {
  var _a2;
  for (let i = instances.length - 1; i >= 0; i--) {
    const instance = instances[i].vm.component;
    (_a2 = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a2.close();
  }
}
message$1.closeAll = closeAll;
message$1._context = null;
const ElMessage = withInstallFunction(message$1, "$message");
var base = /* @__PURE__ */ (() => '@charset "UTF-8";html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}:root{--ep-color-white: #ffffff;--ep-color-black: #000000;--ep-color-primary-rgb: 0, 128, 0;--ep-color-success-rgb: 33, 186, 69;--ep-color-warning-rgb: 242, 113, 28;--ep-color-danger-rgb: 219, 40, 40;--ep-color-error-rgb: 219, 40, 40;--ep-color-info-rgb: 66, 184, 221;--ep-font-size-extra-large: 20px;--ep-font-size-large: 18px;--ep-font-size-medium: 16px;--ep-font-size-base: 14px;--ep-font-size-small: 13px;--ep-font-size-extra-small: 12px;--ep-font-family: "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "\\5fae\\8f6f\\96c5\\9ed1", Arial, sans-serif;--ep-font-weight-primary: 500;--ep-font-line-height-primary: 24px;--ep-index-normal: 1;--ep-index-top: 1000;--ep-index-popper: 2000;--ep-border-radius-base: 4px;--ep-border-radius-small: 2px;--ep-border-radius-round: 20px;--ep-border-radius-circle: 100%;--ep-transition-duration: .3s;--ep-transition-duration-fast: .2s;--ep-transition-function-ease-in-out-bezier: cubic-bezier(.645, .045, .355, 1);--ep-transition-function-fast-bezier: cubic-bezier(.23, 1, .32, 1);--ep-transition-all: all var(--ep-transition-duration) var(--ep-transition-function-ease-in-out-bezier);--ep-transition-fade: opacity var(--ep-transition-duration) var(--ep-transition-function-fast-bezier);--ep-transition-md-fade: transform var(--ep-transition-duration) var(--ep-transition-function-fast-bezier), opacity var(--ep-transition-duration) var(--ep-transition-function-fast-bezier);--ep-transition-fade-linear: opacity var(--ep-transition-duration-fast) linear;--ep-transition-border: border-color var(--ep-transition-duration-fast) var(--ep-transition-function-ease-in-out-bezier);--ep-transition-box-shadow: box-shadow var(--ep-transition-duration-fast) var(--ep-transition-function-ease-in-out-bezier);--ep-transition-color: color var(--ep-transition-duration-fast) var(--ep-transition-function-ease-in-out-bezier);--ep-component-size-large: 40px;--ep-component-size: 32px;--ep-component-size-small: 24px}:root{color-scheme:light;--ep-color-white: #ffffff;--ep-color-black: #000000;--ep-color-primary: green;--ep-color-primary-light-3: #4da64d;--ep-color-primary-light-5: #80c080;--ep-color-primary-light-7: #b3d9b3;--ep-color-primary-light-8: #cce6cc;--ep-color-primary-light-9: #e6f2e6;--ep-color-primary-dark-2: #006600;--ep-color-success: #21ba45;--ep-color-success-light-3: #64cf7d;--ep-color-success-light-5: #90dda2;--ep-color-success-light-7: #bceac7;--ep-color-success-light-8: #d3f1da;--ep-color-success-light-9: #e9f8ec;--ep-color-success-dark-2: #1a9537;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #f69c60;--ep-color-warning-light-5: #f9b88e;--ep-color-warning-light-7: #fbd4bb;--ep-color-warning-light-8: #fce3d2;--ep-color-warning-light-9: #fef1e8;--ep-color-warning-dark-2: #c25a16;--ep-color-danger: #db2828;--ep-color-danger-light-3: #e66969;--ep-color-danger-light-5: #ed9494;--ep-color-danger-light-7: #f4bfbf;--ep-color-danger-light-8: #f8d4d4;--ep-color-danger-light-9: #fbeaea;--ep-color-danger-dark-2: #af2020;--ep-color-error: #db2828;--ep-color-error-light-3: #e66969;--ep-color-error-light-5: #ed9494;--ep-color-error-light-7: #f4bfbf;--ep-color-error-light-8: #f8d4d4;--ep-color-error-light-9: #fbeaea;--ep-color-error-dark-2: #af2020;--ep-color-info: #42b8dd;--ep-color-info-light-3: #7bcde7;--ep-color-info-light-5: #a1dcee;--ep-color-info-light-7: #c6eaf5;--ep-color-info-light-8: #d9f1f8;--ep-color-info-light-9: #ecf8fc;--ep-color-info-dark-2: #3593b1;--ep-bg-color: #ffffff;--ep-bg-color-page: #f2f3f5;--ep-bg-color-overlay: #ffffff;--ep-text-color-primary: #303133;--ep-text-color-regular: #606266;--ep-text-color-secondary: #909399;--ep-text-color-placeholder: #a8abb2;--ep-text-color-disabled: #c0c4cc;--ep-border-color: #dcdfe6;--ep-border-color-light: #e4e7ed;--ep-border-color-lighter: #ebeef5;--ep-border-color-extra-light: #f2f6fc;--ep-border-color-dark: #d4d7de;--ep-border-color-darker: #cdd0d6;--ep-fill-color: #f0f2f5;--ep-fill-color-light: #f5f7fa;--ep-fill-color-lighter: #fafafa;--ep-fill-color-extra-light: #fafcff;--ep-fill-color-dark: #ebedf0;--ep-fill-color-darker: #e6e8eb;--ep-fill-color-blank: #ffffff;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .04), 0px 8px 20px rgba(0, 0, 0, .08);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .12);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .12);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .08), 0px 12px 32px rgba(0, 0, 0, .12), 0px 8px 16px -8px rgba(0, 0, 0, .16);--ep-disabled-bg-color: var(--ep-fill-color-light);--ep-disabled-text-color: var(--ep-text-color-placeholder);--ep-disabled-border-color: var(--ep-border-color-light);--ep-overlay-color: rgba(0, 0, 0, .8);--ep-overlay-color-light: rgba(0, 0, 0, .7);--ep-overlay-color-lighter: rgba(0, 0, 0, .5);--ep-mask-color: rgba(255, 255, 255, .9);--ep-mask-color-extra-light: rgba(255, 255, 255, .3);--ep-border-width: 1px;--ep-border-style: solid;--ep-border-color-hover: var(--ep-text-color-disabled);--ep-border: var(--ep-border-width) var(--ep-border-style) var(--ep-border-color);--ep-svg-monochrome-grey: var(--ep-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--ep-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.ep-fade-in-linear-enter-active,.ep-fade-in-linear-leave-active{transition:var(--ep-transition-fade-linear)}.ep-fade-in-linear-enter-from,.ep-fade-in-linear-leave-to{opacity:0}.ep-fade-in-enter-active,.ep-fade-in-leave-active{transition:all var(--ep-transition-duration) cubic-bezier(.55,0,.1,1)}.ep-fade-in-enter-from,.ep-fade-in-leave-active{opacity:0}.ep-zoom-in-center-enter-active,.ep-zoom-in-center-leave-active{transition:all var(--ep-transition-duration) cubic-bezier(.55,0,.1,1)}.ep-zoom-in-center-enter-from,.ep-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.ep-zoom-in-top-enter-active,.ep-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--ep-transition-md-fade);transform-origin:center top}.ep-zoom-in-top-enter-active[data-popper-placement^=top],.ep-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.ep-zoom-in-top-enter-from,.ep-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.ep-zoom-in-bottom-enter-active,.ep-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--ep-transition-md-fade);transform-origin:center bottom}.ep-zoom-in-bottom-enter-from,.ep-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.ep-zoom-in-left-enter-active,.ep-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:var(--ep-transition-md-fade);transform-origin:top left}.ep-zoom-in-left-enter-from,.ep-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--ep-transition-duration) height ease-in-out,var(--ep-transition-duration) padding-top ease-in-out,var(--ep-transition-duration) padding-bottom ease-in-out}.ep-collapse-transition-leave-active,.ep-collapse-transition-enter-active{transition:var(--ep-transition-duration) max-height ease-in-out,var(--ep-transition-duration) padding-top ease-in-out,var(--ep-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--ep-transition-duration) width ease-in-out,var(--ep-transition-duration) padding-left ease-in-out,var(--ep-transition-duration) padding-right ease-in-out}.ep-list-enter-active,.ep-list-leave-active{transition:all 1s}.ep-list-enter-from,.ep-list-leave-to{opacity:0;transform:translateY(-30px)}.ep-list-leave-active{position:absolute!important}.ep-opacity-transition{transition:opacity var(--ep-transition-duration) cubic-bezier(.55,0,.1,1)}.ep-icon-loading{animation:rotating 2s linear infinite}.ep-icon--right{margin-left:5px}.ep-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.ep-icon{--color: inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.ep-icon.is-loading{animation:rotating 2s linear infinite}.ep-icon svg{height:1em;width:1em}\n')();
var configProvider = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}\n")();
var datePicker = /* @__PURE__ */ (() => 'html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}.ep-date-table{font-size:12px;user-select:none}.ep-date-table.is-week-mode .ep-date-table__row:hover .ep-date-table-cell{background-color:var(--ep-datepicker-inrange-bg-color)}.ep-date-table.is-week-mode .ep-date-table__row:hover td.available:hover{color:var(--ep-datepicker-text-color)}.ep-date-table.is-week-mode .ep-date-table__row:hover td:first-child .ep-date-table-cell{margin-left:5px;border-top-left-radius:15px;border-bottom-left-radius:15px}.ep-date-table.is-week-mode .ep-date-table__row:hover td:last-child .ep-date-table-cell{margin-right:5px;border-top-right-radius:15px;border-bottom-right-radius:15px}.ep-date-table.is-week-mode .ep-date-table__row.current .ep-date-table-cell{background-color:var(--ep-datepicker-inrange-bg-color)}.ep-date-table td{width:32px;height:30px;padding:4px 0;box-sizing:border-box;text-align:center;cursor:pointer;position:relative}.ep-date-table td .ep-date-table-cell{height:30px;padding:3px 0;box-sizing:border-box}.ep-date-table td .ep-date-table-cell .ep-date-table-cell__text{width:24px;height:24px;display:block;margin:0 auto;line-height:24px;position:absolute;left:50%;transform:translate(-50%);border-radius:50%}.ep-date-table td.next-month,.ep-date-table td.prev-month{color:var(--ep-datepicker-off-text-color)}.ep-date-table td.today{position:relative}.ep-date-table td.today .ep-date-table-cell__text{color:var(--ep-color-primary);font-weight:700}.ep-date-table td.today.start-date .ep-date-table-cell__text,.ep-date-table td.today.end-date .ep-date-table-cell__text{color:#fff}.ep-date-table td.available:hover{color:var(--ep-datepicker-hover-text-color)}.ep-date-table td.in-range .ep-date-table-cell{background-color:var(--ep-datepicker-inrange-bg-color)}.ep-date-table td.in-range .ep-date-table-cell:hover{background-color:var(--ep-datepicker-inrange-hover-bg-color)}.ep-date-table td.current:not(.disabled) .ep-date-table-cell__text{color:#fff;background-color:var(--ep-datepicker-active-color)}.ep-date-table td.current:not(.disabled):focus-visible .ep-date-table-cell__text{outline:2px solid var(--ep-datepicker-active-color);outline-offset:1px}.ep-date-table td.start-date .ep-date-table-cell,.ep-date-table td.end-date .ep-date-table-cell{color:#fff}.ep-date-table td.start-date .ep-date-table-cell__text,.ep-date-table td.end-date .ep-date-table-cell__text{background-color:var(--ep-datepicker-active-color)}.ep-date-table td.start-date .ep-date-table-cell{margin-left:5px;border-top-left-radius:15px;border-bottom-left-radius:15px}.ep-date-table td.end-date .ep-date-table-cell{margin-right:5px;border-top-right-radius:15px;border-bottom-right-radius:15px}.ep-date-table td.disabled .ep-date-table-cell{background-color:var(--ep-fill-color-light);opacity:1;cursor:not-allowed;color:var(--ep-text-color-placeholder)}.ep-date-table td.selected .ep-date-table-cell{margin-left:5px;margin-right:5px;background-color:var(--ep-datepicker-inrange-bg-color);border-radius:15px}.ep-date-table td.selected .ep-date-table-cell:hover{background-color:var(--ep-datepicker-inrange-hover-bg-color)}.ep-date-table td.selected .ep-date-table-cell__text{background-color:var(--ep-datepicker-active-color);color:#fff;border-radius:15px}.ep-date-table td.week{font-size:80%;color:var(--ep-datepicker-header-text-color)}.ep-date-table td:focus{outline:none}.ep-date-table th{padding:5px;color:var(--ep-datepicker-header-text-color);font-weight:400;border-bottom:solid 1px var(--ep-border-color-lighter)}.ep-month-table{font-size:12px;margin:-1px;border-collapse:collapse}.ep-month-table td{text-align:center;padding:8px 0;cursor:pointer}.ep-month-table td div{height:48px;padding:6px 0;box-sizing:border-box}.ep-month-table td.today .cell{color:var(--ep-color-primary);font-weight:700}.ep-month-table td.today.start-date .cell,.ep-month-table td.today.end-date .cell{color:#fff}.ep-month-table td.disabled .cell{background-color:var(--ep-fill-color-light);cursor:not-allowed;color:var(--ep-text-color-placeholder)}.ep-month-table td.disabled .cell:hover{color:var(--ep-text-color-placeholder)}.ep-month-table td .cell{width:60px;height:36px;display:block;line-height:36px;color:var(--ep-datepicker-text-color);margin:0 auto;border-radius:18px}.ep-month-table td .cell:hover{color:var(--ep-datepicker-hover-text-color)}.ep-month-table td.in-range div{background-color:var(--ep-datepicker-inrange-bg-color)}.ep-month-table td.in-range div:hover{background-color:var(--ep-datepicker-inrange-hover-bg-color)}.ep-month-table td.start-date div,.ep-month-table td.end-date div{color:#fff}.ep-month-table td.start-date .cell,.ep-month-table td.end-date .cell{color:#fff;background-color:var(--ep-datepicker-active-color)}.ep-month-table td.start-date div{border-top-left-radius:24px;border-bottom-left-radius:24px}.ep-month-table td.end-date div{border-top-right-radius:24px;border-bottom-right-radius:24px}.ep-month-table td.current:not(.disabled) .cell{color:var(--ep-datepicker-active-color)}.ep-month-table td:focus-visible{outline:none}.ep-month-table td:focus-visible .cell{outline:2px solid var(--ep-datepicker-active-color)}.ep-year-table{font-size:12px;margin:-1px;border-collapse:collapse}.ep-year-table .ep-icon{color:var(--ep-datepicker-icon-color)}.ep-year-table td{text-align:center;padding:20px 3px;cursor:pointer}.ep-year-table td.today .cell{color:var(--ep-color-primary);font-weight:700}.ep-year-table td.disabled .cell{background-color:var(--ep-fill-color-light);cursor:not-allowed;color:var(--ep-text-color-placeholder)}.ep-year-table td.disabled .cell:hover{color:var(--ep-text-color-placeholder)}.ep-year-table td .cell{width:48px;height:36px;display:block;line-height:36px;color:var(--ep-datepicker-text-color);border-radius:18px;margin:0 auto}.ep-year-table td .cell:hover{color:var(--ep-datepicker-hover-text-color)}.ep-year-table td.current:not(.disabled) .cell{color:var(--ep-datepicker-active-color)}.ep-year-table td:focus-visible{outline:none}.ep-year-table td:focus-visible .cell{outline:2px solid var(--ep-datepicker-active-color)}.ep-time-spinner.has-seconds .ep-time-spinner__wrapper{width:33.3%}.ep-time-spinner__wrapper{max-height:192px;overflow:auto;display:inline-block;width:50%;vertical-align:top;position:relative}.ep-time-spinner__wrapper.ep-scrollbar__wrap:not(.ep-scrollbar__wrap--hidden-default){padding-bottom:15px}.ep-time-spinner__wrapper.is-arrow{box-sizing:border-box;text-align:center;overflow:hidden}.ep-time-spinner__wrapper.is-arrow .ep-time-spinner__list{transform:translateY(-32px)}.ep-time-spinner__wrapper.is-arrow .ep-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--ep-fill-color-light);cursor:default}.ep-time-spinner__arrow{font-size:12px;color:var(--ep-text-color-secondary);position:absolute;left:0;width:100%;z-index:var(--ep-index-normal);text-align:center;height:30px;line-height:30px;cursor:pointer}.ep-time-spinner__arrow:hover{color:var(--ep-color-primary)}.ep-time-spinner__arrow.arrow-up{top:10px}.ep-time-spinner__arrow.arrow-down{bottom:10px}.ep-time-spinner__input.ep-input{width:70%}.ep-time-spinner__input.ep-input .ep-input__inner{padding:0;text-align:center}.ep-time-spinner__list{padding:0;margin:0;list-style:none;text-align:center}.ep-time-spinner__list:after,.ep-time-spinner__list:before{content:"";display:block;width:100%;height:80px}.ep-time-spinner__item{height:32px;line-height:32px;font-size:12px;color:var(--ep-text-color-regular)}.ep-time-spinner__item:hover:not(.is-disabled):not(.is-active){background:var(--ep-fill-color-light);cursor:pointer}.ep-time-spinner__item.is-active:not(.is-disabled){color:var(--ep-text-color-primary);font-weight:700}.ep-time-spinner__item.is-disabled{color:var(--ep-text-color-placeholder);cursor:not-allowed}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--ep-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.ep-fade-in-linear-enter-active,.ep-fade-in-linear-leave-active{transition:var(--ep-transition-fade-linear)}.ep-fade-in-linear-enter-from,.ep-fade-in-linear-leave-to{opacity:0}.ep-fade-in-enter-active,.ep-fade-in-leave-active{transition:all var(--ep-transition-duration) cubic-bezier(.55,0,.1,1)}.ep-fade-in-enter-from,.ep-fade-in-leave-active{opacity:0}.ep-zoom-in-center-enter-active,.ep-zoom-in-center-leave-active{transition:all var(--ep-transition-duration) cubic-bezier(.55,0,.1,1)}.ep-zoom-in-center-enter-from,.ep-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.ep-zoom-in-top-enter-active,.ep-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--ep-transition-md-fade);transform-origin:center top}.ep-zoom-in-top-enter-active[data-popper-placement^=top],.ep-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.ep-zoom-in-top-enter-from,.ep-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.ep-zoom-in-bottom-enter-active,.ep-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--ep-transition-md-fade);transform-origin:center bottom}.ep-zoom-in-bottom-enter-from,.ep-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.ep-zoom-in-left-enter-active,.ep-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:var(--ep-transition-md-fade);transform-origin:top left}.ep-zoom-in-left-enter-from,.ep-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--ep-transition-duration) height ease-in-out,var(--ep-transition-duration) padding-top ease-in-out,var(--ep-transition-duration) padding-bottom ease-in-out}.ep-collapse-transition-leave-active,.ep-collapse-transition-enter-active{transition:var(--ep-transition-duration) max-height ease-in-out,var(--ep-transition-duration) padding-top ease-in-out,var(--ep-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--ep-transition-duration) width ease-in-out,var(--ep-transition-duration) padding-left ease-in-out,var(--ep-transition-duration) padding-right ease-in-out}.ep-list-enter-active,.ep-list-leave-active{transition:all 1s}.ep-list-enter-from,.ep-list-leave-to{opacity:0;transform:translateY(-30px)}.ep-list-leave-active{position:absolute!important}.ep-opacity-transition{transition:opacity var(--ep-transition-duration) cubic-bezier(.55,0,.1,1)}.ep-picker__popper{--ep-datepicker-border-color: var(--ep-disabled-border-color)}.ep-picker__popper.ep-popper{background:var(--ep-bg-color-overlay);border:1px solid var(--ep-datepicker-border-color);box-shadow:var(--ep-box-shadow-light)}.ep-picker__popper.ep-popper .ep-popper__arrow:before{border:1px solid var(--ep-datepicker-border-color)}.ep-picker__popper.ep-popper[data-popper-placement^=top] .ep-popper__arrow:before{border-top-color:transparent;border-left-color:transparent}.ep-picker__popper.ep-popper[data-popper-placement^=bottom] .ep-popper__arrow:before{border-bottom-color:transparent;border-right-color:transparent}.ep-picker__popper.ep-popper[data-popper-placement^=left] .ep-popper__arrow:before{border-left-color:transparent;border-bottom-color:transparent}.ep-picker__popper.ep-popper[data-popper-placement^=right] .ep-popper__arrow:before{border-right-color:transparent;border-top-color:transparent}.ep-date-editor{--ep-date-editor-width: 220px;--ep-date-editor-monthrange-width: 300px;--ep-date-editor-daterange-width: 350px;--ep-date-editor-datetimerange-width: 400px;--ep-input-text-color: var(--ep-text-color-regular);--ep-input-border: var(--ep-border);--ep-input-hover-border: var(--ep-border-color-hover);--ep-input-focus-border: var(--ep-color-primary);--ep-input-transparent-border: 0 0 0 1px transparent inset;--ep-input-border-color: var(--ep-border-color);--ep-input-border-radius: var(--ep-border-radius-base);--ep-input-bg-color: var(--ep-fill-color-blank);--ep-input-icon-color: var(--ep-text-color-placeholder);--ep-input-placeholder-color: var(--ep-text-color-placeholder);--ep-input-hover-border-color: var(--ep-border-color-hover);--ep-input-clear-hover-color: var(--ep-text-color-secondary);--ep-input-focus-border-color: var(--ep-color-primary);position:relative;display:inline-block;text-align:left}.ep-date-editor.ep-input__wrapper{box-shadow:0 0 0 1px var(--ep-input-border-color, var(--ep-border-color)) inset}.ep-date-editor.ep-input__wrapper:hover{box-shadow:0 0 0 1px var(--ep-input-hover-border-color) inset}.ep-date-editor.ep-input,.ep-date-editor.ep-input__wrapper{width:var(--ep-date-editor-width);height:var(--ep-input-height, var(--ep-component-size))}.ep-date-editor--monthrange{--ep-date-editor-width: var(--ep-date-editor-monthrange-width)}.ep-date-editor--daterange,.ep-date-editor--timerange{--ep-date-editor-width: var(--ep-date-editor-daterange-width)}.ep-date-editor--datetimerange{--ep-date-editor-width: var(--ep-date-editor-datetimerange-width)}.ep-date-editor--dates .ep-input__wrapper{text-overflow:ellipsis;white-space:nowrap}.ep-date-editor .close-icon,.ep-date-editor .clear-icon{cursor:pointer}.ep-date-editor .clear-icon:hover{color:var(--ep-text-color-secondary)}.ep-date-editor .ep-range__icon{height:inherit;font-size:14px;color:var(--ep-text-color-placeholder);float:left}.ep-date-editor .ep-range__icon svg{vertical-align:middle}.ep-date-editor .ep-range-input{appearance:none;border:none;outline:none;display:inline-block;height:100%;margin:0;padding:0;width:39%;text-align:center;font-size:var(--ep-font-size-base);color:var(--ep-text-color-regular);background-color:transparent}.ep-date-editor .ep-range-input::placeholder{color:var(--ep-text-color-placeholder)}.ep-date-editor .ep-range-separator{flex:1;display:inline-flex;justify-content:center;align-items:center;height:100%;padding:0 5px;margin:0;font-size:14px;word-break:keep-all;color:var(--ep-text-color-primary)}.ep-date-editor .ep-range__close-icon{font-size:14px;color:var(--ep-text-color-placeholder);height:inherit;width:unset;cursor:pointer}.ep-date-editor .ep-range__close-icon:hover{color:var(--ep-text-color-secondary)}.ep-date-editor .ep-range__close-icon svg{vertical-align:middle}.ep-date-editor .ep-range__close-icon--hidden{opacity:0;visibility:hidden}.ep-range-editor.ep-input__wrapper{display:inline-flex;align-items:center;padding:0 10px}.ep-range-editor .ep-range-input{line-height:1}.ep-range-editor.is-active,.ep-range-editor.is-active:hover{box-shadow:0 0 0 1px var(--ep-input-focus-border-color) inset}.ep-range-editor--large{line-height:var(--ep-component-size-large)}.ep-range-editor--large.ep-input__wrapper{height:var(--ep-component-size-large)}.ep-range-editor--large .ep-range-separator{line-height:40px;font-size:14px}.ep-range-editor--large .ep-range-input{font-size:14px}.ep-range-editor--small{line-height:var(--ep-component-size-small)}.ep-range-editor--small.ep-input__wrapper{height:var(--ep-component-size-small)}.ep-range-editor--small .ep-range-separator{line-height:24px;font-size:12px}.ep-range-editor--small .ep-range-input{font-size:12px}.ep-range-editor.is-disabled{background-color:var(--ep-disabled-bg-color);border-color:var(--ep-disabled-border-color);color:var(--ep-disabled-text-color);cursor:not-allowed}.ep-range-editor.is-disabled:hover,.ep-range-editor.is-disabled:focus{border-color:var(--ep-disabled-border-color)}.ep-range-editor.is-disabled input{background-color:var(--ep-disabled-bg-color);color:var(--ep-disabled-text-color);cursor:not-allowed}.ep-range-editor.is-disabled input::placeholder{color:var(--ep-text-color-placeholder)}.ep-range-editor.is-disabled .ep-range-separator{color:var(--ep-disabled-text-color)}.ep-picker-panel{color:var(--ep-text-color-regular);background:var(--ep-bg-color-overlay);border-radius:var(--ep-border-radius-base);line-height:30px}.ep-picker-panel .ep-time-panel{margin:5px 0;border:solid 1px var(--ep-datepicker-border-color);background-color:var(--ep-bg-color-overlay);box-shadow:var(--ep-box-shadow-light)}.ep-picker-panel__body:after,.ep-picker-panel__body-wrapper:after{content:"";display:table;clear:both}.ep-picker-panel__content{position:relative;margin:15px}.ep-picker-panel__footer{border-top:1px solid var(--ep-datepicker-inner-border-color);padding:4px 12px;text-align:right;background-color:var(--ep-bg-color-overlay);position:relative;font-size:0}.ep-picker-panel__shortcut{display:block;width:100%;border:0;background-color:transparent;line-height:28px;font-size:14px;color:var(--ep-datepicker-text-color);padding-left:12px;text-align:left;outline:none;cursor:pointer}.ep-picker-panel__shortcut:hover{color:var(--ep-datepicker-hover-text-color)}.ep-picker-panel__shortcut.active{background-color:#e6f1fe;color:var(--ep-datepicker-active-color)}.ep-picker-panel__btn{border:1px solid var(--ep-fill-color-darker);color:var(--ep-text-color-primary);line-height:24px;border-radius:2px;padding:0 20px;cursor:pointer;background-color:transparent;outline:none;font-size:12px}.ep-picker-panel__btn[disabled]{color:var(--ep-text-color-disabled);cursor:not-allowed}.ep-picker-panel__icon-btn{font-size:12px;color:var(--ep-datepicker-icon-color);border:0;background:transparent;cursor:pointer;outline:none;margin-top:8px}.ep-picker-panel__icon-btn:hover{color:var(--ep-datepicker-hover-text-color)}.ep-picker-panel__icon-btn:focus-visible{color:var(--ep-datepicker-hover-text-color)}.ep-picker-panel__icon-btn.is-disabled{color:var(--ep-text-color-disabled)}.ep-picker-panel__icon-btn.is-disabled:hover{cursor:not-allowed}.ep-picker-panel__icon-btn .ep-icon{cursor:pointer;font-size:inherit}.ep-picker-panel__link-btn{vertical-align:middle}.ep-picker-panel *[slot=sidebar],.ep-picker-panel__sidebar{position:absolute;top:0;bottom:0;width:110px;border-right:1px solid var(--ep-datepicker-inner-border-color);box-sizing:border-box;padding-top:6px;background-color:var(--ep-bg-color-overlay);overflow:auto}.ep-picker-panel *[slot=sidebar]+.ep-picker-panel__body,.ep-picker-panel__sidebar+.ep-picker-panel__body{margin-left:110px}.ep-date-picker{--ep-datepicker-text-color: var(--ep-text-color-regular);--ep-datepicker-off-text-color: var(--ep-text-color-placeholder);--ep-datepicker-header-text-color: var(--ep-text-color-regular);--ep-datepicker-icon-color: var(--ep-text-color-primary);--ep-datepicker-border-color: var(--ep-disabled-border-color);--ep-datepicker-inner-border-color: var(--ep-border-color-light);--ep-datepicker-inrange-bg-color: var(--ep-border-color-extra-light);--ep-datepicker-inrange-hover-bg-color: var(--ep-border-color-extra-light);--ep-datepicker-active-color: var(--ep-color-primary);--ep-datepicker-hover-text-color: var(--ep-color-primary)}.ep-date-picker{width:322px}.ep-date-picker.has-sidebar.has-time{width:434px}.ep-date-picker.has-sidebar{width:438px}.ep-date-picker.has-time .ep-picker-panel__body-wrapper{position:relative}.ep-date-picker .ep-picker-panel__content{width:292px}.ep-date-picker table{table-layout:fixed;width:100%}.ep-date-picker__editor-wrap{position:relative;display:table-cell;padding:0 5px}.ep-date-picker__time-header{position:relative;border-bottom:1px solid var(--ep-datepicker-inner-border-color);font-size:12px;padding:8px 5px 5px;display:table;width:100%;box-sizing:border-box}.ep-date-picker__header{margin:12px;text-align:center}.ep-date-picker__header--bordered{margin-bottom:0;padding-bottom:12px;border-bottom:solid 1px var(--ep-border-color-lighter)}.ep-date-picker__header--bordered+.ep-picker-panel__content{margin-top:0}.ep-date-picker__header-label{font-size:16px;font-weight:500;padding:0 5px;line-height:22px;text-align:center;cursor:pointer;color:var(--ep-text-color-regular)}.ep-date-picker__header-label:hover{color:var(--ep-datepicker-hover-text-color)}.ep-date-picker__header-label:focus-visible{outline:none;color:var(--ep-datepicker-hover-text-color)}.ep-date-picker__header-label.active{color:var(--ep-datepicker-active-color)}.ep-date-picker__prev-btn{float:left}.ep-date-picker__next-btn{float:right}.ep-date-picker__time-wrap{padding:10px;text-align:center}.ep-date-picker__time-label{float:left;cursor:pointer;line-height:30px;margin-left:10px}.ep-date-picker .ep-time-panel{position:absolute}.ep-date-range-picker{--ep-datepicker-text-color: var(--ep-text-color-regular);--ep-datepicker-off-text-color: var(--ep-text-color-placeholder);--ep-datepicker-header-text-color: var(--ep-text-color-regular);--ep-datepicker-icon-color: var(--ep-text-color-primary);--ep-datepicker-border-color: var(--ep-disabled-border-color);--ep-datepicker-inner-border-color: var(--ep-border-color-light);--ep-datepicker-inrange-bg-color: var(--ep-border-color-extra-light);--ep-datepicker-inrange-hover-bg-color: var(--ep-border-color-extra-light);--ep-datepicker-active-color: var(--ep-color-primary);--ep-datepicker-hover-text-color: var(--ep-color-primary)}.ep-date-range-picker{width:646px}.ep-date-range-picker.has-sidebar{width:756px}.ep-date-range-picker table{table-layout:fixed;width:100%}.ep-date-range-picker .ep-picker-panel__body{min-width:513px}.ep-date-range-picker .ep-picker-panel__content{margin:0}.ep-date-range-picker__header{position:relative;text-align:center;height:28px}.ep-date-range-picker__header [class*=arrow-left]{float:left}.ep-date-range-picker__header [class*=arrow-right]{float:right}.ep-date-range-picker__header div{font-size:16px;font-weight:500;margin-right:50px}.ep-date-range-picker__content{float:left;width:50%;box-sizing:border-box;margin:0;padding:16px}.ep-date-range-picker__content.is-left{border-right:1px solid var(--ep-datepicker-inner-border-color)}.ep-date-range-picker__content .ep-date-range-picker__header div{margin-left:50px;margin-right:50px}.ep-date-range-picker__editors-wrap{box-sizing:border-box;display:table-cell}.ep-date-range-picker__editors-wrap.is-right{text-align:right}.ep-date-range-picker__time-header{position:relative;border-bottom:1px solid var(--ep-datepicker-inner-border-color);font-size:12px;padding:8px 5px 5px;display:table;width:100%;box-sizing:border-box}.ep-date-range-picker__time-header>.ep-icon-arrow-right{font-size:20px;vertical-align:middle;display:table-cell;color:var(--ep-datepicker-icon-color)}.ep-date-range-picker__time-picker-wrap{position:relative;display:table-cell;padding:0 5px}.ep-date-range-picker__time-picker-wrap .ep-picker-panel{position:absolute;top:13px;right:0;z-index:1;background:#ffffff}.ep-date-range-picker__time-picker-wrap .ep-time-panel{position:absolute}.ep-time-range-picker{width:354px;overflow:visible}.ep-time-range-picker__content{position:relative;text-align:center;padding:10px;z-index:1}.ep-time-range-picker__cell{box-sizing:border-box;margin:0;padding:4px 7px 7px;width:50%;display:inline-block}.ep-time-range-picker__header{margin-bottom:5px;text-align:center;font-size:14px}.ep-time-range-picker__body{border-radius:2px;border:1px solid var(--ep-datepicker-border-color)}.ep-time-panel{border-radius:2px;position:relative;width:180px;left:0;z-index:var(--ep-index-top);user-select:none;box-sizing:content-box}.ep-time-panel__content{font-size:0;position:relative;overflow:hidden}.ep-time-panel__content:after,.ep-time-panel__content:before{content:"";top:50%;position:absolute;margin-top:-16px;height:32px;z-index:-1;left:0;right:0;box-sizing:border-box;padding-top:6px;text-align:left}.ep-time-panel__content:after{left:50%;margin-left:12%;margin-right:12%}.ep-time-panel__content:before{padding-left:50%;margin-right:12%;margin-left:12%;border-top:1px solid var(--ep-border-color-light);border-bottom:1px solid var(--ep-border-color-light)}.ep-time-panel__content.has-seconds:after{left:66.6666666667%}.ep-time-panel__content.has-seconds:before{padding-left:33.3333333333%}.ep-time-panel__footer{border-top:1px solid var(--ep-timepicker-inner-border-color, var(--ep-border-color-light));padding:4px;height:36px;line-height:25px;text-align:right;box-sizing:border-box}.ep-time-panel__btn{border:none;line-height:28px;padding:0 5px;margin:0 5px;cursor:pointer;background-color:transparent;outline:none;font-size:12px;color:var(--ep-text-color-primary)}.ep-time-panel__btn.confirm{font-weight:800;color:var(--ep-timepicker-active-color, var(--ep-color-primary))}\n')();
var input = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}.ep-textarea{--ep-input-text-color: var(--ep-text-color-regular);--ep-input-border: var(--ep-border);--ep-input-hover-border: var(--ep-border-color-hover);--ep-input-focus-border: var(--ep-color-primary);--ep-input-transparent-border: 0 0 0 1px transparent inset;--ep-input-border-color: var(--ep-border-color);--ep-input-border-radius: var(--ep-border-radius-base);--ep-input-bg-color: var(--ep-fill-color-blank);--ep-input-icon-color: var(--ep-text-color-placeholder);--ep-input-placeholder-color: var(--ep-text-color-placeholder);--ep-input-hover-border-color: var(--ep-border-color-hover);--ep-input-clear-hover-color: var(--ep-text-color-secondary);--ep-input-focus-border-color: var(--ep-color-primary)}.ep-textarea{position:relative;display:inline-block;width:100%;vertical-align:bottom;font-size:var(--ep-font-size-base)}.ep-textarea__inner{position:relative;display:block;resize:vertical;padding:5px 11px;line-height:1.5;box-sizing:border-box;width:100%;font-size:inherit;font-family:inherit;color:var(--ep-input-text-color, var(--ep-text-color-regular));background-color:var(--ep-input-bg-color, var(--ep-fill-color-blank));background-image:none;-webkit-appearance:none;box-shadow:0 0 0 1px var(--ep-input-border-color, var(--ep-border-color)) inset;border-radius:var(--ep-input-border-radius, var(--ep-border-radius-base));transition:var(--ep-transition-box-shadow);border:none}.ep-textarea__inner::placeholder{color:var(--ep-input-placeholder-color, var(--ep-text-color-placeholder))}.ep-textarea__inner:hover{box-shadow:0 0 0 1px var(--ep-input-hover-border-color) inset}.ep-textarea__inner:focus{outline:none;box-shadow:0 0 0 1px var(--ep-input-focus-border-color) inset}.ep-textarea .ep-input__count{color:var(--ep-color-info);background:var(--ep-fill-color-blank);position:absolute;font-size:12px;line-height:14px;bottom:5px;right:10px}.ep-textarea.is-disabled .ep-textarea__inner{background-color:var(--ep-disabled-bg-color);border-color:var(--ep-disabled-border-color);color:var(--ep-disabled-text-color);cursor:not-allowed}.ep-textarea.is-disabled .ep-textarea__inner::placeholder{color:var(--ep-text-color-placeholder)}.ep-textarea.is-exceed .ep-textarea__inner{border-color:var(--ep-color-danger)}.ep-textarea.is-exceed .ep-input__count{color:var(--ep-color-danger)}.ep-input{--ep-input-text-color: var(--ep-text-color-regular);--ep-input-border: var(--ep-border);--ep-input-hover-border: var(--ep-border-color-hover);--ep-input-focus-border: var(--ep-color-primary);--ep-input-transparent-border: 0 0 0 1px transparent inset;--ep-input-border-color: var(--ep-border-color);--ep-input-border-radius: var(--ep-border-radius-base);--ep-input-bg-color: var(--ep-fill-color-blank);--ep-input-icon-color: var(--ep-text-color-placeholder);--ep-input-placeholder-color: var(--ep-text-color-placeholder);--ep-input-hover-border-color: var(--ep-border-color-hover);--ep-input-clear-hover-color: var(--ep-text-color-secondary);--ep-input-focus-border-color: var(--ep-color-primary)}.ep-input{--ep-input-height: var(--ep-component-size);position:relative;font-size:var(--ep-font-size-base);display:inline-flex;width:100%;line-height:var(--ep-input-height);box-sizing:border-box}.ep-input::-webkit-scrollbar{z-index:11;width:6px}.ep-input::-webkit-scrollbar:horizontal{height:6px}.ep-input::-webkit-scrollbar-thumb{border-radius:5px;width:6px;background:var(--ep-text-color-disabled)}.ep-input::-webkit-scrollbar-corner{background:var(--ep-fill-color-blank)}.ep-input::-webkit-scrollbar-track{background:var(--ep-fill-color-blank)}.ep-input::-webkit-scrollbar-track-piece{background:var(--ep-fill-color-blank);width:6px}.ep-input .ep-input__clear,.ep-input .ep-input__password{color:var(--ep-input-icon-color);font-size:14px;cursor:pointer}.ep-input .ep-input__clear:hover,.ep-input .ep-input__password:hover{color:var(--ep-input-clear-hover-color)}.ep-input .ep-input__count{height:100%;display:inline-flex;align-items:center;color:var(--ep-color-info);font-size:12px}.ep-input .ep-input__count .ep-input__count-inner{background:var(--ep-fill-color-blank);line-height:initial;display:inline-block;padding-left:8px}.ep-input__wrapper{display:inline-flex;flex-grow:1;align-items:center;justify-content:center;padding:1px 11px;background-color:var(--ep-input-bg-color, var(--ep-fill-color-blank));background-image:none;border-radius:var(--ep-input-border-radius, var(--ep-border-radius-base));transition:var(--ep-transition-box-shadow);box-shadow:0 0 0 1px var(--ep-input-border-color, var(--ep-border-color)) inset}.ep-input__wrapper:hover{box-shadow:0 0 0 1px var(--ep-input-hover-border-color) inset}.ep-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--ep-input-focus-border-color) inset}.ep-input__inner{--ep-input-inner-height: calc(var(--ep-input-height, 32px) - 2px);width:100%;flex-grow:1;-webkit-appearance:none;color:var(--ep-input-text-color, var(--ep-text-color-regular));font-size:inherit;height:var(--ep-input-inner-height);line-height:var(--ep-input-inner-height);padding:0;outline:none;border:none;background:none;box-sizing:border-box}.ep-input__inner:focus{outline:none}.ep-input__inner::placeholder{color:var(--ep-input-placeholder-color, var(--ep-text-color-placeholder))}.ep-input__inner[type=password]::-ms-reveal{display:none}.ep-input__prefix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--ep-input-icon-color, var(--ep-text-color-placeholder));transition:all var(--ep-transition-duration);pointer-events:none}.ep-input__prefix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.ep-input__prefix-inner>:last-child{margin-right:8px}.ep-input__prefix-inner>:first-child,.ep-input__prefix-inner>:first-child.ep-input__icon{margin-left:0}.ep-input__suffix{display:inline-flex;white-space:nowrap;flex-shrink:0;flex-wrap:nowrap;height:100%;text-align:center;color:var(--ep-input-icon-color, var(--ep-text-color-placeholder));transition:all var(--ep-transition-duration);pointer-events:none}.ep-input__suffix-inner{pointer-events:all;display:inline-flex;align-items:center;justify-content:center}.ep-input__suffix-inner>:first-child{margin-left:8px}.ep-input .ep-input__icon{height:inherit;line-height:inherit;display:flex;justify-content:center;align-items:center;transition:all var(--ep-transition-duration);margin-left:8px}.ep-input__validateIcon{pointer-events:none}.ep-input.is-active .ep-input__wrapper{box-shadow:0 0 0 1px var(--ep-input-focus-color, ) inset}.ep-input.is-disabled{cursor:not-allowed}.ep-input.is-disabled .ep-input__wrapper{background-color:var(--ep-disabled-bg-color);box-shadow:0 0 0 1px var(--ep-disabled-border-color) inset}.ep-input.is-disabled .ep-input__inner{color:var(--ep-disabled-text-color);cursor:not-allowed}.ep-input.is-disabled .ep-input__inner::placeholder{color:var(--ep-text-color-placeholder)}.ep-input.is-disabled .ep-input__icon{cursor:not-allowed}.ep-input.is-exceed .ep-input__wrapper{box-shadow:0 0 0 1px var(--ep-color-danger) inset}.ep-input.is-exceed .ep-input__suffix .ep-input__count{color:var(--ep-color-danger)}.ep-input--large{--ep-input-height: var(--ep-component-size-large);font-size:14px}.ep-input--large .ep-input__wrapper{padding:1px 15px}.ep-input--large .ep-input__inner{--ep-input-inner-height: calc(var(--ep-input-height, 40px) - 2px)}.ep-input--small{--ep-input-height: var(--ep-component-size-small);font-size:12px}.ep-input--small .ep-input__wrapper{padding:1px 7px}.ep-input--small .ep-input__inner{--ep-input-inner-height: calc(var(--ep-input-height, 24px) - 2px)}.ep-input-group{display:inline-flex;width:100%;align-items:stretch}.ep-input-group__append,.ep-input-group__prepend{background-color:var(--ep-fill-color-light);color:var(--ep-color-info);position:relative;display:inline-flex;align-items:center;justify-content:center;min-height:100%;border-radius:var(--ep-input-border-radius);padding:0 20px;white-space:nowrap}.ep-input-group__append:focus,.ep-input-group__prepend:focus{outline:none}.ep-input-group__append .ep-select,.ep-input-group__append .ep-button,.ep-input-group__prepend .ep-select,.ep-input-group__prepend .ep-button{display:inline-block;margin:0 -20px}.ep-input-group__append button.ep-button,.ep-input-group__append button.ep-button:hover,.ep-input-group__append div.ep-select .ep-input__wrapper,.ep-input-group__append div.ep-select:hover .ep-input__wrapper,.ep-input-group__prepend button.ep-button,.ep-input-group__prepend button.ep-button:hover,.ep-input-group__prepend div.ep-select .ep-input__wrapper,.ep-input-group__prepend div.ep-select:hover .ep-input__wrapper{border-color:transparent;background-color:transparent;color:inherit}.ep-input-group__append .ep-button,.ep-input-group__append .ep-input,.ep-input-group__prepend .ep-button,.ep-input-group__prepend .ep-input{font-size:inherit}.ep-input-group__prepend{border-right:0;border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--ep-input-border-color) inset,0 1px 0 0 var(--ep-input-border-color) inset,0 -1px 0 0 var(--ep-input-border-color) inset}.ep-input-group__append{border-left:0;border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--ep-input-border-color) inset,0 -1px 0 0 var(--ep-input-border-color) inset,-1px 0 0 0 var(--ep-input-border-color) inset}.ep-input-group--prepend>.ep-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0}.ep-input-group--prepend .ep-input-group__prepend .ep-select .ep-input .ep-input__inner{box-shadow:none!important}.ep-input-group--prepend .ep-input-group__prepend .ep-select .ep-input .ep-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0;box-shadow:1px 0 0 0 var(--ep-input-border-color) inset,0 1px 0 0 var(--ep-input-border-color) inset,0 -1px 0 0 var(--ep-input-border-color) inset}.ep-input-group--prepend .ep-input-group__prepend .ep-select .ep-input.is-focus .ep-input__inner{box-shadow:none!important}.ep-input-group--prepend .ep-input-group__prepend .ep-select .ep-input.is-focus .ep-input__wrapper{box-shadow:1px 0 0 0 var(--ep-input-focus-border-color) inset,1px 0 0 0 var(--ep-input-focus-border-color),0 1px 0 0 var(--ep-input-focus-border-color) inset,0 -1px 0 0 var(--ep-input-focus-border-color) inset!important;z-index:2}.ep-input-group--prepend .ep-input-group__prepend .ep-select .ep-input.is-focus .ep-input__wrapper:focus{outline:none;z-index:2;box-shadow:1px 0 0 0 var(--ep-input-focus-border-color) inset,1px 0 0 0 var(--ep-input-focus-border-color),0 1px 0 0 var(--ep-input-focus-border-color) inset,0 -1px 0 0 var(--ep-input-focus-border-color) inset!important}.ep-input-group--prepend .ep-input-group__prepend .ep-select:hover .ep-input__inner{box-shadow:none!important}.ep-input-group--prepend .ep-input-group__prepend .ep-select:hover .ep-input__wrapper{z-index:1;box-shadow:1px 0 0 0 var(--ep-input-hover-border-color) inset,1px 0 0 0 var(--ep-input-hover-border-color),0 1px 0 0 var(--ep-input-hover-border-color) inset,0 -1px 0 0 var(--ep-input-hover-border-color) inset!important}.ep-input-group--append>.ep-input__wrapper{border-top-right-radius:0;border-bottom-right-radius:0}.ep-input-group--append .ep-input-group__append .ep-select .ep-input .ep-input__inner{box-shadow:none!important}.ep-input-group--append .ep-input-group__append .ep-select .ep-input .ep-input__wrapper{border-top-left-radius:0;border-bottom-left-radius:0;box-shadow:0 1px 0 0 var(--ep-input-border-color) inset,0 -1px 0 0 var(--ep-input-border-color) inset,-1px 0 0 0 var(--ep-input-border-color) inset}.ep-input-group--append .ep-input-group__append .ep-select .ep-input.is-focus .ep-input__inner{box-shadow:none!important}.ep-input-group--append .ep-input-group__append .ep-select .ep-input.is-focus .ep-input__wrapper{z-index:2;box-shadow:-1px 0 0 0 var(--ep-input-focus-border-color),-1px 0 0 0 var(--ep-input-focus-border-color) inset,0 1px 0 0 var(--ep-input-focus-border-color) inset,0 -1px 0 0 var(--ep-input-focus-border-color) inset!important}.ep-input-group--append .ep-input-group__append .ep-select:hover .ep-input__inner{box-shadow:none!important}.ep-input-group--append .ep-input-group__append .ep-select:hover .ep-input__wrapper{z-index:1;box-shadow:-1px 0 0 0 var(--ep-input-hover-border-color),-1px 0 0 0 var(--ep-input-hover-border-color) inset,0 1px 0 0 var(--ep-input-hover-border-color) inset,0 -1px 0 0 var(--ep-input-hover-border-color) inset!important}\n")();
var scrollbar = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}.ep-scrollbar{--ep-scrollbar-opacity: .3;--ep-scrollbar-bg-color: var(--ep-text-color-secondary);--ep-scrollbar-hover-opacity: .5;--ep-scrollbar-hover-bg-color: var(--ep-text-color-secondary)}.ep-scrollbar{overflow:hidden;position:relative;height:100%}.ep-scrollbar__wrap{overflow:auto;height:100%}.ep-scrollbar__wrap--hidden-default{scrollbar-width:none}.ep-scrollbar__wrap--hidden-default::-webkit-scrollbar{display:none}.ep-scrollbar__thumb{position:relative;display:block;width:0;height:0;cursor:pointer;border-radius:inherit;background-color:var(--ep-scrollbar-bg-color, var(--ep-text-color-secondary));transition:var(--ep-transition-duration) background-color;opacity:var(--ep-scrollbar-opacity, .3)}.ep-scrollbar__thumb:hover{background-color:var(--ep-scrollbar-hover-bg-color, var(--ep-text-color-secondary));opacity:var(--ep-scrollbar-hover-opacity, .5)}.ep-scrollbar__bar{position:absolute;right:2px;bottom:2px;z-index:1;border-radius:4px}.ep-scrollbar__bar.is-vertical{width:6px;top:2px}.ep-scrollbar__bar.is-vertical>div{width:100%}.ep-scrollbar__bar.is-horizontal{height:6px;left:2px}.ep-scrollbar__bar.is-horizontal>div{height:100%}.ep-scrollbar-fade-enter-active{transition:opacity .34s ease-out}.ep-scrollbar-fade-leave-active{transition:opacity .12s ease-out}.ep-scrollbar-fade-enter-from,.ep-scrollbar-fade-leave-active{opacity:0}\n")();
var popper = /* @__PURE__ */ (() => 'html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}.ep-popper{--ep-popper-border-radius: var(--ep-popover-border-radius, 4px)}.ep-popper{position:absolute;border-radius:var(--ep-popper-border-radius);padding:5px 11px;z-index:2000;font-size:12px;line-height:20px;min-width:10px;word-wrap:break-word;visibility:visible}.ep-popper.is-dark{color:var(--ep-bg-color);background:var(--ep-text-color-primary);border:1px solid var(--ep-text-color-primary)}.ep-popper.is-dark .ep-popper__arrow:before{border:1px solid var(--ep-text-color-primary);background:var(--ep-text-color-primary);right:0}.ep-popper.is-light{background:var(--ep-bg-color-overlay);border:1px solid var(--ep-border-color-light)}.ep-popper.is-light .ep-popper__arrow:before{border:1px solid var(--ep-border-color-light);background:var(--ep-bg-color-overlay);right:0}.ep-popper.is-pure{padding:0}.ep-popper__arrow{position:absolute;width:10px;height:10px;z-index:-1}.ep-popper__arrow:before{position:absolute;width:10px;height:10px;z-index:-1;content:" ";transform:rotate(45deg);background:var(--ep-text-color-primary);box-sizing:border-box}.ep-popper[data-popper-placement^=top]>.ep-popper__arrow{bottom:-5px}.ep-popper[data-popper-placement^=top]>.ep-popper__arrow:before{border-bottom-right-radius:2px}.ep-popper[data-popper-placement^=bottom]>.ep-popper__arrow{top:-5px}.ep-popper[data-popper-placement^=bottom]>.ep-popper__arrow:before{border-top-left-radius:2px}.ep-popper[data-popper-placement^=left]>.ep-popper__arrow{right:-5px}.ep-popper[data-popper-placement^=left]>.ep-popper__arrow:before{border-top-right-radius:2px}.ep-popper[data-popper-placement^=right]>.ep-popper__arrow{left:-5px}.ep-popper[data-popper-placement^=right]>.ep-popper__arrow:before{border-bottom-left-radius:2px}.ep-popper[data-popper-placement^=top] .ep-popper__arrow:before{border-top-color:transparent!important;border-left-color:transparent!important}.ep-popper[data-popper-placement^=bottom] .ep-popper__arrow:before{border-bottom-color:transparent!important;border-right-color:transparent!important}.ep-popper[data-popper-placement^=left] .ep-popper__arrow:before{border-left-color:transparent!important;border-bottom-color:transparent!important}.ep-popper[data-popper-placement^=right] .ep-popper__arrow:before{border-right-color:transparent!important;border-top-color:transparent!important}\n')();
var button = /* @__PURE__ */ (() => 'html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}.ep-button{--ep-button-font-weight: var(--ep-font-weight-primary);--ep-button-border-color: var(--ep-border-color);--ep-button-bg-color: var(--ep-fill-color-blank);--ep-button-text-color: var(--ep-text-color-regular);--ep-button-disabled-text-color: var(--ep-disabled-text-color);--ep-button-disabled-bg-color: var(--ep-fill-color-blank);--ep-button-disabled-border-color: var(--ep-border-color-light);--ep-button-divide-border-color: rgba(255, 255, 255, .5);--ep-button-hover-text-color: var(--ep-color-primary);--ep-button-hover-bg-color: var(--ep-color-primary-light-9);--ep-button-hover-border-color: var(--ep-color-primary-light-7);--ep-button-active-text-color: var(--ep-button-hover-text-color);--ep-button-active-border-color: var(--ep-color-primary);--ep-button-active-bg-color: var(--ep-button-hover-bg-color)}.ep-button{display:inline-flex;justify-content:center;align-items:center;line-height:1;height:32px;white-space:nowrap;cursor:pointer;color:var(--ep-button-text-color);text-align:center;box-sizing:border-box;outline:none;transition:.1s;font-weight:var(--ep-button-font-weight);user-select:none;vertical-align:middle;-webkit-appearance:none;background-color:var(--ep-button-bg-color);border:var(--ep-border);border-color:var(--ep-button-border-color);padding:8px 49px;font-size:var(--ep-font-size-base);border-radius:var(--ep-border-radius-base)}.ep-button:hover,.ep-button:focus{color:var(--ep-button-hover-text-color);border-color:var(--ep-button-hover-border-color);background-color:var(--ep-button-hover-bg-color);outline:none}.ep-button:active{color:var(--ep-button-active-text-color);border-color:var(--ep-button-active-border-color);background-color:var(--ep-button-active-bg-color);outline:none}.ep-button:focus-visible{border-color:transparent;outline:2px solid var(--ep-button-border-color);outline-offset:1px}.ep-button>span{display:inline-flex;align-items:center}.ep-button+.ep-button{margin-left:12px}.ep-button.is-round{padding:8px 49px}.ep-button::-moz-focus-inner{border:0}.ep-button [class*=ep-icon]+span{margin-left:6px}.ep-button [class*=ep-icon] svg{vertical-align:bottom}.ep-button.is-plain{--ep-button-hover-text-color: var(--ep-color-primary);--ep-button-hover-bg-color: var(--ep-fill-color-blank);--ep-button-hover-border-color: var(--ep-color-primary)}.ep-button.is-active{color:var(--ep-button-active-text-color);border-color:var(--ep-button-active-border-color);background-color:var(--ep-button-active-bg-color);outline:none}.ep-button.is-disabled,.ep-button.is-disabled:hover,.ep-button.is-disabled:focus{color:var(--ep-button-disabled-text-color);cursor:not-allowed;background-image:none;background-color:var(--ep-button-disabled-bg-color);border-color:var(--ep-button-disabled-border-color)}.ep-button.is-loading{position:relative;pointer-events:none}.ep-button.is-loading:before{z-index:1;pointer-events:none;content:"";position:absolute;left:-1px;top:-1px;right:-1px;bottom:-1px;border-radius:inherit;background-color:var(--ep-mask-color-extra-light)}.ep-button.is-round{border-radius:var(--ep-border-radius-round)}.ep-button.is-circle{border-radius:50%;padding:8px}.ep-button.is-text{color:var(--ep-button-text-color);border:0 solid transparent;background-color:transparent}.ep-button.is-text.is-disabled{color:var(--ep-button-disabled-text-color);background-color:transparent!important}.ep-button.is-text:not(.is-disabled):hover,.ep-button.is-text:not(.is-disabled):focus{background-color:var(--ep-fill-color-light)}.ep-button.is-text:not(.is-disabled):focus-visible{border-color:transparent;outline:2px solid var(--ep-button-border-color);outline-offset:1px}.ep-button.is-text:not(.is-disabled):active{background-color:var(--ep-fill-color)}.ep-button.is-text:not(.is-disabled).is-has-bg{background-color:var(--ep-fill-color-light)}.ep-button.is-text:not(.is-disabled).is-has-bg:hover{background-color:var(--ep-fill-color)}.ep-button.is-text:not(.is-disabled).is-has-bg:active{background-color:var(--ep-fill-color-dark)}.ep-button__text--expand{letter-spacing:.3em;margin-right:-.3em}.ep-button.is-link{border-color:transparent;color:var(--ep-button-text-color);background:transparent;padding-left:0;padding-right:0;outline:0;outline-offset:0}.ep-button.is-link:hover{color:var(--ep-button-hover-link-text-color)}.ep-button.is-link.is-disabled{color:var(--ep-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.ep-button.is-link:not(.is-disabled):hover,.ep-button.is-link:not(.is-disabled):focus{border-color:transparent;background-color:transparent}.ep-button.is-link:not(.is-disabled):active{border-color:transparent;background-color:transparent}.ep-button--text{border-color:transparent;background:transparent;color:var(--ep-color-primary);padding-left:0;padding-right:0}.ep-button--text.is-disabled{color:var(--ep-button-disabled-text-color);background-color:transparent!important;border-color:transparent!important}.ep-button--text:not(.is-disabled):hover,.ep-button--text:not(.is-disabled):focus{color:var(--ep-color-primary-light-3);border-color:transparent;background-color:transparent}.ep-button--text:not(.is-disabled):active{color:var(--ep-color-primary-dark-2);border-color:transparent;background-color:transparent}.ep-button__link--expand{letter-spacing:.3em;margin-right:-.3em}.ep-button--primary{--ep-button-text-color: var(--ep-color-white);--ep-button-bg-color: var(--ep-color-primary);--ep-button-border-color: var(--ep-color-primary);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-link-text-color: var(--ep-color-primary-light-5);--ep-button-hover-bg-color: var(--ep-color-primary-light-3);--ep-button-hover-border-color: var(--ep-color-primary-light-3);--ep-button-active-bg-color: var(--ep-color-primary-dark-2);--ep-button-active-border-color: var(--ep-color-primary-dark-2);--ep-button-disabled-text-color: var(--ep-color-white);--ep-button-disabled-bg-color: var(--ep-color-primary-light-5);--ep-button-disabled-border-color: var(--ep-color-primary-light-5)}.ep-button--primary.is-plain,.ep-button--primary.is-text,.ep-button--primary.is-link{--ep-button-text-color: var(--ep-color-primary);--ep-button-bg-color: var(--ep-color-primary-light-9);--ep-button-border-color: var(--ep-color-primary-light-5);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-bg-color: var(--ep-color-primary);--ep-button-hover-border-color: var(--ep-color-primary);--ep-button-active-text-color: var(--ep-color-white)}.ep-button--primary.is-plain.is-disabled,.ep-button--primary.is-plain.is-disabled:hover,.ep-button--primary.is-plain.is-disabled:focus,.ep-button--primary.is-plain.is-disabled:active,.ep-button--primary.is-text.is-disabled,.ep-button--primary.is-text.is-disabled:hover,.ep-button--primary.is-text.is-disabled:focus,.ep-button--primary.is-text.is-disabled:active,.ep-button--primary.is-link.is-disabled,.ep-button--primary.is-link.is-disabled:hover,.ep-button--primary.is-link.is-disabled:focus,.ep-button--primary.is-link.is-disabled:active{color:var(--ep-color-primary-light-5);background-color:var(--ep-color-primary-light-9);border-color:var(--ep-color-primary-light-8)}.ep-button--success{--ep-button-text-color: var(--ep-color-white);--ep-button-bg-color: var(--ep-color-success);--ep-button-border-color: var(--ep-color-success);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-link-text-color: var(--ep-color-success-light-5);--ep-button-hover-bg-color: var(--ep-color-success-light-3);--ep-button-hover-border-color: var(--ep-color-success-light-3);--ep-button-active-bg-color: var(--ep-color-success-dark-2);--ep-button-active-border-color: var(--ep-color-success-dark-2);--ep-button-disabled-text-color: var(--ep-color-white);--ep-button-disabled-bg-color: var(--ep-color-success-light-5);--ep-button-disabled-border-color: var(--ep-color-success-light-5)}.ep-button--success.is-plain,.ep-button--success.is-text,.ep-button--success.is-link{--ep-button-text-color: var(--ep-color-success);--ep-button-bg-color: var(--ep-color-success-light-9);--ep-button-border-color: var(--ep-color-success-light-5);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-bg-color: var(--ep-color-success);--ep-button-hover-border-color: var(--ep-color-success);--ep-button-active-text-color: var(--ep-color-white)}.ep-button--success.is-plain.is-disabled,.ep-button--success.is-plain.is-disabled:hover,.ep-button--success.is-plain.is-disabled:focus,.ep-button--success.is-plain.is-disabled:active,.ep-button--success.is-text.is-disabled,.ep-button--success.is-text.is-disabled:hover,.ep-button--success.is-text.is-disabled:focus,.ep-button--success.is-text.is-disabled:active,.ep-button--success.is-link.is-disabled,.ep-button--success.is-link.is-disabled:hover,.ep-button--success.is-link.is-disabled:focus,.ep-button--success.is-link.is-disabled:active{color:var(--ep-color-success-light-5);background-color:var(--ep-color-success-light-9);border-color:var(--ep-color-success-light-8)}.ep-button--warning{--ep-button-text-color: var(--ep-color-white);--ep-button-bg-color: var(--ep-color-warning);--ep-button-border-color: var(--ep-color-warning);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-link-text-color: var(--ep-color-warning-light-5);--ep-button-hover-bg-color: var(--ep-color-warning-light-3);--ep-button-hover-border-color: var(--ep-color-warning-light-3);--ep-button-active-bg-color: var(--ep-color-warning-dark-2);--ep-button-active-border-color: var(--ep-color-warning-dark-2);--ep-button-disabled-text-color: var(--ep-color-white);--ep-button-disabled-bg-color: var(--ep-color-warning-light-5);--ep-button-disabled-border-color: var(--ep-color-warning-light-5)}.ep-button--warning.is-plain,.ep-button--warning.is-text,.ep-button--warning.is-link{--ep-button-text-color: var(--ep-color-warning);--ep-button-bg-color: var(--ep-color-warning-light-9);--ep-button-border-color: var(--ep-color-warning-light-5);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-bg-color: var(--ep-color-warning);--ep-button-hover-border-color: var(--ep-color-warning);--ep-button-active-text-color: var(--ep-color-white)}.ep-button--warning.is-plain.is-disabled,.ep-button--warning.is-plain.is-disabled:hover,.ep-button--warning.is-plain.is-disabled:focus,.ep-button--warning.is-plain.is-disabled:active,.ep-button--warning.is-text.is-disabled,.ep-button--warning.is-text.is-disabled:hover,.ep-button--warning.is-text.is-disabled:focus,.ep-button--warning.is-text.is-disabled:active,.ep-button--warning.is-link.is-disabled,.ep-button--warning.is-link.is-disabled:hover,.ep-button--warning.is-link.is-disabled:focus,.ep-button--warning.is-link.is-disabled:active{color:var(--ep-color-warning-light-5);background-color:var(--ep-color-warning-light-9);border-color:var(--ep-color-warning-light-8)}.ep-button--danger{--ep-button-text-color: var(--ep-color-white);--ep-button-bg-color: var(--ep-color-danger);--ep-button-border-color: var(--ep-color-danger);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-link-text-color: var(--ep-color-danger-light-5);--ep-button-hover-bg-color: var(--ep-color-danger-light-3);--ep-button-hover-border-color: var(--ep-color-danger-light-3);--ep-button-active-bg-color: var(--ep-color-danger-dark-2);--ep-button-active-border-color: var(--ep-color-danger-dark-2);--ep-button-disabled-text-color: var(--ep-color-white);--ep-button-disabled-bg-color: var(--ep-color-danger-light-5);--ep-button-disabled-border-color: var(--ep-color-danger-light-5)}.ep-button--danger.is-plain,.ep-button--danger.is-text,.ep-button--danger.is-link{--ep-button-text-color: var(--ep-color-danger);--ep-button-bg-color: var(--ep-color-danger-light-9);--ep-button-border-color: var(--ep-color-danger-light-5);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-bg-color: var(--ep-color-danger);--ep-button-hover-border-color: var(--ep-color-danger);--ep-button-active-text-color: var(--ep-color-white)}.ep-button--danger.is-plain.is-disabled,.ep-button--danger.is-plain.is-disabled:hover,.ep-button--danger.is-plain.is-disabled:focus,.ep-button--danger.is-plain.is-disabled:active,.ep-button--danger.is-text.is-disabled,.ep-button--danger.is-text.is-disabled:hover,.ep-button--danger.is-text.is-disabled:focus,.ep-button--danger.is-text.is-disabled:active,.ep-button--danger.is-link.is-disabled,.ep-button--danger.is-link.is-disabled:hover,.ep-button--danger.is-link.is-disabled:focus,.ep-button--danger.is-link.is-disabled:active{color:var(--ep-color-danger-light-5);background-color:var(--ep-color-danger-light-9);border-color:var(--ep-color-danger-light-8)}.ep-button--info{--ep-button-text-color: var(--ep-color-white);--ep-button-bg-color: var(--ep-color-info);--ep-button-border-color: var(--ep-color-info);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-link-text-color: var(--ep-color-info-light-5);--ep-button-hover-bg-color: var(--ep-color-info-light-3);--ep-button-hover-border-color: var(--ep-color-info-light-3);--ep-button-active-bg-color: var(--ep-color-info-dark-2);--ep-button-active-border-color: var(--ep-color-info-dark-2);--ep-button-disabled-text-color: var(--ep-color-white);--ep-button-disabled-bg-color: var(--ep-color-info-light-5);--ep-button-disabled-border-color: var(--ep-color-info-light-5)}.ep-button--info.is-plain,.ep-button--info.is-text,.ep-button--info.is-link{--ep-button-text-color: var(--ep-color-info);--ep-button-bg-color: var(--ep-color-info-light-9);--ep-button-border-color: var(--ep-color-info-light-5);--ep-button-hover-text-color: var(--ep-color-white);--ep-button-hover-bg-color: var(--ep-color-info);--ep-button-hover-border-color: var(--ep-color-info);--ep-button-active-text-color: var(--ep-color-white)}.ep-button--info.is-plain.is-disabled,.ep-button--info.is-plain.is-disabled:hover,.ep-button--info.is-plain.is-disabled:focus,.ep-button--info.is-plain.is-disabled:active,.ep-button--info.is-text.is-disabled,.ep-button--info.is-text.is-disabled:hover,.ep-button--info.is-text.is-disabled:focus,.ep-button--info.is-text.is-disabled:active,.ep-button--info.is-link.is-disabled,.ep-button--info.is-link.is-disabled:hover,.ep-button--info.is-link.is-disabled:focus,.ep-button--info.is-link.is-disabled:active{color:var(--ep-color-info-light-5);background-color:var(--ep-color-info-light-9);border-color:var(--ep-color-info-light-8)}.ep-button--large{--ep-button-size: 40px;height:var(--ep-button-size);padding:12px 19px;font-size:var(--ep-font-size-base);border-radius:var(--ep-border-radius-base)}.ep-button--large [class*=ep-icon]+span{margin-left:8px}.ep-button--large.is-round{padding:12px 19px}.ep-button--large.is-circle{width:var(--ep-button-size);padding:12px}.ep-button--small{--ep-button-size: 24px;height:var(--ep-button-size);padding:5px 11px;font-size:12px;border-radius:calc(var(--ep-border-radius-base) - 1px)}.ep-button--small [class*=ep-icon]+span{margin-left:4px}.ep-button--small.is-round{padding:5px 11px}.ep-button--small.is-circle{width:var(--ep-button-size);padding:5px}\n')();
var tag = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}.ep-tag{--ep-tag-font-size: 12px;--ep-tag-border-radius: 4px;--ep-tag-border-radius-rounded: 9999px}.ep-tag{--ep-tag-bg-color: var(--ep-color-primary-light-9);--ep-tag-border-color: var(--ep-color-primary-light-8);--ep-tag-hover-color: var(--ep-color-primary);--ep-tag-text-color: var(--ep-color-primary);background-color:var(--ep-tag-bg-color);border-color:var(--ep-tag-border-color);color:var(--ep-tag-text-color);display:inline-flex;justify-content:center;align-items:center;height:24px;padding:0 9px;font-size:var(--ep-tag-font-size);line-height:1;border-width:1px;border-style:solid;border-radius:var(--ep-tag-border-radius);box-sizing:border-box;white-space:nowrap;--ep-icon-size: 14px}.ep-tag.ep-tag--primary{--ep-tag-bg-color: var(--ep-color-primary-light-9);--ep-tag-border-color: var(--ep-color-primary-light-8);--ep-tag-hover-color: var(--ep-color-primary)}.ep-tag.ep-tag--success{--ep-tag-bg-color: var(--ep-color-success-light-9);--ep-tag-border-color: var(--ep-color-success-light-8);--ep-tag-hover-color: var(--ep-color-success)}.ep-tag.ep-tag--warning{--ep-tag-bg-color: var(--ep-color-warning-light-9);--ep-tag-border-color: var(--ep-color-warning-light-8);--ep-tag-hover-color: var(--ep-color-warning)}.ep-tag.ep-tag--danger{--ep-tag-bg-color: var(--ep-color-danger-light-9);--ep-tag-border-color: var(--ep-color-danger-light-8);--ep-tag-hover-color: var(--ep-color-danger)}.ep-tag.ep-tag--error{--ep-tag-bg-color: var(--ep-color-error-light-9);--ep-tag-border-color: var(--ep-color-error-light-8);--ep-tag-hover-color: var(--ep-color-error)}.ep-tag.ep-tag--info{--ep-tag-bg-color: var(--ep-color-info-light-9);--ep-tag-border-color: var(--ep-color-info-light-8);--ep-tag-hover-color: var(--ep-color-info)}.ep-tag.ep-tag--primary{--ep-tag-text-color: var(--ep-color-primary)}.ep-tag.ep-tag--success{--ep-tag-text-color: var(--ep-color-success)}.ep-tag.ep-tag--warning{--ep-tag-text-color: var(--ep-color-warning)}.ep-tag.ep-tag--danger{--ep-tag-text-color: var(--ep-color-danger)}.ep-tag.ep-tag--error{--ep-tag-text-color: var(--ep-color-error)}.ep-tag.ep-tag--info{--ep-tag-text-color: var(--ep-color-info)}.ep-tag.is-hit{border-color:var(--ep-color-primary)}.ep-tag.is-round{border-radius:var(--ep-tag-border-radius-rounded)}.ep-tag .ep-tag__close{color:var(--ep-tag-text-color)}.ep-tag .ep-tag__close:hover{color:var(--ep-color-white);background-color:var(--ep-tag-hover-color)}.ep-tag .ep-icon{border-radius:50%;cursor:pointer;font-size:calc(var(--ep-icon-size) - 2px);height:var(--ep-icon-size);width:var(--ep-icon-size)}.ep-tag .ep-tag__close{margin-left:6px}.ep-tag--dark{--ep-tag-bg-color: var(--ep-color-primary);--ep-tag-border-color: var(--ep-color-primary);--ep-tag-hover-color: var(--ep-color-primary-light-3);--ep-tag-text-color: var(--ep-color-white)}.ep-tag--dark.ep-tag--primary{--ep-tag-bg-color: var(--ep-color-primary);--ep-tag-border-color: var(--ep-color-primary);--ep-tag-hover-color: var(--ep-color-primary-light-3)}.ep-tag--dark.ep-tag--success{--ep-tag-bg-color: var(--ep-color-success);--ep-tag-border-color: var(--ep-color-success);--ep-tag-hover-color: var(--ep-color-success-light-3)}.ep-tag--dark.ep-tag--warning{--ep-tag-bg-color: var(--ep-color-warning);--ep-tag-border-color: var(--ep-color-warning);--ep-tag-hover-color: var(--ep-color-warning-light-3)}.ep-tag--dark.ep-tag--danger{--ep-tag-bg-color: var(--ep-color-danger);--ep-tag-border-color: var(--ep-color-danger);--ep-tag-hover-color: var(--ep-color-danger-light-3)}.ep-tag--dark.ep-tag--error{--ep-tag-bg-color: var(--ep-color-error);--ep-tag-border-color: var(--ep-color-error);--ep-tag-hover-color: var(--ep-color-error-light-3)}.ep-tag--dark.ep-tag--info{--ep-tag-bg-color: var(--ep-color-info);--ep-tag-border-color: var(--ep-color-info);--ep-tag-hover-color: var(--ep-color-info-light-3)}.ep-tag--dark.ep-tag--primary,.ep-tag--dark.ep-tag--success,.ep-tag--dark.ep-tag--warning,.ep-tag--dark.ep-tag--danger,.ep-tag--dark.ep-tag--error,.ep-tag--dark.ep-tag--info{--ep-tag-text-color: var(--ep-color-white)}.ep-tag--plain{--ep-tag-border-color: var(--ep-color-primary-light-5);--ep-tag-hover-color: var(--ep-color-primary);--ep-tag-bg-color: var(--ep-fill-color-blank)}.ep-tag--plain.ep-tag--primary{--ep-tag-bg-color: var(--ep-fill-color-blank);--ep-tag-border-color: var(--ep-color-primary-light-5);--ep-tag-hover-color: var(--ep-color-primary)}.ep-tag--plain.ep-tag--success{--ep-tag-bg-color: var(--ep-fill-color-blank);--ep-tag-border-color: var(--ep-color-success-light-5);--ep-tag-hover-color: var(--ep-color-success)}.ep-tag--plain.ep-tag--warning{--ep-tag-bg-color: var(--ep-fill-color-blank);--ep-tag-border-color: var(--ep-color-warning-light-5);--ep-tag-hover-color: var(--ep-color-warning)}.ep-tag--plain.ep-tag--danger{--ep-tag-bg-color: var(--ep-fill-color-blank);--ep-tag-border-color: var(--ep-color-danger-light-5);--ep-tag-hover-color: var(--ep-color-danger)}.ep-tag--plain.ep-tag--error{--ep-tag-bg-color: var(--ep-fill-color-blank);--ep-tag-border-color: var(--ep-color-error-light-5);--ep-tag-hover-color: var(--ep-color-error)}.ep-tag--plain.ep-tag--info{--ep-tag-bg-color: var(--ep-fill-color-blank);--ep-tag-border-color: var(--ep-color-info-light-5);--ep-tag-hover-color: var(--ep-color-info)}.ep-tag.is-closable{padding-right:5px}.ep-tag--large{padding:0 11px;height:32px;--ep-icon-size: 16px}.ep-tag--large .ep-tag__close{margin-left:8px}.ep-tag--large.is-closable{padding-right:7px}.ep-tag--small{padding:0 7px;height:20px;--ep-icon-size: 12px}.ep-tag--small .ep-tag__close{margin-left:4px}.ep-tag--small.is-closable{padding-right:3px}.ep-tag--small .ep-icon-close{transform:scale(.8)}.ep-tag.ep-tag--primary.is-hit{border-color:var(--ep-color-primary)}.ep-tag.ep-tag--success.is-hit{border-color:var(--ep-color-success)}.ep-tag.ep-tag--warning.is-hit{border-color:var(--ep-color-warning)}.ep-tag.ep-tag--danger.is-hit{border-color:var(--ep-color-danger)}.ep-tag.ep-tag--error.is-hit{border-color:var(--ep-color-error)}.ep-tag.ep-tag--info.is-hit{border-color:var(--ep-color-info)}\n")();
var HelloWorld_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ".ep-button{margin:4px}\n")();
const _hoisted_1$5 = /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createTextVNode(" See "),
  /* @__PURE__ */ createBaseVNode("a", {
    href: "https://element-plus.org",
    target: "_blank"
  }, "element-plus"),
  /* @__PURE__ */ createTextVNode(" for more information. ")
], -1);
const _hoisted_2$5 = /* @__PURE__ */ createTextVNode("El Message");
const _hoisted_3$2 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
const _hoisted_4$2 = /* @__PURE__ */ createTextVNode("Tag 1");
const _hoisted_5$2 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
const _hoisted_6$2 = /* @__PURE__ */ createBaseVNode("p", null, "For example, we can custom primary color to 'green'.", -1);
const _hoisted_7$2 = /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createTextVNode(" Edit "),
  /* @__PURE__ */ createBaseVNode("code", null, "components/HelloWorld.vue"),
  /* @__PURE__ */ createTextVNode(" to test components. ")
], -1);
const _hoisted_8$2 = /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createTextVNode(" Edit "),
  /* @__PURE__ */ createBaseVNode("code", null, "styles/element/var.scss"),
  /* @__PURE__ */ createTextVNode(" to test scss variables. ")
], -1);
const _hoisted_9$2 = /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createTextVNode(" Full Example: "),
  /* @__PURE__ */ createBaseVNode("a", {
    href: "https://github.com/element-plus/element-plus-vite-starter",
    target: "_blank"
  }, "element-plus-vite-starter"),
  /* @__PURE__ */ createTextVNode(" | On demand Example: "),
  /* @__PURE__ */ createBaseVNode("a", {
    href: "https://github.com/element-plus/unplugin-element-plus",
    target: "_blank"
  }, "unplugin-element-plus/examples/vite")
], -1);
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  __name: "HelloWorld",
  props: {
    msg: null
  },
  setup(__props) {
    const count = ref(0);
    const input2 = ref("element-plus");
    const curDate = ref("");
    const toast = () => {
      ElMessage.success("Hello");
    };
    return (_ctx, _cache) => {
      const _component_el_button = ElButton;
      const _component_el_input = ElInput;
      const _component_el_tag = ElTag;
      const _component_el_date_picker = ElDatePicker;
      return openBlock(), createElementBlock(Fragment, null, [
        createBaseVNode("h1", null, toDisplayString(__props.msg), 1),
        _hoisted_1$5,
        createVNode(_component_el_button, { onClick: toast }, {
          default: withCtx(() => [
            _hoisted_2$5
          ]),
          _: 1
        }),
        createVNode(_component_el_button, {
          type: "primary",
          onClick: _cache[0] || (_cache[0] = ($event) => count.value++)
        }, {
          default: withCtx(() => [
            createTextVNode("count is: " + toDisplayString(count.value), 1)
          ]),
          _: 1
        }),
        createVNode(_component_el_button, {
          type: "success",
          onClick: _cache[1] || (_cache[1] = ($event) => count.value++)
        }, {
          default: withCtx(() => [
            createTextVNode("count is: " + toDisplayString(count.value), 1)
          ]),
          _: 1
        }),
        createVNode(_component_el_button, {
          type: "warning",
          onClick: _cache[2] || (_cache[2] = ($event) => count.value++)
        }, {
          default: withCtx(() => [
            createTextVNode("count is: " + toDisplayString(count.value), 1)
          ]),
          _: 1
        }),
        createVNode(_component_el_button, {
          type: "danger",
          onClick: _cache[3] || (_cache[3] = ($event) => count.value++)
        }, {
          default: withCtx(() => [
            createTextVNode("count is: " + toDisplayString(count.value), 1)
          ]),
          _: 1
        }),
        createVNode(_component_el_button, {
          type: "info",
          onClick: _cache[4] || (_cache[4] = ($event) => count.value++)
        }, {
          default: withCtx(() => [
            createTextVNode("count is: " + toDisplayString(count.value), 1)
          ]),
          _: 1
        }),
        _hoisted_3$2,
        createVNode(_component_el_input, {
          modelValue: input2.value,
          "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => input2.value = $event),
          style: { "width": "200px", "margin": "20px" }
        }, null, 8, ["modelValue"]),
        createVNode(_component_el_tag, null, {
          default: withCtx(() => [
            _hoisted_4$2
          ]),
          _: 1
        }),
        _hoisted_5$2,
        createVNode(_component_el_date_picker, {
          modelValue: curDate.value,
          "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => curDate.value = $event),
          type: "date",
          placeholder: "Pick a day"
        }, null, 8, ["modelValue"]),
        _hoisted_6$2,
        _hoisted_7$2,
        _hoisted_8$2,
        _hoisted_9$2
      ], 64);
    };
  }
});
var menu = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--ep-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.ep-fade-in-linear-enter-active,.ep-fade-in-linear-leave-active{transition:var(--ep-transition-fade-linear)}.ep-fade-in-linear-enter-from,.ep-fade-in-linear-leave-to{opacity:0}.ep-fade-in-enter-active,.ep-fade-in-leave-active{transition:all var(--ep-transition-duration) cubic-bezier(.55,0,.1,1)}.ep-fade-in-enter-from,.ep-fade-in-leave-active{opacity:0}.ep-zoom-in-center-enter-active,.ep-zoom-in-center-leave-active{transition:all var(--ep-transition-duration) cubic-bezier(.55,0,.1,1)}.ep-zoom-in-center-enter-from,.ep-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.ep-zoom-in-top-enter-active,.ep-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transition:var(--ep-transition-md-fade);transform-origin:center top}.ep-zoom-in-top-enter-active[data-popper-placement^=top],.ep-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.ep-zoom-in-top-enter-from,.ep-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.ep-zoom-in-bottom-enter-active,.ep-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transition:var(--ep-transition-md-fade);transform-origin:center bottom}.ep-zoom-in-bottom-enter-from,.ep-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.ep-zoom-in-left-enter-active,.ep-zoom-in-left-leave-active{opacity:1;transform:scale(1);transition:var(--ep-transition-md-fade);transform-origin:top left}.ep-zoom-in-left-enter-from,.ep-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--ep-transition-duration) height ease-in-out,var(--ep-transition-duration) padding-top ease-in-out,var(--ep-transition-duration) padding-bottom ease-in-out}.ep-collapse-transition-leave-active,.ep-collapse-transition-enter-active{transition:var(--ep-transition-duration) max-height ease-in-out,var(--ep-transition-duration) padding-top ease-in-out,var(--ep-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--ep-transition-duration) width ease-in-out,var(--ep-transition-duration) padding-left ease-in-out,var(--ep-transition-duration) padding-right ease-in-out}.ep-list-enter-active,.ep-list-leave-active{transition:all 1s}.ep-list-enter-from,.ep-list-leave-to{opacity:0;transform:translateY(-30px)}.ep-list-leave-active{position:absolute!important}.ep-opacity-transition{transition:opacity var(--ep-transition-duration) cubic-bezier(.55,0,.1,1)}:root{--ep-menu-active-color: var(--ep-color-primary);--ep-menu-text-color: var(--ep-text-color-primary);--ep-menu-hover-text-color: var(--ep-color-primary);--ep-menu-bg-color: var(--ep-fill-color-blank);--ep-menu-hover-bg-color: var(--ep-color-primary-light-9);--ep-menu-item-height: 56px;--ep-menu-sub-item-height: calc(var(--ep-menu-item-height) - 6px);--ep-menu-horizontal-sub-item-height: 36px;--ep-menu-item-font-size: var(--ep-font-size-base);--ep-menu-item-hover-fill: var(--ep-color-primary-light-9);--ep-menu-border-color: var(--ep-border-color);--ep-menu-base-level-padding: 20px;--ep-menu-level-padding: 20px;--ep-menu-icon-width: 24px;--ep-menu-icon-transform-closed: none;--ep-menu-icon-transform-open: rotateZ(180deg)}.ep-menu{border-right:solid 1px var(--ep-menu-border-color);list-style:none;position:relative;margin:0;padding-left:0;background-color:var(--ep-menu-bg-color);box-sizing:border-box}.ep-menu--vertical:not(.ep-menu--collapse):not(.ep-menu--popup-container) .ep-menu-item,.ep-menu--vertical:not(.ep-menu--collapse):not(.ep-menu--popup-container) .ep-sub-menu__title,.ep-menu--vertical:not(.ep-menu--collapse):not(.ep-menu--popup-container) .ep-menu-item-group__title{padding-left:calc(var(--ep-menu-base-level-padding) + var(--ep-menu-level) * var(--ep-menu-level-padding))}.ep-menu--horizontal{display:flex;flex-wrap:nowrap;border-bottom:solid 1px var(--ep-menu-border-color);border-right:none}.ep-menu--horizontal>.ep-menu-item{display:inline-flex;justify-content:center;align-items:center;height:100%;margin:0;border-bottom:2px solid transparent;color:var(--ep-menu-text-color)}.ep-menu--horizontal>.ep-menu-item a,.ep-menu--horizontal>.ep-menu-item a:hover{color:inherit}.ep-menu--horizontal>.ep-menu-item:not(.is-disabled):hover,.ep-menu--horizontal>.ep-menu-item:not(.is-disabled):focus{background-color:#fff}.ep-menu--horizontal>.ep-sub-menu:focus,.ep-menu--horizontal>.ep-sub-menu:hover{outline:none}.ep-menu--horizontal>.ep-sub-menu:hover .ep-sub-menu__title{color:var(--ep-menu-hover-text-color)}.ep-menu--horizontal>.ep-sub-menu.is-active .ep-sub-menu__title{border-bottom:2px solid var(--ep-menu-active-color);color:var(--ep-menu-active-color)}.ep-menu--horizontal>.ep-sub-menu .ep-sub-menu__title{height:100%;border-bottom:2px solid transparent;color:var(--ep-menu-text-color)}.ep-menu--horizontal>.ep-sub-menu .ep-sub-menu__title:hover{background-color:var(--ep-bg-color-overlay)}.ep-menu--horizontal>.ep-sub-menu .ep-sub-menu__icon-arrow{position:static;vertical-align:middle;margin-left:8px;margin-top:-3px}.ep-menu--horizontal .ep-menu .ep-menu-item,.ep-menu--horizontal .ep-menu .ep-sub-menu__title{background-color:var(--ep-menu-bg-color);display:flex;align-items:center;height:var(--ep-menu-horizontal-sub-item-height);padding:0 10px;color:var(--ep-menu-text-color)}.ep-menu--horizontal .ep-menu .ep-sub-menu__title{padding-right:40px}.ep-menu--horizontal .ep-menu .ep-menu-item.is-active,.ep-menu--horizontal .ep-menu .ep-sub-menu.is-active>.ep-sub-menu__title{color:var(--ep-menu-active-color)}.ep-menu--horizontal .ep-menu-item:not(.is-disabled):hover,.ep-menu--horizontal .ep-menu-item:not(.is-disabled):focus{outline:none;color:var(--ep-menu-hover-text-color);background-color:var(--ep-menu-hover-bg-color)}.ep-menu--horizontal>.ep-menu-item.is-active{border-bottom:2px solid var(--ep-menu-active-color);color:var(--ep-menu-active-color)!important}.ep-menu--collapse{width:calc(var(--ep-menu-icon-width) + var(--ep-menu-base-level-padding) * 2)}.ep-menu--collapse>.ep-menu-item [class^=ep-icon],.ep-menu--collapse>.ep-sub-menu>.ep-sub-menu__title [class^=ep-icon]{margin:0;vertical-align:middle;width:var(--ep-menu-icon-width);text-align:center}.ep-menu--collapse>.ep-menu-item .ep-sub-menu__icon-arrow,.ep-menu--collapse>.ep-sub-menu>.ep-sub-menu__title .ep-sub-menu__icon-arrow{display:none}.ep-menu--collapse>.ep-menu-item>span,.ep-menu--collapse>.ep-sub-menu>.ep-sub-menu__title>span{height:0;width:0;overflow:hidden;visibility:hidden;display:inline-block}.ep-menu--collapse>.ep-menu-item.is-active i{color:inherit}.ep-menu--collapse .ep-menu .ep-sub-menu{min-width:200px}.ep-menu--collapse .ep-sub-menu{position:relative}.ep-menu--collapse .ep-sub-menu .ep-menu{position:absolute;margin-left:5px;top:0;left:100%;z-index:10;border:1px solid var(--ep-border-color-light);border-radius:var(--ep-border-radius-small);box-shadow:var(--ep-box-shadow-light)}.ep-menu--collapse .ep-sub-menu.is-opened>.ep-sub-menu__title .ep-sub-menu__icon-arrow{transform:var(--ep-menu-icon-transform-closed)}.ep-menu--collapse .ep-sub-menu.is-active .ep-sub-menu__title{color:var(--ep-menu-active-color)}.ep-menu--popup{z-index:100;min-width:200px;border:none;padding:5px 0;border-radius:var(--ep-border-radius-small);box-shadow:var(--ep-box-shadow-light)}.ep-menu .ep-icon{flex-shrink:0}.ep-menu-item{display:flex;align-items:center;height:var(--ep-menu-item-height);line-height:var(--ep-menu-item-height);font-size:var(--ep-menu-item-font-size);color:var(--ep-menu-text-color);padding:0 var(--ep-menu-base-level-padding);list-style:none;cursor:pointer;position:relative;transition:border-color var(--ep-transition-duration),background-color var(--ep-transition-duration),color var(--ep-transition-duration);box-sizing:border-box;white-space:nowrap}.ep-menu-item *{vertical-align:bottom}.ep-menu-item i{color:inherit}.ep-menu-item:hover,.ep-menu-item:focus{outline:none}.ep-menu-item:hover{background-color:var(--ep-menu-hover-bg-color)}.ep-menu-item.is-disabled{opacity:.25;cursor:not-allowed;background:none!important}.ep-menu-item [class^=ep-icon]{margin-right:5px;width:var(--ep-menu-icon-width);text-align:center;font-size:18px;vertical-align:middle}.ep-menu-item.is-active{color:var(--ep-menu-active-color)}.ep-menu-item.is-active i{color:inherit}.ep-menu-item .ep-menu-tooltip__trigger{position:absolute;left:0;top:0;height:100%;width:100%;display:inline-flex;align-items:center;box-sizing:border-box;padding:0 var(--ep-menu-base-level-padding)}.ep-sub-menu{list-style:none;margin:0;padding-left:0}.ep-sub-menu__title{display:flex;align-items:center;height:var(--ep-menu-item-height);line-height:var(--ep-menu-item-height);font-size:var(--ep-menu-item-font-size);color:var(--ep-menu-text-color);padding:0 var(--ep-menu-base-level-padding);list-style:none;cursor:pointer;position:relative;transition:border-color var(--ep-transition-duration),background-color var(--ep-transition-duration),color var(--ep-transition-duration);box-sizing:border-box;white-space:nowrap}.ep-sub-menu__title *{vertical-align:bottom}.ep-sub-menu__title i{color:inherit}.ep-sub-menu__title:hover,.ep-sub-menu__title:focus{outline:none}.ep-sub-menu__title.is-disabled{opacity:.25;cursor:not-allowed;background:none!important}.ep-sub-menu__title:hover{background-color:var(--ep-menu-hover-bg-color)}.ep-sub-menu .ep-menu{border:none}.ep-sub-menu .ep-menu-item{height:var(--ep-menu-sub-item-height);line-height:var(--ep-menu-sub-item-height);min-width:200px}.ep-sub-menu__hide-arrow .ep-sub-menu__icon-arrow{display:none!important}.ep-sub-menu.is-active .ep-sub-menu__title{border-bottom-color:var(--ep-menu-active-color)}.ep-sub-menu.is-opened>.ep-sub-menu__title .ep-sub-menu__icon-arrow{transform:var(--ep-menu-icon-transform-open)}.ep-sub-menu.is-disabled .ep-sub-menu__title,.ep-sub-menu.is-disabled .ep-menu-item{opacity:.25;cursor:not-allowed;background:none!important}.ep-sub-menu .ep-icon{vertical-align:middle;margin-right:5px;width:var(--ep-menu-icon-width);text-align:center;font-size:18px}.ep-sub-menu .ep-icon.ep-sub-menu__icon-more{margin-right:0!important}.ep-sub-menu .ep-sub-menu__icon-arrow{position:absolute;top:50%;right:var(--ep-menu-base-level-padding);margin-top:-7px;transform:var(--ep-menu-icon-transform-closed);transition:transform var(--ep-transition-duration);font-size:12px;margin-right:0;width:inherit}.ep-menu-item-group>ul{padding:0}.ep-menu-item-group__title{padding:7px 0 7px var(--ep-menu-base-level-padding);line-height:normal;font-size:12px;color:var(--ep-text-color-secondary)}.horizontal-collapse-transition .ep-sub-menu__title .ep-sub-menu__icon-arrow{transition:var(--ep-transition-duration-fast);opacity:0}\n")();
var tooltip = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}\n")();
var subMenu = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}\n")();
var menuItemGroup = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}\n")();
var menuItem = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}\n")();
var icon = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}.ep-icon-loading{animation:rotating 2s linear infinite}.ep-icon--right{margin-left:5px}.ep-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.ep-icon{--color: inherit;height:1em;width:1em;line-height:1em;display:inline-flex;justify-content:center;align-items:center;position:relative;fill:currentColor;color:var(--color);font-size:inherit}.ep-icon.is-loading{animation:rotating 2s linear infinite}.ep-icon svg{height:1em;width:1em}\n")();
const _hoisted_1$4 = /* @__PURE__ */ createBaseVNode("span", null, "Navigator One", -1);
const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("span", null, "Group One", -1);
const _hoisted_3$1 = /* @__PURE__ */ createTextVNode("item one");
const _hoisted_4$1 = /* @__PURE__ */ createTextVNode("item two");
const _hoisted_5$1 = /* @__PURE__ */ createTextVNode("item three");
const _hoisted_6$1 = /* @__PURE__ */ createBaseVNode("span", null, "item four", -1);
const _hoisted_7$1 = /* @__PURE__ */ createTextVNode("item one");
const _hoisted_8$1 = /* @__PURE__ */ createTextVNode("Navigator Two");
const _hoisted_9$1 = /* @__PURE__ */ createTextVNode("Navigator Three");
const _hoisted_10$1 = /* @__PURE__ */ createTextVNode("Navigator Four");
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "BaseSide",
  setup(__props) {
    const isCollapse = ref(true);
    const handleOpen = (key, keyPath) => {
      console.log(key, keyPath);
    };
    const handleClose = (key, keyPath) => {
      console.log(key, keyPath);
    };
    return (_ctx, _cache) => {
      const _component_el_icon = ElIcon;
      const _component_el_menu_item = ElMenuItem;
      const _component_el_menu_item_group = ElMenuItemGroup;
      const _component_el_sub_menu = ElSubMenu;
      const _component_el_menu = ElMenu;
      return openBlock(), createBlock(_component_el_menu, {
        "default-active": "2",
        class: "el-menu-vertical-demo",
        collapse: isCollapse.value,
        onOpen: handleOpen,
        onClose: handleClose
      }, {
        default: withCtx(() => [
          createVNode(_component_el_sub_menu, { index: "1" }, {
            title: withCtx(() => [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode(unref(location_default))
                ]),
                _: 1
              }),
              _hoisted_1$4
            ]),
            default: withCtx(() => [
              createVNode(_component_el_menu_item_group, null, {
                title: withCtx(() => [
                  _hoisted_2$4
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_menu_item, { index: "1-1" }, {
                    default: withCtx(() => [
                      _hoisted_3$1
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_menu_item, { index: "1-2" }, {
                    default: withCtx(() => [
                      _hoisted_4$1
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_el_menu_item_group, { title: "Group Two" }, {
                default: withCtx(() => [
                  createVNode(_component_el_menu_item, { index: "1-3" }, {
                    default: withCtx(() => [
                      _hoisted_5$1
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_el_sub_menu, { index: "1-4" }, {
                title: withCtx(() => [
                  _hoisted_6$1
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_menu_item, { index: "1-4-1" }, {
                    default: withCtx(() => [
                      _hoisted_7$1
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_component_el_menu_item, { index: "2" }, {
            title: withCtx(() => [
              _hoisted_8$1
            ]),
            default: withCtx(() => [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode(unref(menu_default))
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_component_el_menu_item, {
            index: "3",
            disabled: ""
          }, {
            title: withCtx(() => [
              _hoisted_9$1
            ]),
            default: withCtx(() => [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode(unref(document_default))
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_component_el_menu_item, { index: "4" }, {
            title: withCtx(() => [
              _hoisted_10$1
            ]),
            default: withCtx(() => [
              createVNode(_component_el_icon, null, {
                default: withCtx(() => [
                  createVNode(unref(setting_default))
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["collapse"]);
    };
  }
});
const isDark = useDark();
const toggleDark = useToggle(isDark);
const _hoisted_1$3 = /* @__PURE__ */ createTextVNode("Element Plus");
const _hoisted_2$3 = /* @__PURE__ */ createTextVNode("Workspace");
const _hoisted_3 = /* @__PURE__ */ createTextVNode("item one");
const _hoisted_4 = /* @__PURE__ */ createTextVNode("item two");
const _hoisted_5 = /* @__PURE__ */ createTextVNode("item three");
const _hoisted_6 = /* @__PURE__ */ createTextVNode("item four");
const _hoisted_7 = /* @__PURE__ */ createTextVNode("item one");
const _hoisted_8 = /* @__PURE__ */ createTextVNode("item two");
const _hoisted_9 = /* @__PURE__ */ createTextVNode("item three");
const _hoisted_10 = /* @__PURE__ */ createTextVNode("Info");
const _hoisted_11 = /* @__PURE__ */ createTextVNode("Orders");
const _hoisted_12 = /* @__PURE__ */ createBaseVNode("button", {
  class: "border-none w-full bg-transparent cursor-pointer",
  style: { "height": "var(--ep-menu-item-height)" }
}, [
  /* @__PURE__ */ createBaseVNode("i", {
    "inline-flex": "",
    i: "dark:ep-moon ep-sunny"
  })
], -1);
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  __name: "BaseHeader",
  setup(__props) {
    return (_ctx, _cache) => {
      const _component_el_menu_item = ElMenuItem;
      const _component_el_sub_menu = ElSubMenu;
      const _component_el_menu = ElMenu;
      return openBlock(), createBlock(_component_el_menu, {
        class: "el-menu-demo",
        mode: "horizontal"
      }, {
        default: withCtx(() => [
          createVNode(_component_el_menu_item, { index: "1" }, {
            default: withCtx(() => [
              _hoisted_1$3
            ]),
            _: 1
          }),
          createVNode(_component_el_sub_menu, { index: "2" }, {
            title: withCtx(() => [
              _hoisted_2$3
            ]),
            default: withCtx(() => [
              createVNode(_component_el_menu_item, { index: "2-1" }, {
                default: withCtx(() => [
                  _hoisted_3
                ]),
                _: 1
              }),
              createVNode(_component_el_menu_item, { index: "2-2" }, {
                default: withCtx(() => [
                  _hoisted_4
                ]),
                _: 1
              }),
              createVNode(_component_el_menu_item, { index: "2-3" }, {
                default: withCtx(() => [
                  _hoisted_5
                ]),
                _: 1
              }),
              createVNode(_component_el_sub_menu, { index: "2-4" }, {
                title: withCtx(() => [
                  _hoisted_6
                ]),
                default: withCtx(() => [
                  createVNode(_component_el_menu_item, { index: "2-4-1" }, {
                    default: withCtx(() => [
                      _hoisted_7
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_menu_item, { index: "2-4-2" }, {
                    default: withCtx(() => [
                      _hoisted_8
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_menu_item, { index: "2-4-3" }, {
                    default: withCtx(() => [
                      _hoisted_9
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              })
            ]),
            _: 1
          }),
          createVNode(_component_el_menu_item, {
            index: "3",
            disabled: ""
          }, {
            default: withCtx(() => [
              _hoisted_10
            ]),
            _: 1
          }),
          createVNode(_component_el_menu_item, { index: "4" }, {
            default: withCtx(() => [
              _hoisted_11
            ]),
            _: 1
          }),
          createVNode(_component_el_menu_item, {
            h: "full",
            onClick: _cache[0] || (_cache[0] = ($event) => unref(toggleDark)())
          }, {
            default: withCtx(() => [
              _hoisted_12
            ]),
            _: 1
          })
        ]),
        _: 1
      });
    };
  }
});
var _imports_0 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAD6AAAAXcCAMAAAABMYHEAAACeVBMVEUAAABBuINAnv81Sl5ArIBBuINAnv9BuINBn/9Anv9Anv9Anv9AroBBuINAnv9An/9Anv9Anv9BuINBuINBuINAnv8/nv81SF5Bnv9BuINAnv8/nv9Anv9Anf8/pH1Anv9Anv9Bn/81SV4+n/9BuIM1Sl41SV5BuIM+n/9Anv9Anv9BuINAnv9BuIM/nv9Anv9BuINBuINAnv9Anv9Anv9BuINBuINAnv9Anv9Anv9Anv9BuINBuINAnv9Anv9BuINAnv9Anv9BuINBuINBuYNBuINBuINBuINAnv9Anv9BuINAnv8/nv9BuINBuINBuINBuINAnv9BuINBuINAnv9BuINBuINBuIM0Rl1BuINAnv9Anv9BuINBuoRBuINBuINBuINBuINAnv9BuINBuINBuINBuINAnv86a2s/nv9BuINBuINBuINBuINBuIM6aWtAnv9BuIM5ZmlAnv9Anv9Anv9BuINBuIM6aGpAnv80RFxAnv9Anv9Anv9Anv9Anv9Anv85Y2hAnv84XmZAnv84YWdAnv9Anv84XGVAnv9Anv83W2U3WWQ2UmE4X2c2VGI1Sl9Anv81SF02UmI1S19Anv82UWE1S183VmNAnv82VGI2UGE3VWM2TmA0RFw2U2IzQVs3VGI4XWY6cm04XWU+mHlAnv9BuIM1SV40Q1w1R100Rl1BuYNBu4RCwYY0P1tBvoVCv4U0QVtBvIRBvYU0Plo0RVw3V2M1TWA2UmEzO1k4YWdCxIdCw4Y8iHRBs4I9lHg9j3Y7eW8/pn05amo5b2s3XGU/oXxAsIE8g3I+mXlAqn8+nXs7fnBArYA6dG1BtYI4ZWhCx4gjrDjxAAAApnRSTlMAu+G7A/ik/hRmMykG11xH5vzG/OjWe/gE7/aPGj4IUJAC6g8LxtfkEcII8xYlTKffG/OVdyAPCrj5hRfqQ7fRzulJ9ROUZE8YJivTOpp3Q2vwwo6ZsVV8+4duYtu9nzkRWg22rHFfLg2YyqQyPoIVHqgqrSLcNS8fgP1Y67OeyVM5clrtQze/ZmqKc3/OTrLlxe+o4Ly48onYotyS0/HDu5qRwJvFWd24fgAA6TFJREFUeNrswYEAAAAAgKD9qRepAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg9uBAAAAAAADI/7URVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWFPTgQAAAAAADyf20EVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhDw4EAAAAAID8XxtBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVXYgwMBAAAAACD/10ZQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRX24EAAAAAAAMj/tRFUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYU9OBAAAAAAAPJ/bQRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWEPDgQAAAAAgPxfG0FVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVdiDAwEAAAAAIP/XRlBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFfbgQAAAAAAAyP+1EVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhT04EAAAAAAA8n9tBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYQ8OBAAAAACA/F8bQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV2IMDAQAAAAAg/9dGUFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUV9uBAAAAAAADI/7URVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWFPTgQAAAAAADyf20EVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhDw4EAAAAAID8XxtBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVXYgwMBAAAAACD/10ZQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRX24EAAAAAAAMj/tRFUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYU9OBAAAAAAAPJ/bQRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWEPDgQAAAAAgPxfG0FVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVdiDAwEAAAAAIP/XRlBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFfbgQAAAAAAAyP+1EVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhT04EAAAAAAA8n9tBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYQ8OBAAAAACA/F8bQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV2IMDAQAAAAAg/9dGUFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUV9u2nJZEwDuD4iEoXu1ggXjwI6psQPM1xLoLoIbvkQbbD4JykmwxC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Gp3McwAAAOhHMZvGj3aLcQIAAAD0JK8OTYhvQtNW2u0AAADQr7pdhfgS7qk0HAAAAAyiKLP0KSuXCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/bgQAAAAAAAyP+1EVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhT04EAAAAAAA8n9tBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYQ8OBAAAAACA/F8bQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV2IMDAQAAAAAg/9dGUFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUV9uBAAAAAAADI/7URVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWFPTgQAAAAAADyf20EVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhDw4EAAAAAID8XxtBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVXYgwMBAAAAACD/10ZQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRX24EAAAAAAAMj/tRFUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYU9OBAAAAAAAPJ/bQRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWEPDgQAAAAAgPxfG0FVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVdiDAwEAAAAAIP/XRlBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFfbgQAAAAAAAyP+1EVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhT04EAAAAAAA8n9tBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYQ8OBAAAAACA/F8bQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV2IMDAQAAAAAg/9dGUFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUV9uBAAAAAAADI/7URVFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWFPTgQAAAAAADyf20EVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhDw4EAAAAAID8XxtBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVXYgwMBAAAAACD/10ZQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVRX24EAAAAAAAMj/tRFUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYU9OBAAAAAAAPJ/bQRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWEPDgQAAAAAgPxfG0FVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVdiDAwEAAAAAIP/XRlBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVFfbgQAAAAAAAyP+1EVRVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVhT04EAAAAAAA8n9tBFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYQ8OBAAAAACA/F8bQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV2oMDAQAAAABB/taDXAEAAAAAAAAAAAAAAAAA7AW3iHGJ+hrIrQAAAABJRU5ErkJggg==";
var App_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => "#app{text-align:center;color:var(--ep-text-color-primary)}.element-plus-logo{width:50%}\n")();
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$2 = {};
const _hoisted_1$2 = { style: { "display": "flex" } };
const _hoisted_2$2 = /* @__PURE__ */ createBaseVNode("img", {
  alt: "Vue logo",
  class: "element-plus-logo",
  src: _imports_0
}, null, -1);
function _sfc_render(_ctx, _cache) {
  const _component_BaseHeader = _sfc_main$3;
  const _component_BaseSide = _sfc_main$4;
  const _component_HelloWorld = _sfc_main$5;
  const _component_el_config_provider = ElConfigProvider;
  return openBlock(), createBlock(_component_el_config_provider, { namespace: "ep" }, {
    default: withCtx(() => [
      createVNode(_component_BaseHeader),
      createBaseVNode("div", _hoisted_1$2, [
        createVNode(_component_BaseSide),
        createBaseVNode("div", null, [
          _hoisted_2$2,
          createVNode(_component_HelloWorld, { msg: "Hello Vue 3.0 + Element Plus + Vite" })
        ])
      ])
    ]),
    _: 1
  });
}
var App = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render]]);
const p = function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
};
p();
var index = /* @__PURE__ */ (() => '@charset "UTF-8";html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}body{font-family:Helvetica Neue,Helvetica,PingFang SC,Hiragino Sans GB,Microsoft YaHei,\\5fae\\8f6f\\96c5\\9ed1,Arial,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;margin:0}a{color:var(--ep-color-primary)}code{border-radius:2px;padding:2px 4px;background-color:var(--ep-color-primary-light-9);color:var(--ep-color-primary)}\n')();
var __uno = /* @__PURE__ */ (() => "#--unocss--{layer:__ALL__}\n")();
var message = /* @__PURE__ */ (() => "html.dark{color-scheme:dark;--ep-color-primary: #589ef8;--ep-color-primary-light-3: #4475b4;--ep-color-primary-light-5: #365986;--ep-color-primary-light-7: #283d58;--ep-color-primary-light-8: #223042;--ep-color-primary-light-9: #1b222b;--ep-color-primary-dark-2: #79b1f9;--ep-color-success: #21ba45;--ep-color-success-light-3: #1d8836;--ep-color-success-light-5: #1b672d;--ep-color-success-light-7: #184623;--ep-color-success-light-8: #17351e;--ep-color-success-light-9: #152519;--ep-color-success-dark-2: #4dc86a;--ep-color-warning: #f2711c;--ep-color-warning-light-3: #af551a;--ep-color-warning-light-5: #834318;--ep-color-warning-light-7: #573016;--ep-color-warning-light-8: #402716;--ep-color-warning-light-9: #2a1d15;--ep-color-warning-dark-2: #f58d49;--ep-color-danger: #db2828;--ep-color-danger-light-3: #9f2222;--ep-color-danger-light-5: #781e1e;--ep-color-danger-light-7: #501a1a;--ep-color-danger-light-8: #3c1818;--ep-color-danger-light-9: #281616;--ep-color-danger-dark-2: #e25353;--ep-color-error: #db2828;--ep-color-error-light-3: #9f2222;--ep-color-error-light-5: #781e1e;--ep-color-error-light-7: #501a1a;--ep-color-error-light-8: #3c1818;--ep-color-error-light-9: #281616;--ep-color-error-dark-2: #e25353;--ep-color-info: #42b8dd;--ep-color-info-light-3: #3487a1;--ep-color-info-light-5: #2b6679;--ep-color-info-light-7: #224550;--ep-color-info-light-8: #1d353c;--ep-color-info-light-9: #192428;--ep-color-info-dark-2: #68c6e4;--ep-box-shadow: 0px 12px 32px 4px rgba(0, 0, 0, .36), 0px 8px 20px rgba(0, 0, 0, .72);--ep-box-shadow-light: 0px 0px 12px rgba(0, 0, 0, .72);--ep-box-shadow-lighter: 0px 0px 6px rgba(0, 0, 0, .72);--ep-box-shadow-dark: 0px 16px 48px 16px rgba(0, 0, 0, .72), 0px 12px 32px #000000, 0px 8px 16px -8px #000000;--ep-bg-color-page: #0a0a0a;--ep-bg-color: #141414;--ep-bg-color-overlay: #1d1e1f;--ep-text-color-primary: #E5EAF3;--ep-text-color-regular: #CFD3DC;--ep-text-color-secondary: #A3A6AD;--ep-text-color-placeholder: #8D9095;--ep-text-color-disabled: #6C6E72;--ep-border-color-darker: #636466;--ep-border-color-dark: #58585B;--ep-border-color: #4C4D4F;--ep-border-color-light: #414243;--ep-border-color-lighter: #363637;--ep-border-color-extra-light: #2B2B2C;--ep-fill-color-darker: #424243;--ep-fill-color-dark: #39393A;--ep-fill-color: #303030;--ep-fill-color-light: #262727;--ep-fill-color-lighter: #1D1D1D;--ep-fill-color-extra-light: #191919;--ep-fill-color-blank: transparent;--ep-mask-color: rgba(0, 0, 0, .8);--ep-mask-color-extra-light: rgba(0, 0, 0, .3)}html.dark .ep-button{--ep-button-disabled-text-color: rgba(255, 255, 255, .5)}html.dark .ep-card{--ep-card-bg-color: var(--ep-bg-color-overlay)}html.dark .ep-empty{--ep-empty-fill-color-0: var(--ep-color-black);--ep-empty-fill-color-1: #4b4b52;--ep-empty-fill-color-2: #36383d;--ep-empty-fill-color-3: #1e1e20;--ep-empty-fill-color-4: #262629;--ep-empty-fill-color-5: #202124;--ep-empty-fill-color-6: #212224;--ep-empty-fill-color-7: #1b1c1f;--ep-empty-fill-color-8: #1c1d1f;--ep-empty-fill-color-9: #18181a}.ep-message{--ep-message-min-width: 380px;--ep-message-bg-color: var(--ep-color-info-light-9);--ep-message-border-color: var(--ep-border-color-lighter);--ep-message-padding: 15px 15px 15px 20px;--ep-message-close-size: 16px;--ep-message-close-icon-color: var(--ep-text-color-placeholder);--ep-message-close-hover-color: var(--ep-text-color-secondary)}.ep-message{min-width:var(--ep-message-min-width);box-sizing:border-box;border-radius:var(--ep-border-radius-base);border-width:var(--ep-border-width);border-style:var(--ep-border-style);border-color:var(--ep-message-border-color);position:fixed;left:50%;top:20px;transform:translate(-50%);transition:opacity .3s,transform .4s,top .4s;background-color:var(--ep-message-bg-color);transition:opacity var(--ep-transition-duration),transform .4s,top .4s;padding:var(--ep-message-padding);display:flex;align-items:center}.ep-message.is-center{justify-content:center}.ep-message.is-closable .ep-message__content{padding-right:16px}.ep-message p{margin:0}.ep-message--success{--ep-message-bg-color: var(--ep-color-success-light-9);--ep-message-border-color: var(--ep-color-success-light-8);--ep-message-text-color: var(--ep-color-success)}.ep-message--success .ep-message__content,.ep-message .ep-message-icon--success{color:var(--ep-message-text-color)}.ep-message--info{--ep-message-bg-color: var(--ep-color-info-light-9);--ep-message-border-color: var(--ep-color-info-light-8);--ep-message-text-color: var(--ep-color-info)}.ep-message--info .ep-message__content,.ep-message .ep-message-icon--info{color:var(--ep-message-text-color)}.ep-message--warning{--ep-message-bg-color: var(--ep-color-warning-light-9);--ep-message-border-color: var(--ep-color-warning-light-8);--ep-message-text-color: var(--ep-color-warning)}.ep-message--warning .ep-message__content,.ep-message .ep-message-icon--warning{color:var(--ep-message-text-color)}.ep-message--error{--ep-message-bg-color: var(--ep-color-error-light-9);--ep-message-border-color: var(--ep-color-error-light-8);--ep-message-text-color: var(--ep-color-error)}.ep-message--error .ep-message__content,.ep-message .ep-message-icon--error{color:var(--ep-message-text-color)}.ep-message__icon{margin-right:10px}.ep-message .ep-message__badge{position:absolute;top:-8px;right:-8px}.ep-message__content{padding:0;font-size:14px;line-height:1}.ep-message__content:focus{outline-width:0}.ep-message .ep-message__closeBtn{position:absolute;top:50%;right:15px;transform:translateY(-50%);cursor:pointer;color:var(--ep-message-close-icon-color);font-size:var(--ep-message-close-size)}.ep-message .ep-message__closeBtn:focus{outline-width:0}.ep-message .ep-message__closeBtn:hover{color:var(--ep-message-close-hover-color)}.ep-message-fade-enter-from,.ep-message-fade-leave-to{opacity:0;transform:translate(-50%,-100%)}\n")();
var highchartsVue_min = { exports: {} };
var highcharts = { exports: {} };
(function(module2) {
  (function(U2, K2) {
    module2.exports ? (K2["default"] = K2, module2.exports = U2.document ? K2(U2) : K2) : (U2.Highcharts && U2.Highcharts.error(16, true), U2.Highcharts = K2(U2));
  })(typeof window !== "undefined" ? window : commonjsGlobal, function(U2) {
    function K2(a, C2, f2, H2) {
      a.hasOwnProperty(C2) || (a[C2] = H2.apply(null, f2), typeof CustomEvent === "function" && U2.dispatchEvent(new CustomEvent("HighchartsModuleLoaded", { detail: { path: C2, module: a[C2] } })));
    }
    var f = {};
    K2(f, "Core/Globals.js", [], function() {
      var a;
      (function(a2) {
        a2.SVG_NS = "http://www.w3.org/2000/svg";
        a2.product = "Highcharts";
        a2.version = "10.1.0";
        a2.win = typeof U2 !== "undefined" ? U2 : {};
        a2.doc = a2.win.document;
        a2.svg = a2.doc && a2.doc.createElementNS && !!a2.doc.createElementNS(a2.SVG_NS, "svg").createSVGRect;
        a2.userAgent = a2.win.navigator && a2.win.navigator.userAgent || "";
        a2.isChrome = a2.userAgent.indexOf("Chrome") !== -1;
        a2.isFirefox = a2.userAgent.indexOf("Firefox") !== -1;
        a2.isMS = /(edge|msie|trident)/i.test(a2.userAgent) && !a2.win.opera;
        a2.isSafari = !a2.isChrome && a2.userAgent.indexOf("Safari") !== -1;
        a2.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(a2.userAgent);
        a2.isWebKit = a2.userAgent.indexOf("AppleWebKit") !== -1;
        a2.deg2rad = 2 * Math.PI / 360;
        a2.hasBidiBug = a2.isFirefox && 4 > parseInt(a2.userAgent.split("Firefox/")[1], 10);
        a2.hasTouch = !!a2.win.TouchEvent;
        a2.marginNames = ["plotTop", "marginRight", "marginBottom", "plotLeft"];
        a2.noop = function() {
        };
        a2.supportsPassiveEvents = function() {
          var f2 = false;
          if (!a2.isMS) {
            var C2 = Object.defineProperty({}, "passive", { get: function() {
              f2 = true;
            } });
            a2.win.addEventListener && a2.win.removeEventListener && (a2.win.addEventListener("testPassive", a2.noop, C2), a2.win.removeEventListener("testPassive", a2.noop, C2));
          }
          return f2;
        }();
        a2.charts = [];
        a2.dateFormats = {};
        a2.seriesTypes = {};
        a2.symbolSizes = {};
        a2.chartCount = 0;
      })(a || (a = {}));
      return a;
    });
    K2(f, "Core/Utilities.js", [f["Core/Globals.js"]], function(a) {
      function f2(d2, r, h3, l2) {
        var v = r ? "Highcharts error" : "Highcharts warning";
        d2 === 32 && (d2 = v + ": Deprecated member");
        var m2 = n(d2), c2 = m2 ? v + " #" + d2 + ": www.highcharts.com/errors/" + d2 + "/" : d2.toString();
        if (typeof l2 !== "undefined") {
          var q3 = "";
          m2 && (c2 += "?");
          y(l2, function(b2, d3) {
            q3 += "\n - " + d3 + ": " + b2;
            m2 && (c2 += encodeURI(d3) + "=" + encodeURI(b2));
          });
          c2 += q3;
        }
        z(a, "displayError", { chart: h3, code: d2, message: c2, params: l2 }, function() {
          if (r)
            throw Error(c2);
          b.console && f2.messages.indexOf(c2) === -1 && console.warn(c2);
        });
        f2.messages.push(c2);
      }
      function B2(b2, d2) {
        var v = {};
        y(b2, function(r, h3) {
          if (I2(b2[h3], true) && !b2.nodeType && d2[h3])
            r = B2(b2[h3], d2[h3]), Object.keys(r).length && (v[h3] = r);
          else if (I2(b2[h3]) || b2[h3] !== d2[h3] || h3 in b2 && !(h3 in d2))
            v[h3] = b2[h3];
        });
        return v;
      }
      function H2(b2, d2) {
        return parseInt(b2, d2 || 10);
      }
      function w(b2) {
        return typeof b2 === "string";
      }
      function E2(b2) {
        b2 = Object.prototype.toString.call(b2);
        return b2 === "[object Array]" || b2 === "[object Array Iterator]";
      }
      function I2(b2, d2) {
        return !!b2 && typeof b2 === "object" && (!d2 || !E2(b2));
      }
      function A(b2) {
        return I2(b2) && typeof b2.nodeType === "number";
      }
      function u(b2) {
        var d2 = b2 && b2.constructor;
        return !(!I2(b2, true) || A(b2) || !d2 || !d2.name || d2.name === "Object");
      }
      function n(b2) {
        return typeof b2 === "number" && !isNaN(b2) && Infinity > b2 && -Infinity < b2;
      }
      function k(b2) {
        return typeof b2 !== "undefined" && b2 !== null;
      }
      function e(b2, d2, h3) {
        var v = w(d2) && !k(h3), r, l2 = function(d3, h4) {
          k(d3) ? b2.setAttribute(h4, d3) : v ? (r = b2.getAttribute(h4)) || h4 !== "class" || (r = b2.getAttribute(h4 + "Name")) : b2.removeAttribute(h4);
        };
        w(d2) ? l2(h3, d2) : y(d2, l2);
        return r;
      }
      function c(b2, d2) {
        var v;
        b2 || (b2 = {});
        for (v in d2)
          b2[v] = d2[v];
        return b2;
      }
      function p2() {
        for (var b2 = arguments, d2 = b2.length, h3 = 0; h3 < d2; h3++) {
          var l2 = b2[h3];
          if (typeof l2 !== "undefined" && l2 !== null)
            return l2;
        }
      }
      function g(b2, d2) {
        a.isMS && !a.svg && d2 && k(d2.opacity) && (d2.filter = "alpha(opacity=" + 100 * d2.opacity + ")");
        c(b2.style, d2);
      }
      function t(b2) {
        return Math.pow(10, Math.floor(Math.log(b2) / Math.LN10));
      }
      function q2(b2, d2) {
        return 1e14 < b2 ? b2 : parseFloat(b2.toPrecision(d2 || 14));
      }
      function F(d2, r, h3) {
        var v = a.getStyle || F;
        if (r === "width")
          return r = Math.min(d2.offsetWidth, d2.scrollWidth), h3 = d2.getBoundingClientRect && d2.getBoundingClientRect().width, h3 < r && h3 >= r - 1 && (r = Math.floor(h3)), Math.max(0, r - (v(d2, "padding-left", true) || 0) - (v(d2, "padding-right", true) || 0));
        if (r === "height")
          return Math.max(0, Math.min(d2.offsetHeight, d2.scrollHeight) - (v(d2, "padding-top", true) || 0) - (v(d2, "padding-bottom", true) || 0));
        b.getComputedStyle || f2(27, true);
        if (d2 = b.getComputedStyle(d2, void 0)) {
          var l2 = d2.getPropertyValue(r);
          p2(h3, r !== "opacity") && (l2 = H2(l2));
        }
        return l2;
      }
      function y(b2, d2, h3) {
        for (var v in b2)
          Object.hasOwnProperty.call(b2, v) && d2.call(h3 || b2[v], b2[v], v, b2);
      }
      function x(b2, d2, h3) {
        function v(d3, J2) {
          var v2 = b2.removeEventListener || a.removeEventListenerPolyfill;
          v2 && v2.call(b2, d3, J2, false);
        }
        function r(r2) {
          var J2;
          if (b2.nodeName) {
            if (d2) {
              var L = {};
              L[d2] = true;
            } else
              L = r2;
            y(L, function(b3, d3) {
              if (r2[d3])
                for (J2 = r2[d3].length; J2--; )
                  v(d3, r2[d3][J2].fn);
            });
          }
        }
        var l2 = typeof b2 === "function" && b2.prototype || b2;
        if (Object.hasOwnProperty.call(l2, "hcEvents")) {
          var m2 = l2.hcEvents;
          d2 ? (l2 = m2[d2] || [], h3 ? (m2[d2] = l2.filter(function(b3) {
            return h3 !== b3.fn;
          }), v(d2, h3)) : (r(m2), m2[d2] = [])) : (r(m2), delete l2.hcEvents);
        }
      }
      function z(b2, d2, l2, m2) {
        l2 = l2 || {};
        if (h2.createEvent && (b2.dispatchEvent || b2.fireEvent && b2 !== a)) {
          var v = h2.createEvent("Events");
          v.initEvent(d2, true, true);
          l2 = c(v, l2);
          b2.dispatchEvent ? b2.dispatchEvent(l2) : b2.fireEvent(d2, l2);
        } else if (b2.hcEvents) {
          l2.target || c(l2, { preventDefault: function() {
            l2.defaultPrevented = true;
          }, target: b2, type: d2 });
          v = [];
          for (var r = b2, q3 = false; r.hcEvents; )
            Object.hasOwnProperty.call(r, "hcEvents") && r.hcEvents[d2] && (v.length && (q3 = true), v.unshift.apply(v, r.hcEvents[d2])), r = Object.getPrototypeOf(r);
          q3 && v.sort(function(b3, d3) {
            return b3.order - d3.order;
          });
          v.forEach(function(d3) {
            d3.fn.call(b2, l2) === false && l2.preventDefault();
          });
        }
        m2 && !l2.defaultPrevented && m2.call(b2, l2);
      }
      var m = a.charts, h2 = a.doc, b = a.win;
      (f2 || (f2 = {})).messages = [];
      Math.easeInOutSine = function(b2) {
        return -0.5 * (Math.cos(Math.PI * b2) - 1);
      };
      var l = Array.prototype.find ? function(b2, d2) {
        return b2.find(d2);
      } : function(b2, d2) {
        var v, r = b2.length;
        for (v = 0; v < r; v++)
          if (d2(b2[v], v))
            return b2[v];
      };
      y({ map: "map", each: "forEach", grep: "filter", reduce: "reduce", some: "some" }, function(b2, d2) {
        a[d2] = function(v) {
          var r;
          f2(32, false, void 0, (r = {}, r["Highcharts." + d2] = "use Array." + b2, r));
          return Array.prototype[b2].apply(v, [].slice.call(arguments, 1));
        };
      });
      var d, D = function() {
        var b2 = Math.random().toString(36).substring(2, 9) + "-", r = 0;
        return function() {
          return "highcharts-" + (d ? "" : b2) + r++;
        };
      }();
      b.jQuery && (b.jQuery.fn.highcharts = function() {
        var b2 = [].slice.call(arguments);
        if (this[0])
          return b2[0] ? (new a[w(b2[0]) ? b2.shift() : "Chart"](this[0], b2[0], b2[1]), this) : m[e(this[0], "data-highcharts-chart")];
      });
      l = {
        addEvent: function(b2, d2, h3, l2) {
          l2 === void 0 && (l2 = {});
          var r = typeof b2 === "function" && b2.prototype || b2;
          Object.hasOwnProperty.call(r, "hcEvents") || (r.hcEvents = {});
          r = r.hcEvents;
          a.Point && b2 instanceof a.Point && b2.series && b2.series.chart && (b2.series.chart.runTrackerClick = true);
          var v = b2.addEventListener || a.addEventListenerPolyfill;
          v && v.call(b2, d2, h3, a.supportsPassiveEvents ? { passive: l2.passive === void 0 ? d2.indexOf("touch") !== -1 : l2.passive, capture: false } : false);
          r[d2] || (r[d2] = []);
          r[d2].push({ fn: h3, order: typeof l2.order === "number" ? l2.order : Infinity });
          r[d2].sort(function(b3, d3) {
            return b3.order - d3.order;
          });
          return function() {
            x(b2, d2, h3);
          };
        },
        arrayMax: function(b2) {
          for (var d2 = b2.length, v = b2[0]; d2--; )
            b2[d2] > v && (v = b2[d2]);
          return v;
        },
        arrayMin: function(b2) {
          for (var d2 = b2.length, v = b2[0]; d2--; )
            b2[d2] < v && (v = b2[d2]);
          return v;
        },
        attr: e,
        clamp: function(b2, d2, h3) {
          return b2 > d2 ? b2 < h3 ? b2 : h3 : d2;
        },
        cleanRecursively: B2,
        clearTimeout: function(b2) {
          k(b2) && clearTimeout(b2);
        },
        correctFloat: q2,
        createElement: function(b2, d2, l2, m2, q3) {
          b2 = h2.createElement(b2);
          d2 && c(b2, d2);
          q3 && g(b2, { padding: "0", border: "none", margin: "0" });
          l2 && g(b2, l2);
          m2 && m2.appendChild(b2);
          return b2;
        },
        css: g,
        defined: k,
        destroyObjectProperties: function(b2, d2) {
          y(b2, function(r, v) {
            r && r !== d2 && r.destroy && r.destroy();
            delete b2[v];
          });
        },
        discardElement: function(b2) {
          b2 && b2.parentElement && b2.parentElement.removeChild(b2);
        },
        erase: function(b2, d2) {
          for (var r = b2.length; r--; )
            if (b2[r] === d2) {
              b2.splice(r, 1);
              break;
            }
        },
        error: f2,
        extend: c,
        extendClass: function(b2, d2) {
          var r = function() {
          };
          r.prototype = new b2();
          c(r.prototype, d2);
          return r;
        },
        find: l,
        fireEvent: z,
        getMagnitude: t,
        getNestedProperty: function(d2, r) {
          for (d2 = d2.split("."); d2.length && k(r); ) {
            var h3 = d2.shift();
            if (typeof h3 === "undefined" || h3 === "__proto__")
              return;
            r = r[h3];
            if (!k(r) || typeof r === "function" || typeof r.nodeType === "number" || r === b)
              return;
          }
          return r;
        },
        getStyle: F,
        inArray: function(b2, d2, h3) {
          f2(32, false, void 0, { "Highcharts.inArray": "use Array.indexOf" });
          return d2.indexOf(b2, h3);
        },
        isArray: E2,
        isClass: u,
        isDOMElement: A,
        isFunction: function(b2) {
          return typeof b2 === "function";
        },
        isNumber: n,
        isObject: I2,
        isString: w,
        keys: function(b2) {
          f2(32, false, void 0, { "Highcharts.keys": "use Object.keys" });
          return Object.keys(b2);
        },
        merge: function() {
          var b2, d2 = arguments, h3 = {}, l2 = function(b3, d3) {
            typeof b3 !== "object" && (b3 = {});
            y(d3, function(r, J2) {
              J2 !== "__proto__" && J2 !== "constructor" && (!I2(r, true) || u(r) || A(r) ? b3[J2] = d3[J2] : b3[J2] = l2(b3[J2] || {}, r));
            });
            return b3;
          };
          d2[0] === true && (h3 = d2[1], d2 = Array.prototype.slice.call(d2, 2));
          var m2 = d2.length;
          for (b2 = 0; b2 < m2; b2++)
            h3 = l2(h3, d2[b2]);
          return h3;
        },
        normalizeTickInterval: function(b2, d2, h3, l2, m2) {
          var r = b2;
          h3 = p2(h3, t(b2));
          var v = b2 / h3;
          d2 || (d2 = m2 ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], l2 === false && (h3 === 1 ? d2 = d2.filter(function(b3) {
            return b3 % 1 === 0;
          }) : 0.1 >= h3 && (d2 = [1 / h3])));
          for (l2 = 0; l2 < d2.length && !(r = d2[l2], m2 && r * h3 >= b2 || !m2 && v <= (d2[l2] + (d2[l2 + 1] || d2[l2])) / 2); l2++)
            ;
          return r = q2(r * h3, -Math.round(Math.log(1e-3) / Math.LN10));
        },
        objectEach: y,
        offset: function(d2) {
          var r = h2.documentElement;
          d2 = d2.parentElement || d2.parentNode ? d2.getBoundingClientRect() : { top: 0, left: 0, width: 0, height: 0 };
          return { top: d2.top + (b.pageYOffset || r.scrollTop) - (r.clientTop || 0), left: d2.left + (b.pageXOffset || r.scrollLeft) - (r.clientLeft || 0), width: d2.width, height: d2.height };
        },
        pad: function(b2, d2, h3) {
          return Array((d2 || 2) + 1 - String(b2).replace("-", "").length).join(h3 || "0") + b2;
        },
        pick: p2,
        pInt: H2,
        relativeLength: function(b2, d2, h3) {
          return /%$/.test(b2) ? d2 * parseFloat(b2) / 100 + (h3 || 0) : parseFloat(b2);
        },
        removeEvent: x,
        splat: function(b2) {
          return E2(b2) ? b2 : [b2];
        },
        stableSort: function(b2, d2) {
          var h3 = b2.length, r, l2;
          for (l2 = 0; l2 < h3; l2++)
            b2[l2].safeI = l2;
          b2.sort(function(b3, h4) {
            r = d2(b3, h4);
            return r === 0 ? b3.safeI - h4.safeI : r;
          });
          for (l2 = 0; l2 < h3; l2++)
            delete b2[l2].safeI;
        },
        syncTimeout: function(b2, d2, h3) {
          if (0 < d2)
            return setTimeout(b2, d2, h3);
          b2.call(0, h3);
          return -1;
        },
        timeUnits: {
          millisecond: 1,
          second: 1e3,
          minute: 6e4,
          hour: 36e5,
          day: 864e5,
          week: 6048e5,
          month: 24192e5,
          year: 314496e5
        },
        uniqueKey: D,
        useSerialIds: function(b2) {
          return d = p2(b2, d);
        },
        wrap: function(b2, d2, h3) {
          var l2 = b2[d2];
          b2[d2] = function() {
            var b3 = Array.prototype.slice.call(arguments), d3 = arguments, r = this;
            r.proceed = function() {
              l2.apply(r, arguments.length ? arguments : d3);
            };
            b3.unshift(l2);
            b3 = h3.apply(this, b3);
            r.proceed = null;
            return b3;
          };
        }
      };
      return l;
    });
    K2(f, "Core/Chart/ChartDefaults.js", [], function() {
      return {
        alignThresholds: false,
        panning: { enabled: false, type: "x" },
        styledMode: false,
        borderRadius: 0,
        colorCount: 10,
        allowMutatingData: true,
        defaultSeriesType: "line",
        ignoreHiddenSeries: true,
        spacing: [10, 10, 15, 10],
        resetZoomButton: { theme: { zIndex: 6 }, position: { align: "right", x: -10, y: 10 } },
        zoomBySingleTouch: false,
        width: null,
        height: null,
        borderColor: "#335cad",
        backgroundColor: "#ffffff",
        plotBorderColor: "#cccccc"
      };
    });
    K2(f, "Core/Color/Color.js", [f["Core/Globals.js"], f["Core/Utilities.js"]], function(a, f2) {
      var C2 = f2.isNumber, H2 = f2.merge, w = f2.pInt;
      f2 = function() {
        function f3(C3) {
          this.rgba = [NaN, NaN, NaN, NaN];
          this.input = C3;
          var A = a.Color;
          if (A && A !== f3)
            return new A(C3);
          if (!(this instanceof f3))
            return new f3(C3);
          this.init(C3);
        }
        f3.parse = function(a2) {
          return a2 ? new f3(a2) : f3.None;
        };
        f3.prototype.init = function(a2) {
          var A;
          if (typeof a2 === "object" && typeof a2.stops !== "undefined")
            this.stops = a2.stops.map(function(e) {
              return new f3(e[1]);
            });
          else if (typeof a2 === "string") {
            this.input = a2 = f3.names[a2.toLowerCase()] || a2;
            if (a2.charAt(0) === "#") {
              var u = a2.length;
              var n = parseInt(a2.substr(1), 16);
              u === 7 ? A = [(n & 16711680) >> 16, (n & 65280) >> 8, n & 255, 1] : u === 4 && (A = [(n & 3840) >> 4 | (n & 3840) >> 8, (n & 240) >> 4 | n & 240, (n & 15) << 4 | n & 15, 1]);
            }
            if (!A)
              for (n = f3.parsers.length; n-- && !A; ) {
                var k = f3.parsers[n];
                (u = k.regex.exec(a2)) && (A = k.parse(u));
              }
          }
          A && (this.rgba = A);
        };
        f3.prototype.get = function(a2) {
          var A = this.input, u = this.rgba;
          if (typeof A === "object" && typeof this.stops !== "undefined") {
            var n = H2(A);
            n.stops = [].slice.call(n.stops);
            this.stops.forEach(function(k, e) {
              n.stops[e] = [n.stops[e][0], k.get(a2)];
            });
            return n;
          }
          return u && C2(u[0]) ? a2 === "rgb" || !a2 && u[3] === 1 ? "rgb(" + u[0] + "," + u[1] + "," + u[2] + ")" : a2 === "a" ? "" + u[3] : "rgba(" + u.join(",") + ")" : A;
        };
        f3.prototype.brighten = function(a2) {
          var A = this.rgba;
          if (this.stops)
            this.stops.forEach(function(n) {
              n.brighten(a2);
            });
          else if (C2(a2) && a2 !== 0)
            for (var u = 0; 3 > u; u++)
              A[u] += w(255 * a2), 0 > A[u] && (A[u] = 0), 255 < A[u] && (A[u] = 255);
          return this;
        };
        f3.prototype.setOpacity = function(a2) {
          this.rgba[3] = a2;
          return this;
        };
        f3.prototype.tweenTo = function(a2, A) {
          var u = this.rgba, n = a2.rgba;
          if (!C2(u[0]) || !C2(n[0]))
            return a2.input || "none";
          a2 = n[3] !== 1 || u[3] !== 1;
          return (a2 ? "rgba(" : "rgb(") + Math.round(n[0] + (u[0] - n[0]) * (1 - A)) + "," + Math.round(n[1] + (u[1] - n[1]) * (1 - A)) + "," + Math.round(n[2] + (u[2] - n[2]) * (1 - A)) + (a2 ? "," + (n[3] + (u[3] - n[3]) * (1 - A)) : "") + ")";
        };
        f3.names = { white: "#ffffff", black: "#000000" };
        f3.parsers = [{ regex: /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, parse: function(a2) {
          return [w(a2[1]), w(a2[2]), w(a2[3]), parseFloat(a2[4], 10)];
        } }, { regex: /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, parse: function(a2) {
          return [w(a2[1]), w(a2[2]), w(a2[3]), 1];
        } }];
        f3.None = new f3("");
        return f3;
      }();
      return f2;
    });
    K2(f, "Core/Color/Palettes.js", [], function() {
      return { colors: "#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1".split(" ") };
    });
    K2(f, "Core/Time.js", [f["Core/Globals.js"], f["Core/Utilities.js"]], function(a, f2) {
      var C2 = a.win, H2 = f2.defined, w = f2.error, E2 = f2.extend, I2 = f2.isObject, A = f2.merge, u = f2.objectEach, n = f2.pad, k = f2.pick, e = f2.splat, c = f2.timeUnits, p2 = a.isSafari && C2.Intl && C2.Intl.DateTimeFormat.prototype.formatRange, g = a.isSafari && C2.Intl && !C2.Intl.DateTimeFormat.prototype.formatRange;
      f2 = function() {
        function t(c2) {
          this.options = {};
          this.variableTimezone = this.useUTC = false;
          this.Date = C2.Date;
          this.getTimezoneOffset = this.timezoneOffsetFunction();
          this.update(c2);
        }
        t.prototype.get = function(c2, e2) {
          if (this.variableTimezone || this.timezoneOffset) {
            var q2 = e2.getTime(), p3 = q2 - this.getTimezoneOffset(e2);
            e2.setTime(p3);
            c2 = e2["getUTC" + c2]();
            e2.setTime(q2);
            return c2;
          }
          return this.useUTC ? e2["getUTC" + c2]() : e2["get" + c2]();
        };
        t.prototype.set = function(c2, e2, g2) {
          if (this.variableTimezone || this.timezoneOffset) {
            if (c2 === "Milliseconds" || c2 === "Seconds" || c2 === "Minutes" && this.getTimezoneOffset(e2) % 36e5 === 0)
              return e2["setUTC" + c2](g2);
            var q2 = this.getTimezoneOffset(e2);
            q2 = e2.getTime() - q2;
            e2.setTime(q2);
            e2["setUTC" + c2](g2);
            c2 = this.getTimezoneOffset(e2);
            q2 = e2.getTime() + c2;
            return e2.setTime(q2);
          }
          return this.useUTC || p2 && c2 === "FullYear" ? e2["setUTC" + c2](g2) : e2["set" + c2](g2);
        };
        t.prototype.update = function(c2) {
          var e2 = k(c2 && c2.useUTC, true);
          this.options = c2 = A(true, this.options || {}, c2);
          this.Date = c2.Date || C2.Date || Date;
          this.timezoneOffset = (this.useUTC = e2) && c2.timezoneOffset;
          this.getTimezoneOffset = this.timezoneOffsetFunction();
          this.variableTimezone = e2 && !(!c2.getTimezoneOffset && !c2.timezone);
        };
        t.prototype.makeTime = function(c2, e2, p3, t2, z, m) {
          if (this.useUTC) {
            var h2 = this.Date.UTC.apply(0, arguments);
            var b = this.getTimezoneOffset(h2);
            h2 += b;
            var l = this.getTimezoneOffset(h2);
            b !== l ? h2 += l - b : b - 36e5 !== this.getTimezoneOffset(h2 - 36e5) || g || (h2 -= 36e5);
          } else
            h2 = new this.Date(c2, e2, k(p3, 1), k(t2, 0), k(z, 0), k(m, 0)).getTime();
          return h2;
        };
        t.prototype.timezoneOffsetFunction = function() {
          var c2 = this, e2 = this.options, p3 = e2.getTimezoneOffset, g2 = e2.moment || C2.moment;
          if (!this.useUTC)
            return function(c3) {
              return 6e4 * new Date(c3.toString()).getTimezoneOffset();
            };
          if (e2.timezone) {
            if (g2)
              return function(c3) {
                return 6e4 * -g2.tz(c3, e2.timezone).utcOffset();
              };
            w(25);
          }
          return this.useUTC && p3 ? function(c3) {
            return 6e4 * p3(c3.valueOf());
          } : function() {
            return 6e4 * (c2.timezoneOffset || 0);
          };
        };
        t.prototype.dateFormat = function(c2, e2, p3) {
          if (!H2(e2) || isNaN(e2))
            return a.defaultOptions.lang && a.defaultOptions.lang.invalidDate || "";
          c2 = k(c2, "%Y-%m-%d %H:%M:%S");
          var q2 = this, g2 = new this.Date(e2), m = this.get("Hours", g2), h2 = this.get("Day", g2), b = this.get("Date", g2), l = this.get("Month", g2), d = this.get("FullYear", g2), D = a.defaultOptions.lang, v = D && D.weekdays, r = D && D.shortWeekdays;
          g2 = E2({
            a: r ? r[h2] : v[h2].substr(0, 3),
            A: v[h2],
            d: n(b),
            e: n(b, 2, " "),
            w: h2,
            b: D.shortMonths[l],
            B: D.months[l],
            m: n(l + 1),
            o: l + 1,
            y: d.toString().substr(2, 2),
            Y: d,
            H: n(m),
            k: m,
            I: n(m % 12 || 12),
            l: m % 12 || 12,
            M: n(this.get("Minutes", g2)),
            p: 12 > m ? "AM" : "PM",
            P: 12 > m ? "am" : "pm",
            S: n(g2.getSeconds()),
            L: n(Math.floor(e2 % 1e3), 3)
          }, a.dateFormats);
          u(g2, function(b2, d2) {
            for (; c2.indexOf("%" + d2) !== -1; )
              c2 = c2.replace("%" + d2, typeof b2 === "function" ? b2.call(q2, e2) : b2);
          });
          return p3 ? c2.substr(0, 1).toUpperCase() + c2.substr(1) : c2;
        };
        t.prototype.resolveDTLFormat = function(c2) {
          return I2(c2, true) ? c2 : (c2 = e(c2), { main: c2[0], from: c2[1], to: c2[2] });
        };
        t.prototype.getTimeTicks = function(e2, g2, p3, t2) {
          var q2 = this, m = [], h2 = {}, b = new q2.Date(g2), l = e2.unitRange, d = e2.count || 1, D;
          t2 = k(t2, 1);
          if (H2(g2)) {
            q2.set("Milliseconds", b, l >= c.second ? 0 : d * Math.floor(q2.get("Milliseconds", b) / d));
            l >= c.second && q2.set("Seconds", b, l >= c.minute ? 0 : d * Math.floor(q2.get("Seconds", b) / d));
            l >= c.minute && q2.set("Minutes", b, l >= c.hour ? 0 : d * Math.floor(q2.get("Minutes", b) / d));
            l >= c.hour && q2.set("Hours", b, l >= c.day ? 0 : d * Math.floor(q2.get("Hours", b) / d));
            l >= c.day && q2.set("Date", b, l >= c.month ? 1 : Math.max(1, d * Math.floor(q2.get("Date", b) / d)));
            if (l >= c.month) {
              q2.set("Month", b, l >= c.year ? 0 : d * Math.floor(q2.get("Month", b) / d));
              var v = q2.get("FullYear", b);
            }
            l >= c.year && q2.set("FullYear", b, v - v % d);
            l === c.week && (v = q2.get("Day", b), q2.set("Date", b, q2.get("Date", b) - v + t2 + (v < t2 ? -7 : 0)));
            v = q2.get("FullYear", b);
            t2 = q2.get("Month", b);
            var r = q2.get("Date", b), y = q2.get("Hours", b);
            g2 = b.getTime();
            !q2.variableTimezone && q2.useUTC || !H2(p3) || (D = p3 - g2 > 4 * c.month || q2.getTimezoneOffset(g2) !== q2.getTimezoneOffset(p3));
            g2 = b.getTime();
            for (b = 1; g2 < p3; )
              m.push(g2), g2 = l === c.year ? q2.makeTime(v + b * d, 0) : l === c.month ? q2.makeTime(v, t2 + b * d) : !D || l !== c.day && l !== c.week ? D && l === c.hour && 1 < d ? q2.makeTime(v, t2, r, y + b * d) : g2 + l * d : q2.makeTime(v, t2, r + b * d * (l === c.day ? 1 : 7)), b++;
            m.push(g2);
            l <= c.hour && 1e4 > m.length && m.forEach(function(b2) {
              b2 % 18e5 === 0 && q2.dateFormat("%H%M%S%L", b2) === "000000000" && (h2[b2] = "day");
            });
          }
          m.info = E2(e2, { higherRanks: h2, totalRange: l * d });
          return m;
        };
        t.prototype.getDateFormat = function(e2, g2, p3, t2) {
          var q2 = this.dateFormat("%m-%d %H:%M:%S.%L", g2), m = { millisecond: 15, second: 12, minute: 9, hour: 6, day: 3 }, h2 = "millisecond";
          for (b in c) {
            if (e2 === c.week && +this.dateFormat("%w", g2) === p3 && q2.substr(6) === "00:00:00.000") {
              var b = "week";
              break;
            }
            if (c[b] > e2) {
              b = h2;
              break;
            }
            if (m[b] && q2.substr(m[b]) !== "01-01 00:00:00.000".substr(m[b]))
              break;
            b !== "week" && (h2 = b);
          }
          if (b)
            var l = this.resolveDTLFormat(t2[b]).main;
          return l;
        };
        return t;
      }();
      return f2;
    });
    K2(f, "Core/DefaultOptions.js", [f["Core/Chart/ChartDefaults.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Color/Palettes.js"], f["Core/Time.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2, w, E2) {
      f2 = f2.parse;
      var C2 = E2.merge, A = { colors: H2.colors, symbols: [
        "circle",
        "diamond",
        "square",
        "triangle",
        "triangle-down"
      ], lang: { loading: "Loading...", months: "January February March April May June July August September October November December".split(" "), shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" "), weekdays: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), decimalPoint: ".", numericSymbols: "kMGTPE".split(""), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " " }, global: {}, time: {
        Date: void 0,
        getTimezoneOffset: void 0,
        timezone: void 0,
        timezoneOffset: 0,
        useUTC: true
      }, chart: a, title: { text: "Chart title", align: "center", margin: 15, widthAdjust: -44 }, subtitle: { text: "", align: "center", widthAdjust: -44 }, caption: { margin: 15, text: "", align: "left", verticalAlign: "bottom" }, plotOptions: {}, labels: { style: { position: "absolute", color: "#333333" } }, legend: { enabled: true, align: "center", alignColumns: true, className: "highcharts-no-tooltip", layout: "horizontal", labelFormatter: function() {
        return this.name;
      }, borderColor: "#999999", borderRadius: 0, navigation: {
        activeColor: "#003399",
        inactiveColor: "#cccccc"
      }, itemStyle: { color: "#333333", cursor: "pointer", fontSize: "12px", fontWeight: "bold", textOverflow: "ellipsis" }, itemHoverStyle: { color: "#000000" }, itemHiddenStyle: { color: "#cccccc" }, shadow: false, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, squareSymbol: true, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "45%" }, style: {
        position: "absolute",
        backgroundColor: "#ffffff",
        opacity: 0.5,
        textAlign: "center"
      } }, tooltip: {
        enabled: true,
        animation: B2.svg,
        borderRadius: 3,
        dateTimeLabelFormats: { millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y" },
        footerFormat: "",
        headerShape: "callout",
        hideDelay: 500,
        padding: 8,
        shape: "callout",
        shared: false,
        snap: B2.isTouchDevice ? 25 : 10,
        headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
        pointFormat: '<span style="color:{point.color}">\u25CF</span> {series.name}: <b>{point.y}</b><br/>',
        backgroundColor: f2("#f7f7f7").setOpacity(0.85).get(),
        borderWidth: 1,
        shadow: true,
        stickOnContact: false,
        style: { color: "#333333", cursor: "default", fontSize: "12px", whiteSpace: "nowrap" },
        useHTML: false
      }, credits: { enabled: true, href: "https://www.highcharts.com?credits", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#999999", fontSize: "9px" }, text: "Highcharts.com" } };
      A.chart.styledMode = false;
      var u = new w(C2(A.global, A.time));
      a = {
        defaultOptions: A,
        defaultTime: u,
        getOptions: function() {
          return A;
        },
        setOptions: function(n) {
          C2(true, A, n);
          if (n.time || n.global)
            B2.time ? B2.time.update(C2(A.global, A.time, n.global, n.time)) : B2.time = u;
          return A;
        }
      };
      return a;
    });
    K2(f, "Core/Animation/Fx.js", [f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = a.parse, w = f2.win, E2 = B2.isNumber, I2 = B2.objectEach;
      return function() {
        function a2(a3, n, k) {
          this.pos = NaN;
          this.options = n;
          this.elem = a3;
          this.prop = k;
        }
        a2.prototype.dSetter = function() {
          var a3 = this.paths, n = a3 && a3[0];
          a3 = a3 && a3[1];
          var k = this.now || 0, e = [];
          if (k !== 1 && n && a3)
            if (n.length === a3.length && 1 > k)
              for (var c = 0; c < a3.length; c++) {
                for (var p2 = n[c], g = a3[c], t = [], q2 = 0; q2 < g.length; q2++) {
                  var F = p2[q2], y = g[q2];
                  E2(F) && E2(y) && (g[0] !== "A" || q2 !== 4 && q2 !== 5) ? t[q2] = F + k * (y - F) : t[q2] = y;
                }
                e.push(t);
              }
            else
              e = a3;
          else
            e = this.toD || [];
          this.elem.attr("d", e, void 0, true);
        };
        a2.prototype.update = function() {
          var a3 = this.elem, n = this.prop, k = this.now, e = this.options.step;
          if (this[n + "Setter"])
            this[n + "Setter"]();
          else
            a3.attr ? a3.element && a3.attr(n, k, null, true) : a3.style[n] = k + this.unit;
          e && e.call(a3, k, this);
        };
        a2.prototype.run = function(u, n, k) {
          var e = this, c = e.options, p2 = function(c2) {
            return p2.stopped ? false : e.step(c2);
          }, g = w.requestAnimationFrame || function(c2) {
            setTimeout(c2, 13);
          }, t = function() {
            for (var c2 = 0; c2 < a2.timers.length; c2++)
              a2.timers[c2]() || a2.timers.splice(c2--, 1);
            a2.timers.length && g(t);
          };
          u !== n || this.elem["forceAnimate:" + this.prop] ? (this.startTime = +new Date(), this.start = u, this.end = n, this.unit = k, this.now = this.start, this.pos = 0, p2.elem = this.elem, p2.prop = this.prop, p2() && a2.timers.push(p2) === 1 && g(t)) : (delete c.curAnim[this.prop], c.complete && Object.keys(c.curAnim).length === 0 && c.complete.call(this.elem));
        };
        a2.prototype.step = function(a3) {
          var n = +new Date(), k = this.options, e = this.elem, c = k.complete, p2 = k.duration, g = k.curAnim;
          if (e.attr && !e.element)
            a3 = false;
          else if (a3 || n >= p2 + this.startTime) {
            this.now = this.end;
            this.pos = 1;
            this.update();
            var t = g[this.prop] = true;
            I2(g, function(c2) {
              c2 !== true && (t = false);
            });
            t && c && c.call(e);
            a3 = false;
          } else
            this.pos = k.easing((n - this.startTime) / p2), this.now = this.start + (this.end - this.start) * this.pos, this.update(), a3 = true;
          return a3;
        };
        a2.prototype.initPath = function(a3, n, k) {
          function e(c2, m) {
            for (; c2.length < x; ) {
              var h2 = c2[0], b = m[x - c2.length];
              b && h2[0] === "M" && (c2[0] = b[0] === "C" ? ["C", h2[1], h2[2], h2[1], h2[2], h2[1], h2[2]] : ["L", h2[1], h2[2]]);
              c2.unshift(h2);
              t && (h2 = c2.pop(), c2.push(c2[c2.length - 1], h2));
            }
          }
          function c(c2, m) {
            for (; c2.length < x; )
              if (m = c2[Math.floor(c2.length / q2) - 1].slice(), m[0] === "C" && (m[1] = m[5], m[2] = m[6]), t) {
                var h2 = c2[Math.floor(c2.length / q2)].slice();
                c2.splice(c2.length / 2, 0, m, h2);
              } else
                c2.push(m);
          }
          var p2 = a3.startX, g = a3.endX;
          k = k.slice();
          var t = a3.isArea, q2 = t ? 2 : 1;
          n = n && n.slice();
          if (!n)
            return [k, k];
          if (p2 && g && g.length) {
            for (a3 = 0; a3 < p2.length; a3++)
              if (p2[a3] === g[0]) {
                var F = a3;
                break;
              } else if (p2[0] === g[g.length - p2.length + a3]) {
                F = a3;
                var y = true;
                break;
              } else if (p2[p2.length - 1] === g[g.length - p2.length + a3]) {
                F = p2.length - a3;
                break;
              }
            typeof F === "undefined" && (n = []);
          }
          if (n.length && E2(F)) {
            var x = k.length + F * q2;
            y ? (e(n, k), c(k, n)) : (e(k, n), c(n, k));
          }
          return [n, k];
        };
        a2.prototype.fillSetter = function() {
          a2.prototype.strokeSetter.apply(this, arguments);
        };
        a2.prototype.strokeSetter = function() {
          this.elem.attr(this.prop, C2(this.start).tweenTo(C2(this.end), this.pos), void 0, true);
        };
        a2.timers = [];
        return a2;
      }();
    });
    K2(f, "Core/Animation/AnimationUtilities.js", [
      f["Core/Animation/Fx.js"],
      f["Core/Utilities.js"]
    ], function(a, f2) {
      function C2(c) {
        return u(c) ? n({ duration: 500, defer: 0 }, c) : { duration: c ? 500 : 0, defer: 0 };
      }
      function H2(c, e2) {
        for (var g = a.timers.length; g--; )
          a.timers[g].elem !== c || e2 && e2 !== a.timers[g].prop || (a.timers[g].stopped = true);
      }
      var w = f2.defined, E2 = f2.getStyle, I2 = f2.isArray, A = f2.isNumber, u = f2.isObject, n = f2.merge, k = f2.objectEach, e = f2.pick;
      return { animate: function(c, e2, g) {
        var p2, q2 = "", F, y;
        if (!u(g)) {
          var x = arguments;
          g = { duration: x[2], easing: x[3], complete: x[4] };
        }
        A(g.duration) || (g.duration = 400);
        g.easing = typeof g.easing === "function" ? g.easing : Math[g.easing] || Math.easeInOutSine;
        g.curAnim = n(e2);
        k(e2, function(t, m) {
          H2(c, m);
          y = new a(c, g, m);
          F = void 0;
          m === "d" && I2(e2.d) ? (y.paths = y.initPath(c, c.pathArray, e2.d), y.toD = e2.d, p2 = 0, F = 1) : c.attr ? p2 = c.attr(m) : (p2 = parseFloat(E2(c, m)) || 0, m !== "opacity" && (q2 = "px"));
          F || (F = t);
          typeof F === "string" && F.match("px") && (F = F.replace(/px/g, ""));
          y.run(p2, F, q2);
        });
      }, animObject: C2, getDeferredAnimation: function(c, e2, g) {
        var p2 = C2(e2), q2 = 0, k2 = 0;
        (g ? [g] : c.series).forEach(function(c2) {
          c2 = C2(c2.options.animation);
          q2 = e2 && w(e2.defer) ? p2.defer : Math.max(q2, c2.duration + c2.defer);
          k2 = Math.min(p2.duration, c2.duration);
        });
        c.renderer.forExport && (q2 = 0);
        return { defer: Math.max(0, q2 - k2), duration: Math.min(q2, k2) };
      }, setAnimation: function(c, p2) {
        p2.renderer.globalAnimation = e(c, p2.options.chart.animation, true);
      }, stop: H2 };
    });
    K2(f, "Core/Renderer/HTML/AST.js", [f["Core/Globals.js"], f["Core/Utilities.js"]], function(a, f2) {
      var C2 = a.SVG_NS, H2 = f2.attr, w = f2.createElement, E2 = f2.css, I2 = f2.error, A = f2.isFunction, u = f2.isString, n = f2.objectEach, k = f2.splat, e = (f2 = a.win.trustedTypes) && A(f2.createPolicy) && f2.createPolicy("highcharts", { createHTML: function(c2) {
        return c2;
      } }), c = e ? e.createHTML("") : "";
      try {
        var p2 = !!new DOMParser().parseFromString(c, "text/html");
      } catch (g) {
        p2 = false;
      }
      A = function() {
        function g(c2) {
          this.nodes = typeof c2 === "string" ? this.parseMarkup(c2) : c2;
        }
        g.filterUserAttributes = function(c2) {
          n(c2, function(e2, p3) {
            var q2 = true;
            g.allowedAttributes.indexOf(p3) === -1 && (q2 = false);
            ["background", "dynsrc", "href", "lowsrc", "src"].indexOf(p3) !== -1 && (q2 = u(e2) && g.allowedReferences.some(function(c3) {
              return e2.indexOf(c3) === 0;
            }));
            q2 || (I2(33, false, void 0, { "Invalid attribute in config": "" + p3 }), delete c2[p3]);
          });
          return c2;
        };
        g.parseStyle = function(c2) {
          return c2.split(";").reduce(function(c3, e2) {
            e2 = e2.split(":").map(function(c4) {
              return c4.trim();
            });
            var g2 = e2.shift();
            g2 && e2.length && (c3[g2.replace(/-([a-z])/g, function(c4) {
              return c4[1].toUpperCase();
            })] = e2.join(":"));
            return c3;
          }, {});
        };
        g.setElementHTML = function(c2, e2) {
          c2.innerHTML = g.emptyHTML;
          e2 && new g(e2).addToDOM(c2);
        };
        g.prototype.addToDOM = function(c2) {
          function e2(c3, p3) {
            var q2;
            k(c3).forEach(function(c4) {
              var m = c4.tagName, h2 = c4.textContent ? a.doc.createTextNode(c4.textContent) : void 0, b = g.bypassHTMLFiltering;
              if (m)
                if (m === "#text")
                  var l = h2;
                else if (g.allowedTags.indexOf(m) !== -1 || b) {
                  m = a.doc.createElementNS(m === "svg" ? C2 : p3.namespaceURI || C2, m);
                  var d = c4.attributes || {};
                  n(c4, function(b2, c5) {
                    c5 !== "tagName" && c5 !== "attributes" && c5 !== "children" && c5 !== "style" && c5 !== "textContent" && (d[c5] = b2);
                  });
                  H2(m, b ? d : g.filterUserAttributes(d));
                  c4.style && E2(m, c4.style);
                  h2 && m.appendChild(h2);
                  e2(c4.children || [], m);
                  l = m;
                } else
                  I2(33, false, void 0, { "Invalid tagName in config": m });
              l && p3.appendChild(l);
              q2 = l;
            });
            return q2;
          }
          return e2(this.nodes, c2);
        };
        g.prototype.parseMarkup = function(c2) {
          var q2 = [];
          c2 = c2.trim().replace(/ style="/g, ' data-style="');
          if (p2)
            c2 = new DOMParser().parseFromString(e ? e.createHTML(c2) : c2, "text/html");
          else {
            var k2 = w("div");
            k2.innerHTML = c2;
            c2 = { body: k2 };
          }
          var t = function(c3, e2) {
            var m = c3.nodeName.toLowerCase(), h2 = { tagName: m };
            m === "#text" && (h2.textContent = c3.textContent || "");
            if (m = c3.attributes) {
              var b = {};
              [].forEach.call(m, function(d) {
                d.name === "data-style" ? h2.style = g.parseStyle(d.value) : b[d.name] = d.value;
              });
              h2.attributes = b;
            }
            if (c3.childNodes.length) {
              var l = [];
              [].forEach.call(c3.childNodes, function(b2) {
                t(b2, l);
              });
              l.length && (h2.children = l);
            }
            e2.push(h2);
          };
          [].forEach.call(c2.body.childNodes, function(c3) {
            return t(c3, q2);
          });
          return q2;
        };
        g.allowedAttributes = "aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex".split(" ");
        g.allowedReferences = "https:// http:// mailto: / ../ ./ #".split(" ");
        g.allowedTags = "a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text".split(" ");
        g.emptyHTML = c;
        g.bypassHTMLFiltering = false;
        return g;
      }();
      return A;
    });
    K2(f, "Core/FormatUtilities.js", [f["Core/DefaultOptions.js"], f["Core/Utilities.js"]], function(a, f2) {
      function C2(a2, k, e, c) {
        a2 = +a2 || 0;
        k = +k;
        var p2 = H2.lang, g = (a2.toString().split(".")[1] || "").split("e")[0].length, t = a2.toString().split("e"), q2 = k;
        if (k === -1)
          k = Math.min(g, 20);
        else if (!I2(k))
          k = 2;
        else if (k && t[1] && 0 > t[1]) {
          var F = k + +t[1];
          0 <= F ? (t[0] = (+t[0]).toExponential(F).split("e")[0], k = F) : (t[0] = t[0].split(".")[0] || 0, a2 = 20 > k ? (t[0] * Math.pow(10, t[1])).toFixed(k) : 0, t[1] = 0);
        }
        F = (Math.abs(t[1] ? t[0] : a2) + Math.pow(10, -Math.max(k, g) - 1)).toFixed(k);
        g = String(u(F));
        var y = 3 < g.length ? g.length % 3 : 0;
        e = A(e, p2.decimalPoint);
        c = A(c, p2.thousandsSep);
        a2 = (0 > a2 ? "-" : "") + (y ? g.substr(0, y) + c : "");
        a2 = 0 > +t[1] && !q2 ? "0" : a2 + g.substr(y).replace(/(\d{3})(?=\d)/g, "$1" + c);
        k && (a2 += e + F.slice(-k));
        t[1] && +a2 !== 0 && (a2 += "e" + t[1]);
        return a2;
      }
      var H2 = a.defaultOptions, w = a.defaultTime, E2 = f2.getNestedProperty, I2 = f2.isNumber, A = f2.pick, u = f2.pInt;
      return { dateFormat: function(a2, k, e) {
        return w.dateFormat(a2, k, e);
      }, format: function(a2, k, e) {
        var c = "{", p2 = false, g = /f$/, t = /\.([0-9])/, q2 = H2.lang, F = e && e.time || w;
        e = e && e.numberFormatter || C2;
        for (var y = []; a2; ) {
          var x = a2.indexOf(c);
          if (x === -1)
            break;
          var z = a2.slice(0, x);
          if (p2) {
            z = z.split(":");
            c = E2(z.shift() || "", k);
            if (z.length && typeof c === "number")
              if (z = z.join(":"), g.test(z)) {
                var m = parseInt((z.match(t) || ["", "-1"])[1], 10);
                c !== null && (c = e(c, m, q2.decimalPoint, -1 < z.indexOf(",") ? q2.thousandsSep : ""));
              } else
                c = F.dateFormat(z, c);
            y.push(c);
          } else
            y.push(z);
          a2 = a2.slice(x + 1);
          c = (p2 = !p2) ? "}" : "{";
        }
        y.push(a2);
        return y.join("");
      }, numberFormat: C2 };
    });
    K2(f, "Core/Renderer/RendererUtilities.js", [f["Core/Utilities.js"]], function(a) {
      var f2 = a.clamp, B2 = a.pick, H2 = a.stableSort, w;
      (function(a2) {
        function C2(a3, u, n) {
          var k = a3, e = k.reducedLen || u, c = function(c2, e2) {
            return (e2.rank || 0) - (c2.rank || 0);
          }, p2 = function(c2, e2) {
            return c2.target - e2.target;
          }, g, t = true, q2 = [], F = 0;
          for (g = a3.length; g--; )
            F += a3[g].size;
          if (F > e) {
            H2(a3, c);
            for (F = g = 0; F <= e; )
              F += a3[g].size, g++;
            q2 = a3.splice(g - 1, a3.length);
          }
          H2(a3, p2);
          for (a3 = a3.map(function(c2) {
            return { size: c2.size, targets: [c2.target], align: B2(c2.align, 0.5) };
          }); t; ) {
            for (g = a3.length; g--; )
              e = a3[g], c = (Math.min.apply(0, e.targets) + Math.max.apply(0, e.targets)) / 2, e.pos = f2(c - e.size * e.align, 0, u - e.size);
            g = a3.length;
            for (t = false; g--; )
              0 < g && a3[g - 1].pos + a3[g - 1].size > a3[g].pos && (a3[g - 1].size += a3[g].size, a3[g - 1].targets = a3[g - 1].targets.concat(a3[g].targets), a3[g - 1].align = 0.5, a3[g - 1].pos + a3[g - 1].size > u && (a3[g - 1].pos = u - a3[g - 1].size), a3.splice(g, 1), t = true);
          }
          k.push.apply(k, q2);
          g = 0;
          a3.some(function(c2) {
            var e2 = 0;
            return (c2.targets || []).some(function() {
              k[g].pos = c2.pos + e2;
              if (typeof n !== "undefined" && Math.abs(k[g].pos - k[g].target) > n)
                return k.slice(0, g + 1).forEach(function(c3) {
                  return delete c3.pos;
                }), k.reducedLen = (k.reducedLen || u) - 0.1 * u, k.reducedLen > 0.1 * u && C2(k, u, n), true;
              e2 += k[g].size;
              g++;
              return false;
            });
          });
          H2(k, p2);
          return k;
        }
        a2.distribute = C2;
      })(w || (w = {}));
      return w;
    });
    K2(f, "Core/Renderer/SVG/SVGElement.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Renderer/HTML/AST.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2, w) {
      var C2 = a.animate, I2 = a.animObject, A = a.stop, u = H2.deg2rad, n = H2.doc, k = H2.noop, e = H2.svg, c = H2.SVG_NS, p2 = H2.win, g = w.addEvent, t = w.attr, q2 = w.createElement, F = w.css, y = w.defined, x = w.erase, z = w.extend, m = w.fireEvent, h2 = w.isArray, b = w.isFunction, l = w.isNumber, d = w.isString, D = w.merge, v = w.objectEach, r = w.pick, O = w.pInt, P2 = w.syncTimeout, S = w.uniqueKey;
      a = function() {
        function a2() {
          this.element = void 0;
          this.onEvents = {};
          this.opacity = 1;
          this.renderer = void 0;
          this.SVG_NS = c;
          this.symbolCustomAttribs = "x y width height r start end innerR anchorX anchorY rounded".split(" ");
        }
        a2.prototype._defaultGetter = function(b2) {
          b2 = r(this[b2 + "Value"], this[b2], this.element ? this.element.getAttribute(b2) : null, 0);
          /^[\-0-9\.]+$/.test(b2) && (b2 = parseFloat(b2));
          return b2;
        };
        a2.prototype._defaultSetter = function(b2, d2, c2) {
          c2.setAttribute(d2, b2);
        };
        a2.prototype.add = function(b2) {
          var d2 = this.renderer, c2 = this.element;
          b2 && (this.parentGroup = b2);
          this.parentInverted = b2 && b2.inverted;
          typeof this.textStr !== "undefined" && this.element.nodeName === "text" && d2.buildText(this);
          this.added = true;
          if (!b2 || b2.handleZ || this.zIndex)
            var h3 = this.zIndexSetter();
          h3 || (b2 ? b2.element : d2.box).appendChild(c2);
          if (this.onAdd)
            this.onAdd();
          return this;
        };
        a2.prototype.addClass = function(b2, d2) {
          var c2 = d2 ? "" : this.attr("class") || "";
          b2 = (b2 || "").split(/ /g).reduce(function(b3, d3) {
            c2.indexOf(d3) === -1 && b3.push(d3);
            return b3;
          }, c2 ? [c2] : []).join(" ");
          b2 !== c2 && this.attr("class", b2);
          return this;
        };
        a2.prototype.afterSetters = function() {
          this.doTransform && (this.updateTransform(), this.doTransform = false);
        };
        a2.prototype.align = function(b2, c2, J2) {
          var h3 = {}, l2 = this.renderer, e2 = l2.alignedObjects, m2, a3, G2;
          if (b2) {
            if (this.alignOptions = b2, this.alignByTranslate = c2, !J2 || d(J2))
              this.alignTo = m2 = J2 || "renderer", x(e2, this), e2.push(this), J2 = void 0;
          } else
            b2 = this.alignOptions, c2 = this.alignByTranslate, m2 = this.alignTo;
          J2 = r(J2, l2[m2], m2 === "scrollablePlotBox" ? l2.plotBox : void 0, l2);
          m2 = b2.align;
          var v2 = b2.verticalAlign;
          l2 = (J2.x || 0) + (b2.x || 0);
          e2 = (J2.y || 0) + (b2.y || 0);
          m2 === "right" ? a3 = 1 : m2 === "center" && (a3 = 2);
          a3 && (l2 += (J2.width - (b2.width || 0)) / a3);
          h3[c2 ? "translateX" : "x"] = Math.round(l2);
          v2 === "bottom" ? G2 = 1 : v2 === "middle" && (G2 = 2);
          G2 && (e2 += (J2.height - (b2.height || 0)) / G2);
          h3[c2 ? "translateY" : "y"] = Math.round(e2);
          this[this.placed ? "animate" : "attr"](h3);
          this.placed = true;
          this.alignAttr = h3;
          return this;
        };
        a2.prototype.alignSetter = function(b2) {
          var d2 = {
            left: "start",
            center: "middle",
            right: "end"
          };
          d2[b2] && (this.alignValue = b2, this.element.setAttribute("text-anchor", d2[b2]));
        };
        a2.prototype.animate = function(b2, d2, c2) {
          var J2 = this, h3 = I2(r(d2, this.renderer.globalAnimation, true));
          d2 = h3.defer;
          r(n.hidden, n.msHidden, n.webkitHidden, false) && (h3.duration = 0);
          h3.duration !== 0 ? (c2 && (h3.complete = c2), P2(function() {
            J2.element && C2(J2, b2, h3);
          }, d2)) : (this.attr(b2, void 0, c2 || h3.complete), v(b2, function(b3, d3) {
            h3.step && h3.step.call(this, b3, { prop: d3, pos: 1, elem: this });
          }, this));
          return this;
        };
        a2.prototype.applyTextOutline = function(b2) {
          var d2 = this.element;
          b2.indexOf("contrast") !== -1 && (b2 = b2.replace(/contrast/g, this.renderer.getContrast(d2.style.fill)));
          var J2 = b2.split(" ");
          b2 = J2[J2.length - 1];
          if ((J2 = J2[0]) && J2 !== "none" && H2.svg) {
            this.fakeTS = true;
            this.ySetter = this.xSetter;
            J2 = J2.replace(/(^[\d\.]+)(.*?)$/g, function(b3, d3, c2) {
              return 2 * Number(d3) + c2;
            });
            this.removeTextOutline();
            var h3 = n.createElementNS(c, "tspan");
            t(h3, { "class": "highcharts-text-outline", fill: b2, stroke: b2, "stroke-width": J2, "stroke-linejoin": "round" });
            [].forEach.call(d2.childNodes, function(b3) {
              var d3 = b3.cloneNode(true);
              d3.removeAttribute && ["fill", "stroke", "stroke-width", "stroke"].forEach(function(b4) {
                return d3.removeAttribute(b4);
              });
              h3.appendChild(d3);
            });
            var l2 = n.createElementNS(c, "tspan");
            l2.textContent = "\u200B";
            ["x", "y"].forEach(function(b3) {
              var c2 = d2.getAttribute(b3);
              c2 && l2.setAttribute(b3, c2);
            });
            h3.appendChild(l2);
            d2.insertBefore(h3, d2.firstChild);
          }
        };
        a2.prototype.attr = function(b2, d2, c2, h3) {
          var J2 = this.element, l2 = this.symbolCustomAttribs, r2, L = this, G2, e2;
          if (typeof b2 === "string" && typeof d2 !== "undefined") {
            var m2 = b2;
            b2 = {};
            b2[m2] = d2;
          }
          typeof b2 === "string" ? L = (this[b2 + "Getter"] || this._defaultGetter).call(this, b2, J2) : (v(b2, function(d3, c3) {
            G2 = false;
            h3 || A(this, c3);
            this.symbolName && l2.indexOf(c3) !== -1 && (r2 || (this.symbolAttr(b2), r2 = true), G2 = true);
            !this.rotation || c3 !== "x" && c3 !== "y" || (this.doTransform = true);
            G2 || (e2 = this[c3 + "Setter"] || this._defaultSetter, e2.call(this, d3, c3, J2), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c3) && this.updateShadows(c3, d3, e2));
          }, this), this.afterSetters());
          c2 && c2.call(this);
          return L;
        };
        a2.prototype.clip = function(b2) {
          return this.attr("clip-path", b2 ? "url(" + this.renderer.url + "#" + b2.id + ")" : "none");
        };
        a2.prototype.crisp = function(b2, d2) {
          d2 = d2 || b2.strokeWidth || 0;
          var c2 = Math.round(d2) % 2 / 2;
          b2.x = Math.floor(b2.x || this.x || 0) + c2;
          b2.y = Math.floor(b2.y || this.y || 0) + c2;
          b2.width = Math.floor((b2.width || this.width || 0) - 2 * c2);
          b2.height = Math.floor((b2.height || this.height || 0) - 2 * c2);
          y(b2.strokeWidth) && (b2.strokeWidth = d2);
          return b2;
        };
        a2.prototype.complexColor = function(b2, d2, c2) {
          var J2 = this.renderer, l2, r2, e2, a3, G2, g2, p3, q3, k2, t2, x2 = [], z2;
          m(this.renderer, "complexColor", { args: arguments }, function() {
            b2.radialGradient ? r2 = "radialGradient" : b2.linearGradient && (r2 = "linearGradient");
            if (r2) {
              e2 = b2[r2];
              G2 = J2.gradients;
              g2 = b2.stops;
              k2 = c2.radialReference;
              h2(e2) && (b2[r2] = e2 = { x1: e2[0], y1: e2[1], x2: e2[2], y2: e2[3], gradientUnits: "userSpaceOnUse" });
              r2 === "radialGradient" && k2 && !y(e2.gradientUnits) && (a3 = e2, e2 = D(e2, J2.getRadialAttr(k2, a3), { gradientUnits: "userSpaceOnUse" }));
              v(e2, function(b3, d3) {
                d3 !== "id" && x2.push(d3, b3);
              });
              v(g2, function(b3) {
                x2.push(b3);
              });
              x2 = x2.join(",");
              if (G2[x2])
                t2 = G2[x2].attr("id");
              else {
                e2.id = t2 = S();
                var L = G2[x2] = J2.createElement(r2).attr(e2).add(J2.defs);
                L.radAttr = a3;
                L.stops = [];
                g2.forEach(function(b3) {
                  b3[1].indexOf("rgba") === 0 ? (l2 = B2.parse(b3[1]), p3 = l2.get("rgb"), q3 = l2.get("a")) : (p3 = b3[1], q3 = 1);
                  b3 = J2.createElement("stop").attr({ offset: b3[0], "stop-color": p3, "stop-opacity": q3 }).add(L);
                  L.stops.push(b3);
                });
              }
              z2 = "url(" + J2.url + "#" + t2 + ")";
              c2.setAttribute(d2, z2);
              c2.gradient = x2;
              b2.toString = function() {
                return z2;
              };
            }
          });
        };
        a2.prototype.css = function(b2) {
          var d2 = this.styles, c2 = {}, h3 = this.element, l2 = !d2;
          b2.color && (b2.fill = b2.color);
          d2 && v(b2, function(b3, J2) {
            d2 && d2[J2] !== b3 && (c2[J2] = b3, l2 = true);
          });
          if (l2) {
            d2 && (b2 = z(d2, c2));
            if (b2.width === null || b2.width === "auto")
              delete this.textWidth;
            else if (h3.nodeName.toLowerCase() === "text" && b2.width)
              var r2 = this.textWidth = O(b2.width);
            this.styles = b2;
            r2 && !e && this.renderer.forExport && delete b2.width;
            var m2 = D(b2);
            h3.namespaceURI === this.SVG_NS && ["textOutline", "textOverflow", "width"].forEach(function(b3) {
              return m2 && delete m2[b3];
            });
            F(h3, m2);
            this.added && (this.element.nodeName === "text" && this.renderer.buildText(this), b2.textOutline && this.applyTextOutline(b2.textOutline));
          }
          return this;
        };
        a2.prototype.dashstyleSetter = function(b2) {
          var d2 = this["stroke-width"];
          d2 === "inherit" && (d2 = 1);
          if (b2 = b2 && b2.toLowerCase()) {
            var c2 = b2.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(",");
            for (b2 = c2.length; b2--; )
              c2[b2] = "" + O(c2[b2]) * r(d2, NaN);
            b2 = c2.join(",").replace(/NaN/g, "none");
            this.element.setAttribute("stroke-dasharray", b2);
          }
        };
        a2.prototype.destroy = function() {
          var b2 = this, d2 = b2.element || {}, c2 = b2.renderer, h3 = d2.ownerSVGElement, l2 = c2.isSVG && d2.nodeName === "SPAN" && b2.parentGroup || void 0;
          d2.onclick = d2.onmouseout = d2.onmouseover = d2.onmousemove = d2.point = null;
          A(b2);
          if (b2.clipPath && h3) {
            var r2 = b2.clipPath;
            [].forEach.call(h3.querySelectorAll("[clip-path],[CLIP-PATH]"), function(b3) {
              -1 < b3.getAttribute("clip-path").indexOf(r2.element.id) && b3.removeAttribute("clip-path");
            });
            b2.clipPath = r2.destroy();
          }
          if (b2.stops) {
            for (h3 = 0; h3 < b2.stops.length; h3++)
              b2.stops[h3].destroy();
            b2.stops.length = 0;
            b2.stops = void 0;
          }
          b2.safeRemoveChild(d2);
          for (c2.styledMode || b2.destroyShadows(); l2 && l2.div && l2.div.childNodes.length === 0; )
            d2 = l2.parentGroup, b2.safeRemoveChild(l2.div), delete l2.div, l2 = d2;
          b2.alignTo && x(c2.alignedObjects, b2);
          v(b2, function(d3, c3) {
            b2[c3] && b2[c3].parentGroup === b2 && b2[c3].destroy && b2[c3].destroy();
            delete b2[c3];
          });
        };
        a2.prototype.destroyShadows = function() {
          (this.shadows || []).forEach(function(b2) {
            this.safeRemoveChild(b2);
          }, this);
          this.shadows = void 0;
        };
        a2.prototype.destroyTextPath = function(b2, d2) {
          var c2 = b2.getElementsByTagName("text")[0];
          if (c2) {
            if (c2.removeAttribute("dx"), c2.removeAttribute("dy"), d2.element.setAttribute("id", ""), this.textPathWrapper && c2.getElementsByTagName("textPath").length) {
              for (b2 = this.textPathWrapper.element.childNodes; b2.length; )
                c2.appendChild(b2[0]);
              c2.removeChild(this.textPathWrapper.element);
            }
          } else if (b2.getAttribute("dx") || b2.getAttribute("dy"))
            b2.removeAttribute("dx"), b2.removeAttribute("dy");
          this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());
        };
        a2.prototype.dSetter = function(b2, d2, c2) {
          h2(b2) && (typeof b2[0] === "string" && (b2 = this.renderer.pathToSegments(b2)), this.pathArray = b2, b2 = b2.reduce(function(b3, d3, c3) {
            return d3 && d3.join ? (c3 ? b3 + " " : "") + d3.join(" ") : (d3 || "").toString();
          }, ""));
          /(NaN| {2}|^$)/.test(b2) && (b2 = "M 0 0");
          this[d2] !== b2 && (c2.setAttribute(d2, b2), this[d2] = b2);
        };
        a2.prototype.fadeOut = function(b2) {
          var d2 = this;
          d2.animate({ opacity: 0 }, { duration: r(b2, 150), complete: function() {
            d2.attr({ y: -9999 }).hide();
          } });
        };
        a2.prototype.fillSetter = function(b2, d2, c2) {
          typeof b2 === "string" ? c2.setAttribute(d2, b2) : b2 && this.complexColor(b2, d2, c2);
        };
        a2.prototype.getBBox = function(d2, c2) {
          var h3 = this.alignValue, l2 = this.element, e2 = this.renderer, m2 = this.styles, v2 = this.textStr, g2 = e2.cache, G2 = e2.cacheKeys, p3 = l2.namespaceURI === this.SVG_NS;
          c2 = r(c2, this.rotation, 0);
          var q3 = e2.styledMode ? l2 && a2.prototype.getStyle.call(l2, "font-size") : m2 && m2.fontSize, D2;
          if (y(v2)) {
            var k2 = v2.toString();
            k2.indexOf("<") === -1 && (k2 = k2.replace(/[0-9]/g, "0"));
            k2 += ["", c2, q3, this.textWidth, h3, m2 && m2.textOverflow, m2 && m2.fontWeight].join();
          }
          k2 && !d2 && (D2 = g2[k2]);
          if (!D2) {
            if (p3 || e2.forExport) {
              try {
                var t2 = this.fakeTS && function(b2) {
                  var d3 = l2.querySelector(".highcharts-text-outline");
                  d3 && F(d3, { display: b2 });
                };
                b(t2) && t2("none");
                D2 = l2.getBBox ? z({}, l2.getBBox()) : {
                  width: l2.offsetWidth,
                  height: l2.offsetHeight
                };
                b(t2) && t2("");
              } catch (ha) {
              }
              if (!D2 || 0 > D2.width)
                D2 = { x: 0, y: 0, width: 0, height: 0 };
            } else
              D2 = this.htmlGetBBox();
            if (e2.isSVG && (e2 = D2.width, d2 = D2.height, p3 && (D2.height = d2 = { "11px,17": 14, "13px,20": 16 }[(q3 || "") + "," + Math.round(d2)] || d2), c2)) {
              p3 = Number(l2.getAttribute("y") || 0) - D2.y;
              h3 = { right: 1, center: 0.5 }[h3 || 0] || 0;
              m2 = c2 * u;
              q3 = (c2 - 90) * u;
              var x2 = e2 * Math.cos(m2);
              c2 = e2 * Math.sin(m2);
              t2 = Math.cos(q3);
              m2 = Math.sin(q3);
              e2 = D2.x + h3 * (e2 - x2) + p3 * t2;
              q3 = e2 + x2;
              t2 = q3 - d2 * t2;
              x2 = t2 - x2;
              p3 = D2.y + p3 - h3 * c2 + p3 * m2;
              h3 = p3 + c2;
              d2 = h3 - d2 * m2;
              c2 = d2 - c2;
              D2.x = Math.min(e2, q3, t2, x2);
              D2.y = Math.min(p3, h3, d2, c2);
              D2.width = Math.max(e2, q3, t2, x2) - D2.x;
              D2.height = Math.max(p3, h3, d2, c2) - D2.y;
            }
            if (k2 && (v2 === "" || 0 < D2.height)) {
              for (; 250 < G2.length; )
                delete g2[G2.shift()];
              g2[k2] || G2.push(k2);
              g2[k2] = D2;
            }
          }
          return D2;
        };
        a2.prototype.getStyle = function(b2) {
          return p2.getComputedStyle(this.element || this, "").getPropertyValue(b2);
        };
        a2.prototype.hasClass = function(b2) {
          return ("" + this.attr("class")).split(" ").indexOf(b2) !== -1;
        };
        a2.prototype.hide = function() {
          return this.attr({ visibility: "hidden" });
        };
        a2.prototype.htmlGetBBox = function() {
          return { height: 0, width: 0, x: 0, y: 0 };
        };
        a2.prototype.init = function(b2, d2) {
          this.element = d2 === "span" ? q2(d2) : n.createElementNS(this.SVG_NS, d2);
          this.renderer = b2;
          m(this, "afterInit");
        };
        a2.prototype.invert = function(b2) {
          this.inverted = b2;
          this.updateTransform();
          return this;
        };
        a2.prototype.on = function(b2, d2) {
          var c2 = this.onEvents;
          if (c2[b2])
            c2[b2]();
          c2[b2] = g(this.element, b2, d2);
          return this;
        };
        a2.prototype.opacitySetter = function(b2, d2, c2) {
          this.opacity = b2 = Number(Number(b2).toFixed(3));
          c2.setAttribute(d2, b2);
        };
        a2.prototype.removeClass = function(b2) {
          return this.attr("class", ("" + this.attr("class")).replace(d(b2) ? new RegExp("(^| )" + b2 + "( |$)") : b2, " ").replace(/ +/g, " ").trim());
        };
        a2.prototype.removeTextOutline = function() {
          var b2 = this.element.querySelector("tspan.highcharts-text-outline");
          b2 && this.safeRemoveChild(b2);
        };
        a2.prototype.safeRemoveChild = function(b2) {
          var d2 = b2.parentNode;
          d2 && d2.removeChild(b2);
        };
        a2.prototype.setRadialReference = function(b2) {
          var d2 = this.element.gradient && this.renderer.gradients[this.element.gradient];
          this.element.radialReference = b2;
          d2 && d2.radAttr && d2.animate(this.renderer.getRadialAttr(b2, d2.radAttr));
          return this;
        };
        a2.prototype.setTextPath = function(b2, d2) {
          var c2 = this.element, h3 = this.text ? this.text.element : c2, r2 = { textAnchor: "text-anchor" }, e2 = false, m2 = this.textPathWrapper, a3 = !m2;
          d2 = D(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, d2);
          var G2 = f2.filterUserAttributes(d2.attributes);
          if (b2 && d2 && d2.enabled) {
            m2 && m2.element.parentNode === null ? (a3 = true, m2 = m2.destroy()) : m2 && this.removeTextOutline.call(m2.parentGroup);
            this.options && this.options.padding && (G2.dx = -this.options.padding);
            m2 || (this.textPathWrapper = m2 = this.renderer.createElement("textPath"), e2 = true);
            var g2 = m2.element;
            (d2 = b2.element.getAttribute("id")) || b2.element.setAttribute("id", d2 = S());
            if (a3)
              for (h3.setAttribute("y", 0), l(G2.dx) && h3.setAttribute("x", -G2.dx), b2 = [].slice.call(h3.childNodes), a3 = 0; a3 < b2.length; a3++) {
                var q3 = b2[a3];
                q3.nodeType !== p2.Node.TEXT_NODE && q3.nodeName !== "tspan" || g2.appendChild(q3);
              }
            e2 && m2 && m2.add({ element: h3 });
            g2.setAttributeNS("http://www.w3.org/1999/xlink", "href", this.renderer.url + "#" + d2);
            y(G2.dy) && (g2.parentNode.setAttribute("dy", G2.dy), delete G2.dy);
            y(G2.dx) && (g2.parentNode.setAttribute("dx", G2.dx), delete G2.dx);
            v(G2, function(b3, d3) {
              g2.setAttribute(r2[d3] || d3, b3);
            });
            c2.removeAttribute("transform");
            this.removeTextOutline.call(m2);
            this.text && !this.renderer.styledMode && this.attr({ fill: "none", "stroke-width": 0 });
            this.applyTextOutline = this.updateTransform = k;
          } else
            m2 && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(c2, b2), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));
          return this;
        };
        a2.prototype.shadow = function(b2, d2, c2) {
          var h3 = [], l2 = this.element, J2 = this.oldShadowOptions, r2 = { color: "#000000", offsetX: this.parentInverted ? -1 : 1, offsetY: this.parentInverted ? -1 : 1, opacity: 0.15, width: 3 }, e2 = false, G2;
          b2 === true ? G2 = r2 : typeof b2 === "object" && (G2 = z(r2, b2));
          G2 && (G2 && J2 && v(G2, function(b3, d3) {
            b3 !== J2[d3] && (e2 = true);
          }), e2 && this.destroyShadows(), this.oldShadowOptions = G2);
          if (!G2)
            this.destroyShadows();
          else if (!this.shadows) {
            var m2 = G2.opacity / G2.width;
            var a3 = this.parentInverted ? "translate(" + G2.offsetY + ", " + G2.offsetX + ")" : "translate(" + G2.offsetX + ", " + G2.offsetY + ")";
            for (r2 = 1; r2 <= G2.width; r2++) {
              var g2 = l2.cloneNode(false);
              var p3 = 2 * G2.width + 1 - 2 * r2;
              t(g2, { stroke: b2.color || "#000000", "stroke-opacity": m2 * r2, "stroke-width": p3, transform: a3, fill: "none" });
              g2.setAttribute("class", (g2.getAttribute("class") || "") + " highcharts-shadow");
              c2 && (t(g2, "height", Math.max(t(g2, "height") - p3, 0)), g2.cutHeight = p3);
              d2 ? d2.element.appendChild(g2) : l2.parentNode && l2.parentNode.insertBefore(g2, l2);
              h3.push(g2);
            }
            this.shadows = h3;
          }
          return this;
        };
        a2.prototype.show = function(b2) {
          b2 === void 0 && (b2 = true);
          return this.attr({ visibility: b2 ? "inherit" : "visible" });
        };
        a2.prototype.strokeSetter = function(b2, d2, c2) {
          this[d2] = b2;
          this.stroke && this["stroke-width"] ? (a2.prototype.fillSetter.call(this, this.stroke, "stroke", c2), c2.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = true) : d2 === "stroke-width" && b2 === 0 && this.hasStroke ? (c2.removeAttribute("stroke"), this.hasStroke = false) : this.renderer.styledMode && this["stroke-width"] && (c2.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = true);
        };
        a2.prototype.strokeWidth = function() {
          if (!this.renderer.styledMode)
            return this["stroke-width"] || 0;
          var b2 = this.getStyle("stroke-width"), d2 = 0;
          if (b2.indexOf("px") === b2.length - 2)
            d2 = O(b2);
          else if (b2 !== "") {
            var h3 = n.createElementNS(c, "rect");
            t(h3, { width: b2, "stroke-width": 0 });
            this.element.parentNode.appendChild(h3);
            d2 = h3.getBBox().width;
            h3.parentNode.removeChild(h3);
          }
          return d2;
        };
        a2.prototype.symbolAttr = function(b2) {
          var d2 = this;
          "x y r start end width height innerR anchorX anchorY clockwise".split(" ").forEach(function(c2) {
            d2[c2] = r(b2[c2], d2[c2]);
          });
          d2.attr({ d: d2.renderer.symbols[d2.symbolName](d2.x, d2.y, d2.width, d2.height, d2) });
        };
        a2.prototype.textSetter = function(b2) {
          b2 !== this.textStr && (delete this.textPxLength, this.textStr = b2, this.added && this.renderer.buildText(this));
        };
        a2.prototype.titleSetter = function(b2) {
          var d2 = this.element, c2 = d2.getElementsByTagName("title")[0] || n.createElementNS(this.SVG_NS, "title");
          d2.insertBefore ? d2.insertBefore(c2, d2.firstChild) : d2.appendChild(c2);
          c2.textContent = String(r(b2, "")).replace(/<[^>]*>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        };
        a2.prototype.toFront = function() {
          var b2 = this.element;
          b2.parentNode.appendChild(b2);
          return this;
        };
        a2.prototype.translate = function(b2, d2) {
          return this.attr({
            translateX: b2,
            translateY: d2
          });
        };
        a2.prototype.updateShadows = function(b2, d2, c2) {
          var h3 = this.shadows;
          if (h3)
            for (var l2 = h3.length; l2--; )
              c2.call(h3[l2], b2 === "height" ? Math.max(d2 - (h3[l2].cutHeight || 0), 0) : b2 === "d" ? this.d : d2, b2, h3[l2]);
        };
        a2.prototype.updateTransform = function() {
          var b2 = this.scaleX, d2 = this.scaleY, c2 = this.inverted, h3 = this.rotation, l2 = this.matrix, e2 = this.element, m2 = this.translateX || 0, a3 = this.translateY || 0;
          c2 && (m2 += this.width, a3 += this.height);
          m2 = ["translate(" + m2 + "," + a3 + ")"];
          y(l2) && m2.push("matrix(" + l2.join(",") + ")");
          c2 ? m2.push("rotate(90) scale(-1,1)") : h3 && m2.push("rotate(" + h3 + " " + r(this.rotationOriginX, e2.getAttribute("x"), 0) + " " + r(this.rotationOriginY, e2.getAttribute("y") || 0) + ")");
          (y(b2) || y(d2)) && m2.push("scale(" + r(b2, 1) + " " + r(d2, 1) + ")");
          m2.length && e2.setAttribute("transform", m2.join(" "));
        };
        a2.prototype.visibilitySetter = function(b2, d2, c2) {
          b2 === "inherit" ? c2.removeAttribute(d2) : this[d2] !== b2 && c2.setAttribute(d2, b2);
          this[d2] = b2;
        };
        a2.prototype.xGetter = function(b2) {
          this.element.nodeName === "circle" && (b2 === "x" ? b2 = "cx" : b2 === "y" && (b2 = "cy"));
          return this._defaultGetter(b2);
        };
        a2.prototype.zIndexSetter = function(b2, d2) {
          var c2 = this.renderer, h3 = this.parentGroup, l2 = (h3 || c2).element || c2.box, r2 = this.element;
          c2 = l2 === c2.box;
          var e2 = false;
          var m2 = this.added;
          var G2;
          y(b2) ? (r2.setAttribute("data-z-index", b2), b2 = +b2, this[d2] === b2 && (m2 = false)) : y(this[d2]) && r2.removeAttribute("data-z-index");
          this[d2] = b2;
          if (m2) {
            (b2 = this.zIndex) && h3 && (h3.handleZ = true);
            d2 = l2.childNodes;
            for (G2 = d2.length - 1; 0 <= G2 && !e2; G2--) {
              h3 = d2[G2];
              m2 = h3.getAttribute("data-z-index");
              var a3 = !y(m2);
              if (h3 !== r2) {
                if (0 > b2 && a3 && !c2 && !G2)
                  l2.insertBefore(r2, d2[G2]), e2 = true;
                else if (O(m2) <= b2 || a3 && (!y(b2) || 0 <= b2))
                  l2.insertBefore(r2, d2[G2 + 1] || null), e2 = true;
              }
            }
            e2 || (l2.insertBefore(r2, d2[c2 ? 3 : 0] || null), e2 = true);
          }
          return e2;
        };
        return a2;
      }();
      a.prototype["stroke-widthSetter"] = a.prototype.strokeSetter;
      a.prototype.yGetter = a.prototype.xGetter;
      a.prototype.matrixSetter = a.prototype.rotationOriginXSetter = a.prototype.rotationOriginYSetter = a.prototype.rotationSetter = a.prototype.scaleXSetter = a.prototype.scaleYSetter = a.prototype.translateXSetter = a.prototype.translateYSetter = a.prototype.verticalAlignSetter = function(b2, d2) {
        this[d2] = b2;
        this.doTransform = true;
      };
      return a;
    });
    K2(f, "Core/Renderer/RendererRegistry.js", [f["Core/Globals.js"]], function(a) {
      var f2;
      (function(f3) {
        f3.rendererTypes = {};
        var C2;
        f3.getRendererType = function(a2) {
          a2 === void 0 && (a2 = C2);
          return f3.rendererTypes[a2] || f3.rendererTypes[C2];
        };
        f3.registerRendererType = function(w, B2, I2) {
          f3.rendererTypes[w] = B2;
          if (!C2 || I2)
            C2 = w, a.Renderer = B2;
        };
      })(f2 || (f2 = {}));
      return f2;
    });
    K2(f, "Core/Renderer/SVG/SVGLabel.js", [f["Core/Renderer/SVG/SVGElement.js"], f["Core/Utilities.js"]], function(a, f2) {
      var C2 = this && this.__extends || function() {
        var a2 = function(k, e) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, e2) {
            c.__proto__ = e2;
          } || function(c, e2) {
            for (var a3 in e2)
              e2.hasOwnProperty(a3) && (c[a3] = e2[a3]);
          };
          return a2(k, e);
        };
        return function(k, e) {
          function c() {
            this.constructor = k;
          }
          a2(k, e);
          k.prototype = e === null ? Object.create(e) : (c.prototype = e.prototype, new c());
        };
      }(), H2 = f2.defined, w = f2.extend, E2 = f2.isNumber, I2 = f2.merge, A = f2.pick, u = f2.removeEvent;
      return function(n) {
        function k(e, c, a2, g, t, q2, F, y, x, z) {
          var m = n.call(this) || this;
          m.paddingLeftSetter = m.paddingSetter;
          m.paddingRightSetter = m.paddingSetter;
          m.init(e, "g");
          m.textStr = c;
          m.x = a2;
          m.y = g;
          m.anchorX = q2;
          m.anchorY = F;
          m.baseline = x;
          m.className = z;
          m.addClass(z === "button" ? "highcharts-no-tooltip" : "highcharts-label");
          z && m.addClass("highcharts-" + z);
          m.text = e.text(void 0, 0, 0, y).attr({ zIndex: 1 });
          var h2;
          typeof t === "string" && ((h2 = /^url\((.*?)\)$/.test(t)) || m.renderer.symbols[t]) && (m.symbolKey = t);
          m.bBox = k.emptyBBox;
          m.padding = 3;
          m.baselineOffset = 0;
          m.needsBox = e.styledMode || h2;
          m.deferredAttr = {};
          m.alignFactor = 0;
          return m;
        }
        C2(k, n);
        k.prototype.alignSetter = function(e) {
          e = {
            left: 0,
            center: 0.5,
            right: 1
          }[e];
          e !== this.alignFactor && (this.alignFactor = e, this.bBox && E2(this.xSetting) && this.attr({ x: this.xSetting }));
        };
        k.prototype.anchorXSetter = function(e, c) {
          this.anchorX = e;
          this.boxAttr(c, Math.round(e) - this.getCrispAdjust() - this.xSetting);
        };
        k.prototype.anchorYSetter = function(e, c) {
          this.anchorY = e;
          this.boxAttr(c, e - this.ySetting);
        };
        k.prototype.boxAttr = function(e, c) {
          this.box ? this.box.attr(e, c) : this.deferredAttr[e] = c;
        };
        k.prototype.css = function(e) {
          if (e) {
            var c = {};
            e = I2(e);
            k.textProps.forEach(function(a2) {
              typeof e[a2] !== "undefined" && (c[a2] = e[a2], delete e[a2]);
            });
            this.text.css(c);
            var p2 = "width" in c;
            "fontSize" in c || "fontWeight" in c ? this.updateTextPadding() : p2 && this.updateBoxSize();
          }
          return a.prototype.css.call(this, e);
        };
        k.prototype.destroy = function() {
          u(this.element, "mouseenter");
          u(this.element, "mouseleave");
          this.text && this.text.destroy();
          this.box && (this.box = this.box.destroy());
          a.prototype.destroy.call(this);
        };
        k.prototype.fillSetter = function(e, c) {
          e && (this.needsBox = true);
          this.fill = e;
          this.boxAttr(c, e);
        };
        k.prototype.getBBox = function() {
          this.textStr && this.bBox.width === 0 && this.bBox.height === 0 && this.updateBoxSize();
          var e = this.padding, c = A(this.paddingLeft, e);
          return { width: this.width, height: this.height, x: this.bBox.x - c, y: this.bBox.y - e };
        };
        k.prototype.getCrispAdjust = function() {
          return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this["stroke-width"] ? parseInt(this["stroke-width"], 10) : 0) % 2 / 2;
        };
        k.prototype.heightSetter = function(e) {
          this.heightSetting = e;
        };
        k.prototype.onAdd = function() {
          var e = this.textStr;
          this.text.add(this);
          this.attr({ text: H2(e) ? e : "", x: this.x, y: this.y });
          this.box && H2(this.anchorX) && this.attr({ anchorX: this.anchorX, anchorY: this.anchorY });
        };
        k.prototype.paddingSetter = function(e, c) {
          E2(e) ? e !== this[c] && (this[c] = e, this.updateTextPadding()) : this[c] = void 0;
        };
        k.prototype.rSetter = function(e, c) {
          this.boxAttr(c, e);
        };
        k.prototype.shadow = function(e) {
          e && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(e));
          return this;
        };
        k.prototype.strokeSetter = function(e, c) {
          this.stroke = e;
          this.boxAttr(c, e);
        };
        k.prototype["stroke-widthSetter"] = function(e, c) {
          e && (this.needsBox = true);
          this["stroke-width"] = e;
          this.boxAttr(c, e);
        };
        k.prototype["text-alignSetter"] = function(e) {
          this.textAlign = e;
        };
        k.prototype.textSetter = function(e) {
          typeof e !== "undefined" && this.text.attr({ text: e });
          this.updateTextPadding();
        };
        k.prototype.updateBoxSize = function() {
          var e = this.text.element.style, c = {}, a2 = this.padding, g = this.bBox = E2(this.widthSetting) && E2(this.heightSetting) && !this.textAlign || !H2(this.text.textStr) ? k.emptyBBox : this.text.getBBox();
          this.width = this.getPaddedWidth();
          this.height = (this.heightSetting || g.height || 0) + 2 * a2;
          e = this.renderer.fontMetrics(e && e.fontSize, this.text);
          this.baselineOffset = a2 + Math.min((this.text.firstLineMetrics || e).b, g.height || Infinity);
          this.heightSetting && (this.baselineOffset += (this.heightSetting - e.h) / 2);
          this.needsBox && (this.box || (a2 = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a2.addClass((this.className === "button" ? "" : "highcharts-label-box") + (this.className ? " highcharts-" + this.className + "-box" : "")), a2.add(this)), a2 = this.getCrispAdjust(), c.x = a2, c.y = (this.baseline ? -this.baselineOffset : 0) + a2, c.width = Math.round(this.width), c.height = Math.round(this.height), this.box.attr(w(c, this.deferredAttr)), this.deferredAttr = {});
        };
        k.prototype.updateTextPadding = function() {
          var e = this.text;
          this.updateBoxSize();
          var c = this.baseline ? 0 : this.baselineOffset, a2 = A(this.paddingLeft, this.padding);
          H2(this.widthSetting) && this.bBox && (this.textAlign === "center" || this.textAlign === "right") && (a2 += { center: 0.5, right: 1 }[this.textAlign] * (this.widthSetting - this.bBox.width));
          if (a2 !== e.x || c !== e.y)
            e.attr("x", a2), e.hasBoxWidthChanged && (this.bBox = e.getBBox(true)), typeof c !== "undefined" && e.attr("y", c);
          e.x = a2;
          e.y = c;
        };
        k.prototype.widthSetter = function(e) {
          this.widthSetting = E2(e) ? e : void 0;
        };
        k.prototype.getPaddedWidth = function() {
          var e = this.padding, c = A(this.paddingLeft, e);
          e = A(this.paddingRight, e);
          return (this.widthSetting || this.bBox.width || 0) + c + e;
        };
        k.prototype.xSetter = function(e) {
          this.x = e;
          this.alignFactor && (e -= this.alignFactor * this.getPaddedWidth(), this["forceAnimate:x"] = true);
          this.xSetting = Math.round(e);
          this.attr("translateX", this.xSetting);
        };
        k.prototype.ySetter = function(e) {
          this.ySetting = this.y = Math.round(e);
          this.attr("translateY", this.ySetting);
        };
        k.emptyBBox = { width: 0, height: 0, x: 0, y: 0 };
        k.textProps = "color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width".split(" ");
        return k;
      }(a);
    });
    K2(f, "Core/Renderer/SVG/Symbols.js", [f["Core/Utilities.js"]], function(a) {
      function f2(a2, f3, n, k, e) {
        var c = [];
        if (e) {
          var p2 = e.start || 0, g = I2(e.r, n);
          n = I2(e.r, k || n);
          var t = (e.end || 0) - 1e-3;
          k = e.innerR;
          var q2 = I2(e.open, 1e-3 > Math.abs((e.end || 0) - p2 - 2 * Math.PI)), F = Math.cos(p2), y = Math.sin(p2), x = Math.cos(t), z = Math.sin(t);
          p2 = I2(e.longArc, 1e-3 > t - p2 - Math.PI ? 0 : 1);
          c.push(["M", a2 + g * F, f3 + n * y], ["A", g, n, 0, p2, I2(e.clockwise, 1), a2 + g * x, f3 + n * z]);
          w(k) && c.push(q2 ? ["M", a2 + k * x, f3 + k * z] : ["L", a2 + k * x, f3 + k * z], ["A", k, k, 0, p2, w(e.clockwise) ? 1 - e.clockwise : 0, a2 + k * F, f3 + k * y]);
          q2 || c.push(["Z"]);
        }
        return c;
      }
      function B2(a2, f3, n, k, e) {
        return e && e.r ? H2(a2, f3, n, k, e) : [["M", a2, f3], ["L", a2 + n, f3], ["L", a2 + n, f3 + k], ["L", a2, f3 + k], ["Z"]];
      }
      function H2(a2, f3, n, k, e) {
        e = e && e.r || 0;
        return [["M", a2 + e, f3], ["L", a2 + n - e, f3], ["C", a2 + n, f3, a2 + n, f3, a2 + n, f3 + e], ["L", a2 + n, f3 + k - e], ["C", a2 + n, f3 + k, a2 + n, f3 + k, a2 + n - e, f3 + k], ["L", a2 + e, f3 + k], ["C", a2, f3 + k, a2, f3 + k, a2, f3 + k - e], ["L", a2, f3 + e], ["C", a2, f3, a2, f3, a2 + e, f3]];
      }
      var w = a.defined, E2 = a.isNumber, I2 = a.pick;
      return { arc: f2, callout: function(a2, f3, n, k, e) {
        var c = Math.min(e && e.r || 0, n, k), p2 = c + 6, g = e && e.anchorX;
        e = e && e.anchorY || 0;
        var t = H2(a2, f3, n, k, { r: c });
        if (!E2(g))
          return t;
        a2 + g >= n ? e > f3 + p2 && e < f3 + k - p2 ? t.splice(3, 1, ["L", a2 + n, e - 6], ["L", a2 + n + 6, e], ["L", a2 + n, e + 6], ["L", a2 + n, f3 + k - c]) : t.splice(3, 1, ["L", a2 + n, k / 2], ["L", g, e], ["L", a2 + n, k / 2], ["L", a2 + n, f3 + k - c]) : 0 >= a2 + g ? e > f3 + p2 && e < f3 + k - p2 ? t.splice(7, 1, ["L", a2, e + 6], ["L", a2 - 6, e], ["L", a2, e - 6], ["L", a2, f3 + c]) : t.splice(7, 1, ["L", a2, k / 2], ["L", g, e], ["L", a2, k / 2], ["L", a2, f3 + c]) : e && e > k && g > a2 + p2 && g < a2 + n - p2 ? t.splice(5, 1, ["L", g + 6, f3 + k], ["L", g, f3 + k + 6], ["L", g - 6, f3 + k], ["L", a2 + c, f3 + k]) : e && 0 > e && g > a2 + p2 && g < a2 + n - p2 && t.splice(1, 1, ["L", g - 6, f3], ["L", g, f3 - 6], ["L", g + 6, f3], ["L", n - c, f3]);
        return t;
      }, circle: function(a2, u, n, k) {
        return f2(a2 + n / 2, u + k / 2, n / 2, k / 2, { start: 0.5 * Math.PI, end: 2.5 * Math.PI, open: false });
      }, diamond: function(a2, f3, n, k) {
        return [[
          "M",
          a2 + n / 2,
          f3
        ], ["L", a2 + n, f3 + k / 2], ["L", a2 + n / 2, f3 + k], ["L", a2, f3 + k / 2], ["Z"]];
      }, rect: B2, roundedRect: H2, square: B2, triangle: function(a2, f3, n, k) {
        return [["M", a2 + n / 2, f3], ["L", a2 + n, f3 + k], ["L", a2, f3 + k], ["Z"]];
      }, "triangle-down": function(a2, f3, n, k) {
        return [["M", a2, f3], ["L", a2 + n, f3], ["L", a2 + n / 2, f3 + k], ["Z"]];
      } };
    });
    K2(f, "Core/Renderer/SVG/TextBuilder.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = f2.doc, w = f2.SVG_NS, E2 = f2.win, I2 = B2.attr, A = B2.extend, u = B2.isString, n = B2.objectEach, k = B2.pick;
      return function() {
        function e(c) {
          var a2 = c.styles;
          this.renderer = c.renderer;
          this.svgElement = c;
          this.width = c.textWidth;
          this.textLineHeight = a2 && a2.lineHeight;
          this.textOutline = a2 && a2.textOutline;
          this.ellipsis = !(!a2 || a2.textOverflow !== "ellipsis");
          this.noWrap = !(!a2 || a2.whiteSpace !== "nowrap");
          this.fontSize = a2 && a2.fontSize;
        }
        e.prototype.buildSVG = function() {
          var c = this.svgElement, e2 = c.element, g = c.renderer, t = k(c.textStr, "").toString(), q2 = t.indexOf("<") !== -1, f3 = e2.childNodes;
          g = this.width && !c.added && g.box;
          var y = /<br.*?>/g, x = [
            t,
            this.ellipsis,
            this.noWrap,
            this.textLineHeight,
            this.textOutline,
            this.fontSize,
            this.width
          ].join();
          if (x !== c.textCache) {
            c.textCache = x;
            delete c.actualWidth;
            for (x = f3.length; x--; )
              e2.removeChild(f3[x]);
            q2 || this.ellipsis || this.width || t.indexOf(" ") !== -1 && (!this.noWrap || y.test(t)) ? t !== "" && (g && g.appendChild(e2), t = new a(t), this.modifyTree(t.nodes), t.addToDOM(c.element), this.modifyDOM(), this.ellipsis && (e2.textContent || "").indexOf("\u2026") !== -1 && c.attr("title", this.unescapeEntities(c.textStr || "", ["&lt;", "&gt;"])), g && g.removeChild(e2)) : e2.appendChild(C2.createTextNode(this.unescapeEntities(t)));
            u(this.textOutline) && c.applyTextOutline && c.applyTextOutline(this.textOutline);
          }
        };
        e.prototype.modifyDOM = function() {
          var c = this, a2 = this.svgElement, e2 = I2(a2.element, "x");
          a2.firstLineMetrics = void 0;
          for (var k2; k2 = a2.element.firstChild; )
            if (/^[\s\u200B]*$/.test(k2.textContent || " "))
              a2.element.removeChild(k2);
            else
              break;
          [].forEach.call(a2.element.querySelectorAll("tspan.highcharts-br"), function(g, q3) {
            g.nextSibling && g.previousSibling && (q3 === 0 && g.previousSibling.nodeType === 1 && (a2.firstLineMetrics = a2.renderer.fontMetrics(void 0, g.previousSibling)), I2(g, { dy: c.getLineHeight(g.nextSibling), x: e2 }));
          });
          var q2 = this.width || 0;
          if (q2) {
            var f3 = function(g, k3) {
              var m = g.textContent || "", h2 = m.replace(/([^\^])-/g, "$1- ").split(" "), b = !c.noWrap && (1 < h2.length || 1 < a2.element.childNodes.length), l = c.getLineHeight(k3), d = 0, D = a2.actualWidth;
              if (c.ellipsis)
                m && c.truncate(g, m, void 0, 0, Math.max(0, q2 - parseInt(c.fontSize || 12, 10)), function(b2, d2) {
                  return b2.substring(0, d2) + "\u2026";
                });
              else if (b) {
                m = [];
                for (b = []; k3.firstChild && k3.firstChild !== g; )
                  b.push(k3.firstChild), k3.removeChild(k3.firstChild);
                for (; h2.length; )
                  h2.length && !c.noWrap && 0 < d && (m.push(g.textContent || ""), g.textContent = h2.join(" ").replace(/- /g, "-")), c.truncate(g, void 0, h2, d === 0 ? D || 0 : 0, q2, function(b2, d2) {
                    return h2.slice(0, d2).join(" ").replace(/- /g, "-");
                  }), D = a2.actualWidth, d++;
                b.forEach(function(b2) {
                  k3.insertBefore(b2, g);
                });
                m.forEach(function(b2) {
                  k3.insertBefore(C2.createTextNode(b2), g);
                  b2 = C2.createElementNS(w, "tspan");
                  b2.textContent = "\u200B";
                  I2(b2, { dy: l, x: e2 });
                  k3.insertBefore(b2, g);
                });
              }
            }, y = function(c2) {
              [].slice.call(c2.childNodes).forEach(function(e3) {
                e3.nodeType === E2.Node.TEXT_NODE ? f3(e3, c2) : (e3.className.baseVal.indexOf("highcharts-br") !== -1 && (a2.actualWidth = 0), y(e3));
              });
            };
            y(a2.element);
          }
        };
        e.prototype.getLineHeight = function(c) {
          var a2;
          c = c.nodeType === E2.Node.TEXT_NODE ? c.parentElement : c;
          this.renderer.styledMode || (a2 = c && /(px|em)$/.test(c.style.fontSize) ? c.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);
          return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(a2, c || this.svgElement.element).h;
        };
        e.prototype.modifyTree = function(c) {
          var a2 = this, e2 = function(g, q2) {
            var k2 = g.attributes;
            k2 = k2 === void 0 ? {} : k2;
            var p2 = g.children, t = g.style;
            t = t === void 0 ? {} : t;
            var f3 = g.tagName, m = a2.renderer.styledMode;
            if (f3 === "b" || f3 === "strong")
              m ? k2["class"] = "highcharts-strong" : t.fontWeight = "bold";
            else if (f3 === "i" || f3 === "em")
              m ? k2["class"] = "highcharts-emphasized" : t.fontStyle = "italic";
            t && t.color && (t.fill = t.color);
            f3 === "br" ? (k2["class"] = "highcharts-br", g.textContent = "\u200B", (q2 = c[q2 + 1]) && q2.textContent && (q2.textContent = q2.textContent.replace(/^ +/gm, ""))) : f3 === "a" && p2 && p2.some(function(c2) {
              return c2.tagName === "#text";
            }) && (g.children = [{ children: p2, tagName: "tspan" }]);
            f3 !== "#text" && f3 !== "a" && (g.tagName = "tspan");
            A(g, { attributes: k2, style: t });
            p2 && p2.filter(function(c2) {
              return c2.tagName !== "#text";
            }).forEach(e2);
          };
          c.forEach(e2);
        };
        e.prototype.truncate = function(c, a2, e2, k2, q2, f3) {
          var g = this.svgElement, p2 = g.renderer, t = g.rotation, m = [], h2 = e2 ? 1 : 0, b = (a2 || e2 || "").length, l = b, d, D = function(b2, d2) {
            d2 = d2 || b2;
            var h3 = c.parentNode;
            if (h3 && typeof m[d2] === "undefined")
              if (h3.getSubStringLength)
                try {
                  m[d2] = k2 + h3.getSubStringLength(0, e2 ? d2 + 1 : d2);
                } catch (S) {
                }
              else
                p2.getSpanWidth && (c.textContent = f3(a2 || e2, b2), m[d2] = k2 + p2.getSpanWidth(g, c));
            return m[d2];
          };
          g.rotation = 0;
          var v = D(c.textContent.length);
          if (k2 + v > q2) {
            for (; h2 <= b; )
              l = Math.ceil((h2 + b) / 2), e2 && (d = f3(e2, l)), v = D(l, d && d.length - 1), h2 === b ? h2 = b + 1 : v > q2 ? b = l - 1 : h2 = l;
            b === 0 ? c.textContent = "" : a2 && b === a2.length - 1 || (c.textContent = d || f3(a2 || e2, l));
          }
          e2 && e2.splice(0, l);
          g.actualWidth = v;
          g.rotation = t;
        };
        e.prototype.unescapeEntities = function(c, a2) {
          n(this.renderer.escapes, function(e2, k2) {
            a2 && a2.indexOf(e2) !== -1 || (c = c.toString().replace(new RegExp(e2, "g"), k2));
          });
          return c;
        };
        return e;
      }();
    });
    K2(f, "Core/Renderer/SVG/SVGRenderer.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Renderer/SVG/SVGLabel.js"], f["Core/Renderer/SVG/Symbols.js"], f["Core/Renderer/SVG/TextBuilder.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2, w, E2, I2, A, u) {
      var n = B2.charts, k = B2.deg2rad, e = B2.doc, c = B2.isFirefox, p2 = B2.isMS, g = B2.isWebKit, t = B2.noop, q2 = B2.SVG_NS, F = B2.symbolSizes, y = B2.win, x = u.addEvent, z = u.attr, m = u.createElement, h2 = u.css, b = u.defined, l = u.destroyObjectProperties, d = u.extend, D = u.isArray, v = u.isNumber, r = u.isObject, O = u.isString, P2 = u.merge, S = u.pick, N2 = u.pInt, C2 = u.uniqueKey, X2;
      B2 = function() {
        function J2(b2, d2, c2, h3, a2, e2, l2) {
          this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;
          this.init(b2, d2, c2, h3, a2, e2, l2);
        }
        J2.prototype.init = function(b2, d2, a2, l2, r2, m2, J3) {
          var G2 = this.createElement("svg").attr({
            version: "1.1",
            "class": "highcharts-root"
          }), L = G2.element;
          J3 || G2.css(this.getStyle(l2));
          b2.appendChild(L);
          z(b2, "dir", "ltr");
          b2.innerHTML.indexOf("xmlns") === -1 && z(L, "xmlns", this.SVG_NS);
          this.isSVG = true;
          this.box = L;
          this.boxWrapper = G2;
          this.alignedObjects = [];
          this.url = this.getReferenceURL();
          this.createElement("desc").add().element.appendChild(e.createTextNode("Created with Highcharts 10.1.0"));
          this.defs = this.createElement("defs").add();
          this.allowHTML = m2;
          this.forExport = r2;
          this.styledMode = J3;
          this.gradients = {};
          this.cache = {};
          this.cacheKeys = [];
          this.imgCount = 0;
          this.setSize(d2, a2, false);
          var g2;
          c && b2.getBoundingClientRect && (d2 = function() {
            h2(b2, { left: 0, top: 0 });
            g2 = b2.getBoundingClientRect();
            h2(b2, { left: Math.ceil(g2.left) - g2.left + "px", top: Math.ceil(g2.top) - g2.top + "px" });
          }, d2(), this.unSubPixelFix = x(y, "resize", d2));
        };
        J2.prototype.definition = function(b2) {
          return new a([b2]).addToDOM(this.defs.element);
        };
        J2.prototype.getReferenceURL = function() {
          if ((c || g) && e.getElementsByTagName("base").length) {
            if (!b(X2)) {
              var d2 = C2();
              d2 = new a([{ tagName: "svg", attributes: { width: 8, height: 8 }, children: [{
                tagName: "defs",
                children: [{ tagName: "clipPath", attributes: { id: d2 }, children: [{ tagName: "rect", attributes: { width: 4, height: 4 } }] }]
              }, { tagName: "rect", attributes: { id: "hitme", width: 8, height: 8, "clip-path": "url(#" + d2 + ")", fill: "rgba(0,0,0,0.001)" } }] }]).addToDOM(e.body);
              h2(d2, { position: "fixed", top: 0, left: 0, zIndex: 9e5 });
              var l2 = e.elementFromPoint(6, 6);
              X2 = (l2 && l2.id) === "hitme";
              e.body.removeChild(d2);
            }
            if (X2)
              return y.location.href.split("#")[0].replace(/<[^>]*>/g, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20");
          }
          return "";
        };
        J2.prototype.getStyle = function(b2) {
          return this.style = d({ fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize: "12px" }, b2);
        };
        J2.prototype.setStyle = function(b2) {
          this.boxWrapper.css(this.getStyle(b2));
        };
        J2.prototype.isHidden = function() {
          return !this.boxWrapper.getBBox().width;
        };
        J2.prototype.destroy = function() {
          var b2 = this.defs;
          this.box = null;
          this.boxWrapper = this.boxWrapper.destroy();
          l(this.gradients || {});
          this.gradients = null;
          b2 && (this.defs = b2.destroy());
          this.unSubPixelFix && this.unSubPixelFix();
          return this.alignedObjects = null;
        };
        J2.prototype.createElement = function(b2) {
          var d2 = new this.Element();
          d2.init(this, b2);
          return d2;
        };
        J2.prototype.getRadialAttr = function(b2, d2) {
          return { cx: b2[0] - b2[2] / 2 + (d2.cx || 0) * b2[2], cy: b2[1] - b2[2] / 2 + (d2.cy || 0) * b2[2], r: (d2.r || 0) * b2[2] };
        };
        J2.prototype.buildText = function(b2) {
          new A(b2).buildSVG();
        };
        J2.prototype.getContrast = function(b2) {
          b2 = f2.parse(b2).rgba;
          b2[0] *= 1;
          b2[1] *= 1.2;
          b2[2] *= 0.5;
          return 459 < b2[0] + b2[1] + b2[2] ? "#000000" : "#FFFFFF";
        };
        J2.prototype.button = function(b2, c2, h3, l2, e2, m2, J3, g2, v2, q3) {
          var G2 = this.label(b2, c2, h3, v2, void 0, void 0, q3, void 0, "button"), D2 = this.styledMode;
          b2 = e2 && e2.states || {};
          e2 && delete e2.states;
          var L = 0, k2 = e2 ? P2(e2) : {}, f3 = P2({ color: "#333333", cursor: "pointer", fontWeight: "normal" }, k2.style);
          delete k2.style;
          k2 = a.filterUserAttributes(k2);
          G2.attr(P2({ padding: 8, r: 2 }, k2));
          if (!D2) {
            k2 = P2({ fill: "#f7f7f7", stroke: "#cccccc", "stroke-width": 1 }, k2);
            m2 = P2(k2, { fill: "#e6e6e6" }, a.filterUserAttributes(m2 || b2.hover || {}));
            var t2 = m2.style;
            delete m2.style;
            J3 = P2(k2, { fill: "#e6ebf5", style: { color: "#000000", fontWeight: "bold" } }, a.filterUserAttributes(J3 || b2.select || {}));
            var M = J3.style;
            delete J3.style;
            g2 = P2(k2, { style: { color: "#cccccc" } }, a.filterUserAttributes(g2 || b2.disabled || {}));
            var y2 = g2.style;
            delete g2.style;
          }
          x(G2.element, p2 ? "mouseover" : "mouseenter", function() {
            L !== 3 && G2.setState(1);
          });
          x(G2.element, p2 ? "mouseout" : "mouseleave", function() {
            L !== 3 && G2.setState(L);
          });
          G2.setState = function(b3) {
            b3 !== 1 && (G2.state = L = b3);
            G2.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass("highcharts-button-" + ["normal", "hover", "pressed", "disabled"][b3 || 0]);
            D2 || (G2.attr([k2, m2, J3, g2][b3 || 0]), b3 = [f3, t2, M, y2][b3 || 0], r(b3) && G2.css(b3));
          };
          D2 || G2.attr(k2).css(d({ cursor: "default" }, f3));
          return G2.on("touchstart", function(b3) {
            return b3.stopPropagation();
          }).on("click", function(b3) {
            L !== 3 && l2.call(G2, b3);
          });
        };
        J2.prototype.crispLine = function(d2, c2, h3) {
          h3 === void 0 && (h3 = "round");
          var a2 = d2[0], e2 = d2[1];
          b(a2[1]) && a2[1] === e2[1] && (a2[1] = e2[1] = Math[h3](a2[1]) - c2 % 2 / 2);
          b(a2[2]) && a2[2] === e2[2] && (a2[2] = e2[2] = Math[h3](a2[2]) + c2 % 2 / 2);
          return d2;
        };
        J2.prototype.path = function(b2) {
          var c2 = this.styledMode ? {} : { fill: "none" };
          D(b2) ? c2.d = b2 : r(b2) && d(c2, b2);
          return this.createElement("path").attr(c2);
        };
        J2.prototype.circle = function(b2, d2, c2) {
          b2 = r(b2) ? b2 : typeof b2 === "undefined" ? {} : { x: b2, y: d2, r: c2 };
          d2 = this.createElement("circle");
          d2.xSetter = d2.ySetter = function(b3, d3, c3) {
            c3.setAttribute("c" + d3, b3);
          };
          return d2.attr(b2);
        };
        J2.prototype.arc = function(b2, d2, c2, a2, h3, e2) {
          r(b2) ? (a2 = b2, d2 = a2.y, c2 = a2.r, b2 = a2.x) : a2 = { innerR: a2, start: h3, end: e2 };
          b2 = this.symbol("arc", b2, d2, c2, c2, a2);
          b2.r = c2;
          return b2;
        };
        J2.prototype.rect = function(b2, d2, c2, a2, h3, e2) {
          h3 = r(b2) ? b2.r : h3;
          var l2 = this.createElement("rect");
          b2 = r(b2) ? b2 : typeof b2 === "undefined" ? {} : { x: b2, y: d2, width: Math.max(c2, 0), height: Math.max(a2, 0) };
          this.styledMode || (typeof e2 !== "undefined" && (b2["stroke-width"] = e2, b2 = l2.crisp(b2)), b2.fill = "none");
          h3 && (b2.r = h3);
          l2.rSetter = function(b3, d3, c3) {
            l2.r = b3;
            z(c3, { rx: b3, ry: b3 });
          };
          l2.rGetter = function() {
            return l2.r || 0;
          };
          return l2.attr(b2);
        };
        J2.prototype.setSize = function(b2, d2, c2) {
          this.width = b2;
          this.height = d2;
          this.boxWrapper.animate({ width: b2, height: d2 }, { step: function() {
            this.attr({ viewBox: "0 0 " + this.attr("width") + " " + this.attr("height") });
          }, duration: S(c2, true) ? void 0 : 0 });
          this.alignElements();
        };
        J2.prototype.g = function(b2) {
          var d2 = this.createElement("g");
          return b2 ? d2.attr({ "class": "highcharts-" + b2 }) : d2;
        };
        J2.prototype.image = function(b2, d2, c2, a2, h3, e2) {
          var l2 = { preserveAspectRatio: "none" }, r2 = function(b3, d3) {
            b3.setAttributeNS ? b3.setAttributeNS("http://www.w3.org/1999/xlink", "href", d3) : b3.setAttribute("hc-svg-href", d3);
          };
          v(d2) && (l2.x = d2);
          v(c2) && (l2.y = c2);
          v(a2) && (l2.width = a2);
          v(h3) && (l2.height = h3);
          var m2 = this.createElement("image").attr(l2);
          d2 = function(d3) {
            r2(m2.element, b2);
            e2.call(m2, d3);
          };
          e2 ? (r2(m2.element, "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="), c2 = new y.Image(), x(c2, "load", d2), c2.src = b2, c2.complete && d2({})) : r2(m2.element, b2);
          return m2;
        };
        J2.prototype.symbol = function(c2, a2, l2, r2, J3, G2) {
          var g2 = this, v2 = /^url\((.*?)\)$/, q3 = v2.test(c2), D2 = !q3 && (this.symbols[c2] ? c2 : "circle"), k2 = D2 && this.symbols[D2], f3;
          if (k2) {
            typeof a2 === "number" && (f3 = k2.call(this.symbols, Math.round(a2 || 0), Math.round(l2 || 0), r2 || 0, J3 || 0, G2));
            var p3 = this.path(f3);
            g2.styledMode || p3.attr("fill", "none");
            d(p3, { symbolName: D2 || void 0, x: a2, y: l2, width: r2, height: J3 });
            G2 && d(p3, G2);
          } else if (q3) {
            var L = c2.match(v2)[1];
            var t2 = p3 = this.image(L);
            t2.imgwidth = S(F[L] && F[L].width, G2 && G2.width);
            t2.imgheight = S(F[L] && F[L].height, G2 && G2.height);
            var y2 = function(b2) {
              return b2.attr({ width: b2.width, height: b2.height });
            };
            ["width", "height"].forEach(function(d2) {
              t2[d2 + "Setter"] = function(d3, c3) {
                var a3 = this["img" + c3];
                this[c3] = d3;
                b(a3) && (G2 && G2.backgroundSize === "within" && this.width && this.height && (a3 = Math.round(a3 * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(c3, a3), this.alignByTranslate || (d3 = ((this[c3] || 0) - a3) / 2, this.attr(c3 === "width" ? { translateX: d3 } : { translateY: d3 })));
              };
            });
            b(a2) && t2.attr({ x: a2, y: l2 });
            t2.isImg = true;
            b(t2.imgwidth) && b(t2.imgheight) ? y2(t2) : (t2.attr({ width: 0, height: 0 }), m("img", { onload: function() {
              var b2 = n[g2.chartIndex];
              this.width === 0 && (h2(this, { position: "absolute", top: "-999em" }), e.body.appendChild(this));
              F[L] = { width: this.width, height: this.height };
              t2.imgwidth = this.width;
              t2.imgheight = this.height;
              t2.element && y2(t2);
              this.parentNode && this.parentNode.removeChild(this);
              g2.imgCount--;
              if (!g2.imgCount && b2 && !b2.hasLoaded)
                b2.onload();
            }, src: L }), this.imgCount++);
          }
          return p3;
        };
        J2.prototype.clipRect = function(b2, d2, c2, a2) {
          var h3 = C2() + "-", l2 = this.createElement("clipPath").attr({ id: h3 }).add(this.defs);
          b2 = this.rect(b2, d2, c2, a2, 0).add(l2);
          b2.id = h3;
          b2.clipPath = l2;
          b2.count = 0;
          return b2;
        };
        J2.prototype.text = function(d2, c2, a2, h3) {
          var l2 = {};
          if (h3 && (this.allowHTML || !this.forExport))
            return this.html(d2, c2, a2);
          l2.x = Math.round(c2 || 0);
          a2 && (l2.y = Math.round(a2));
          b(d2) && (l2.text = d2);
          d2 = this.createElement("text").attr(l2);
          if (!h3 || this.forExport && !this.allowHTML)
            d2.xSetter = function(b2, d3, c3) {
              for (var a3 = c3.getElementsByTagName("tspan"), h4 = c3.getAttribute(d3), l3 = 0, e2; l3 < a3.length; l3++)
                e2 = a3[l3], e2.getAttribute(d3) === h4 && e2.setAttribute(d3, b2);
              c3.setAttribute(d3, b2);
            };
          return d2;
        };
        J2.prototype.fontMetrics = function(b2, d2) {
          b2 = !this.styledMode && /px/.test(b2) || !y.getComputedStyle ? b2 || d2 && d2.style && d2.style.fontSize || this.style && this.style.fontSize : d2 && w.prototype.getStyle.call(d2, "font-size");
          b2 = /px/.test(b2) ? N2(b2) : 12;
          d2 = 24 > b2 ? b2 + 3 : Math.round(1.2 * b2);
          return { h: d2, b: Math.round(0.8 * d2), f: b2 };
        };
        J2.prototype.rotCorr = function(b2, d2, c2) {
          var a2 = b2;
          d2 && c2 && (a2 = Math.max(a2 * Math.cos(d2 * k), 4));
          return { x: -b2 / 3 * Math.sin(d2 * k), y: a2 };
        };
        J2.prototype.pathToSegments = function(b2) {
          for (var d2 = [], c2 = [], a2 = { A: 8, C: 7, H: 2, L: 3, M: 3, Q: 5, S: 5, T: 3, V: 2 }, h3 = 0; h3 < b2.length; h3++)
            O(c2[0]) && v(b2[h3]) && c2.length === a2[c2[0].toUpperCase()] && b2.splice(h3, 0, c2[0].replace("M", "L").replace("m", "l")), typeof b2[h3] === "string" && (c2.length && d2.push(c2.slice(0)), c2.length = 0), c2.push(b2[h3]);
          d2.push(c2.slice(0));
          return d2;
        };
        J2.prototype.label = function(b2, d2, c2, a2, h3, l2, e2, r2, m2) {
          return new E2(this, b2, d2, c2, a2, h3, l2, e2, r2, m2);
        };
        J2.prototype.alignElements = function() {
          this.alignedObjects.forEach(function(b2) {
            return b2.align();
          });
        };
        return J2;
      }();
      d(B2.prototype, {
        Element: w,
        SVG_NS: q2,
        escapes: { "&": "&amp;", "<": "&lt;", ">": "&gt;", "'": "&#39;", '"': "&quot;" },
        symbols: I2,
        draw: t
      });
      H2.registerRendererType("svg", B2, true);
      return B2;
    });
    K2(f, "Core/Renderer/HTML/HTMLElement.js", [f["Core/Globals.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = this && this.__extends || function() {
        var c2 = function(a2, e2) {
          c2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c3, a3) {
            c3.__proto__ = a3;
          } || function(c3, a3) {
            for (var e3 in a3)
              a3.hasOwnProperty(e3) && (c3[e3] = a3[e3]);
          };
          return c2(a2, e2);
        };
        return function(a2, e2) {
          function g() {
            this.constructor = a2;
          }
          c2(a2, e2);
          a2.prototype = e2 === null ? Object.create(e2) : (g.prototype = e2.prototype, new g());
        };
      }(), w = a.isFirefox, E2 = a.isMS, I2 = a.isWebKit, A = a.win, u = B2.css, n = B2.defined, k = B2.extend, e = B2.pick, c = B2.pInt;
      return function(a2) {
        function g() {
          return a2 !== null && a2.apply(this, arguments) || this;
        }
        C2(g, a2);
        g.compose = function(c2) {
          if (g.composedClasses.indexOf(c2) === -1) {
            g.composedClasses.push(c2);
            var a3 = g.prototype, e2 = c2.prototype;
            e2.getSpanCorrection = a3.getSpanCorrection;
            e2.htmlCss = a3.htmlCss;
            e2.htmlGetBBox = a3.htmlGetBBox;
            e2.htmlUpdateTransform = a3.htmlUpdateTransform;
            e2.setSpanRotation = a3.setSpanRotation;
          }
          return c2;
        };
        g.prototype.getSpanCorrection = function(c2, a3, e2) {
          this.xCorr = -c2 * e2;
          this.yCorr = -a3;
        };
        g.prototype.htmlCss = function(c2) {
          var a3 = this.element.tagName === "SPAN" && c2 && "width" in c2, g2 = e(a3 && c2.width, void 0);
          if (a3) {
            delete c2.width;
            this.textWidth = g2;
            var f3 = true;
          }
          c2 && c2.textOverflow === "ellipsis" && (c2.whiteSpace = "nowrap", c2.overflow = "hidden");
          this.styles = k(this.styles, c2);
          u(this.element, c2);
          f3 && this.htmlUpdateTransform();
          return this;
        };
        g.prototype.htmlGetBBox = function() {
          var c2 = this.element;
          return { x: c2.offsetLeft, y: c2.offsetTop, width: c2.offsetWidth, height: c2.offsetHeight };
        };
        g.prototype.htmlUpdateTransform = function() {
          if (this.added) {
            var a3 = this.renderer, e2 = this.element, g2 = this.translateX || 0, k2 = this.translateY || 0, f3 = this.x || 0, p2 = this.y || 0, m = this.textAlign || "left", h2 = { left: 0, center: 0.5, right: 1 }[m], b = this.styles;
            b = b && b.whiteSpace;
            u(e2, { marginLeft: g2, marginTop: k2 });
            !a3.styledMode && this.shadows && this.shadows.forEach(function(b2) {
              u(b2, { marginLeft: g2 + 1, marginTop: k2 + 1 });
            });
            this.inverted && [].forEach.call(e2.childNodes, function(b2) {
              a3.invertChild(b2, e2);
            });
            if (e2.tagName === "SPAN") {
              var l = this.rotation, d = this.textWidth && c(this.textWidth), D = [l, m, e2.innerHTML, this.textWidth, this.textAlign].join(), v = void 0;
              v = false;
              if (d !== this.oldTextWidth) {
                if (this.textPxLength)
                  var r = this.textPxLength;
                else
                  u(e2, { width: "", whiteSpace: b || "nowrap" }), r = e2.offsetWidth;
                (d > this.oldTextWidth || r > d) && (/[ \-]/.test(e2.textContent || e2.innerText) || e2.style.textOverflow === "ellipsis") && (u(e2, { width: r > d || l ? d + "px" : "auto", display: "block", whiteSpace: b || "normal" }), this.oldTextWidth = d, v = true);
              }
              this.hasBoxWidthChanged = v;
              D !== this.cTT && (v = a3.fontMetrics(e2.style.fontSize, e2).b, !n(l) || l === (this.oldRotation || 0) && m === this.oldAlign || this.setSpanRotation(l, h2, v), this.getSpanCorrection(!n(l) && this.textPxLength || e2.offsetWidth, v, h2, l, m));
              u(e2, { left: f3 + (this.xCorr || 0) + "px", top: p2 + (this.yCorr || 0) + "px" });
              this.cTT = D;
              this.oldRotation = l;
              this.oldAlign = m;
            }
          } else
            this.alignOnAdd = true;
        };
        g.prototype.setSpanRotation = function(c2, a3, e2) {
          var g2 = {}, k2 = E2 && !/Edge/.test(A.navigator.userAgent) ? "-ms-transform" : I2 ? "-webkit-transform" : w ? "MozTransform" : A.opera ? "-o-transform" : void 0;
          k2 && (g2[k2] = g2.transform = "rotate(" + c2 + "deg)", g2[k2 + (w ? "Origin" : "-origin")] = g2.transformOrigin = 100 * a3 + "% " + e2 + "px", u(this.element, g2));
        };
        g.composedClasses = [];
        return g;
      }(f2);
    });
    K2(f, "Core/Renderer/HTML/HTMLRenderer.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2) {
      var C2 = this && this.__extends || function() {
        var a2 = function(k, e) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(c, a3) {
            c.__proto__ = a3;
          } || function(c, a3) {
            for (var e2 in a3)
              a3.hasOwnProperty(e2) && (c[e2] = a3[e2]);
          };
          return a2(k, e);
        };
        return function(k, e) {
          function c() {
            this.constructor = k;
          }
          a2(k, e);
          k.prototype = e === null ? Object.create(e) : (c.prototype = e.prototype, new c());
        };
      }(), E2 = H2.attr, I2 = H2.createElement, A = H2.extend, u = H2.pick;
      return function(n) {
        function k() {
          return n !== null && n.apply(this, arguments) || this;
        }
        C2(k, n);
        k.compose = function(a2) {
          k.composedClasses.indexOf(a2) === -1 && (k.composedClasses.push(a2), a2.prototype.html = k.prototype.html);
          return a2;
        };
        k.prototype.html = function(e, c, k2) {
          var g = this.createElement("span"), p2 = g.element, q2 = g.renderer, n2 = q2.isSVG, y = function(c2, a2) {
            ["opacity", "visibility"].forEach(function(e2) {
              c2[e2 + "Setter"] = function(h2, b, l) {
                var d = c2.div ? c2.div.style : a2;
                f2.prototype[e2 + "Setter"].call(this, h2, b, l);
                d && (d[b] = h2);
              };
            });
            c2.addedSetters = true;
          };
          g.textSetter = function(c2) {
            c2 !== this.textStr && (delete this.bBox, delete this.oldTextWidth, a.setElementHTML(this.element, u(c2, "")), this.textStr = c2, g.doTransform = true);
          };
          n2 && y(g, g.element.style);
          g.xSetter = g.ySetter = g.alignSetter = g.rotationSetter = function(c2, a2) {
            a2 === "align" ? g.alignValue = g.textAlign = c2 : g[a2] = c2;
            g.doTransform = true;
          };
          g.afterSetters = function() {
            this.doTransform && (this.htmlUpdateTransform(), this.doTransform = false);
          };
          g.attr({ text: e, x: Math.round(c), y: Math.round(k2) }).css({ position: "absolute" });
          q2.styledMode || g.css({ fontFamily: this.style.fontFamily, fontSize: this.style.fontSize });
          p2.style.whiteSpace = "nowrap";
          g.css = g.htmlCss;
          n2 && (g.add = function(c2) {
            var a2 = q2.box.parentNode, e2 = [];
            if (this.parentGroup = c2) {
              var h2 = c2.div;
              if (!h2) {
                for (; c2; )
                  e2.push(c2), c2 = c2.parentGroup;
                e2.reverse().forEach(function(b) {
                  function c3(d2, c4) {
                    b[c4] = d2;
                    c4 === "translateX" ? v.left = d2 + "px" : v.top = d2 + "px";
                    b.doTransform = true;
                  }
                  var d = E2(b.element, "class"), m = b.styles || {};
                  h2 = b.div = b.div || I2("div", d ? { className: d } : void 0, { position: "absolute", left: (b.translateX || 0) + "px", top: (b.translateY || 0) + "px", display: b.display, opacity: b.opacity, cursor: m.cursor, pointerEvents: m.pointerEvents, visibility: b.visibility }, h2 || a2);
                  var v = h2.style;
                  A(b, { classSetter: function(b2) {
                    return function(d2) {
                      this.element.setAttribute("class", d2);
                      b2.className = d2;
                    };
                  }(h2), on: function() {
                    e2[0].div && g.on.apply({ element: e2[0].div, onEvents: b.onEvents }, arguments);
                    return b;
                  }, translateXSetter: c3, translateYSetter: c3 });
                  b.addedSetters || y(b);
                });
              }
            } else
              h2 = a2;
            h2.appendChild(p2);
            g.added = true;
            g.alignOnAdd && g.htmlUpdateTransform();
            return g;
          });
          return g;
        };
        k.composedClasses = [];
        return k;
      }(B2);
    });
    K2(f, "Core/Axis/AxisDefaults.js", [], function() {
      var a;
      (function(a2) {
        a2.defaultXAxisOptions = {
          alignTicks: true,
          allowDecimals: void 0,
          panningEnabled: true,
          zIndex: 2,
          zoomEnabled: true,
          dateTimeLabelFormats: { millisecond: {
            main: "%H:%M:%S.%L",
            range: false
          }, second: { main: "%H:%M:%S", range: false }, minute: { main: "%H:%M", range: false }, hour: { main: "%H:%M", range: false }, day: { main: "%e. %b" }, week: { main: "%e. %b" }, month: { main: "%b '%y" }, year: { main: "%Y" } },
          endOnTick: false,
          gridLineDashStyle: "Solid",
          gridZIndex: 1,
          labels: { autoRotation: void 0, autoRotationLimit: 80, distance: void 0, enabled: true, indentation: 10, overflow: "justify", padding: 5, reserveSpace: void 0, rotation: void 0, staggerLines: 0, step: 0, useHTML: false, x: 0, zIndex: 7, style: { color: "#666666", cursor: "default", fontSize: "11px" } },
          maxPadding: 0.01,
          minorGridLineDashStyle: "Solid",
          minorTickLength: 2,
          minorTickPosition: "outside",
          minPadding: 0.01,
          offset: void 0,
          opposite: false,
          reversed: void 0,
          reversedStacks: false,
          showEmpty: true,
          showFirstLabel: true,
          showLastLabel: true,
          startOfWeek: 1,
          startOnTick: false,
          tickLength: 10,
          tickPixelInterval: 100,
          tickmarkPlacement: "between",
          tickPosition: "outside",
          title: { align: "middle", rotation: 0, useHTML: false, x: 0, y: 0, style: { color: "#666666" } },
          type: "linear",
          uniqueNames: true,
          visible: true,
          minorGridLineColor: "#f2f2f2",
          minorGridLineWidth: 1,
          minorTickColor: "#999999",
          lineColor: "#ccd6eb",
          lineWidth: 1,
          gridLineColor: "#e6e6e6",
          gridLineWidth: void 0,
          tickColor: "#ccd6eb"
        };
        a2.defaultYAxisOptions = { reversedStacks: true, endOnTick: true, maxPadding: 0.05, minPadding: 0.05, tickPixelInterval: 72, showLastLabel: true, labels: { x: -8 }, startOnTick: true, title: { rotation: 270, text: "Values" }, stackLabels: { animation: {}, allowOverlap: false, enabled: false, crop: true, overflow: "justify", formatter: function() {
          var a3 = this.axis.chart.numberFormatter;
          return a3(this.total, -1);
        }, style: {
          color: "#000000",
          fontSize: "11px",
          fontWeight: "bold",
          textOutline: "1px contrast"
        } }, gridLineWidth: 1, lineWidth: 0 };
        a2.defaultLeftAxisOptions = { labels: { x: -15 }, title: { rotation: 270 } };
        a2.defaultRightAxisOptions = { labels: { x: 15 }, title: { rotation: 90 } };
        a2.defaultBottomAxisOptions = { labels: { autoRotation: [-45], x: 0 }, margin: 15, title: { rotation: 0 } };
        a2.defaultTopAxisOptions = { labels: { autoRotation: [-45], x: 0 }, margin: 15, title: { rotation: 0 } };
      })(a || (a = {}));
      return a;
    });
    K2(f, "Core/Foundation.js", [f["Core/Utilities.js"]], function(a) {
      var f2 = a.addEvent, B2 = a.isFunction, H2 = a.objectEach, w = a.removeEvent, E2;
      (function(a2) {
        a2.registerEventOptions = function(a3, u) {
          a3.eventOptions = a3.eventOptions || {};
          H2(u.events, function(n, k) {
            a3.eventOptions[k] !== n && (a3.eventOptions[k] && (w(a3, k, a3.eventOptions[k]), delete a3.eventOptions[k]), B2(n) && (a3.eventOptions[k] = n, f2(a3, k, n)));
          });
        };
      })(E2 || (E2 = {}));
      return E2;
    });
    K2(f, "Core/Axis/Tick.js", [f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = f2.deg2rad, w = B2.clamp, E2 = B2.correctFloat, I2 = B2.defined, A = B2.destroyObjectProperties, u = B2.extend, n = B2.fireEvent, k = B2.isNumber, e = B2.merge, c = B2.objectEach, p2 = B2.pick;
      f2 = function() {
        function g(c2, a2, e2, g2, k2) {
          this.isNewLabel = this.isNew = true;
          this.axis = c2;
          this.pos = a2;
          this.type = e2 || "";
          this.parameters = k2 || {};
          this.tickmarkOffset = this.parameters.tickmarkOffset;
          this.options = this.parameters.options;
          n(this, "init");
          e2 || g2 || this.addLabel();
        }
        g.prototype.addLabel = function() {
          var c2 = this, e2 = c2.axis, g2 = e2.options, f3 = e2.chart, x = e2.categories, z = e2.logarithmic, m = e2.names, h2 = c2.pos, b = p2(c2.options && c2.options.labels, g2.labels), l = e2.tickPositions, d = h2 === l[0], D = h2 === l[l.length - 1], v = (!b.step || b.step === 1) && e2.tickInterval === 1;
          l = l.info;
          var r = c2.label, O;
          x = this.parameters.category || (x ? p2(x[h2], m[h2], h2) : h2);
          z && k(x) && (x = E2(z.lin2log(x)));
          if (e2.dateTime)
            if (l) {
              var P2 = f3.time.resolveDTLFormat(g2.dateTimeLabelFormats[!g2.grid && l.higherRanks[h2] || l.unitName]);
              var S = P2.main;
            } else
              k(x) && (S = e2.dateTime.getXDateFormat(x, g2.dateTimeLabelFormats || {}));
          c2.isFirst = d;
          c2.isLast = D;
          var N2 = { axis: e2, chart: f3, dateTimeLabelFormat: S, isFirst: d, isLast: D, pos: h2, tick: c2, tickPositionInfo: l, value: x };
          n(this, "labelFormat", N2);
          var C3 = function(d2) {
            return b.formatter ? b.formatter.call(d2, d2) : b.format ? (d2.text = e2.defaultLabelFormatter.call(d2), a.format(b.format, d2, f3)) : e2.defaultLabelFormatter.call(d2, d2);
          };
          g2 = C3.call(N2, N2);
          var X2 = P2 && P2.list;
          c2.shortenLabel = X2 ? function() {
            for (O = 0; O < X2.length; O++)
              if (u(N2, { dateTimeLabelFormat: X2[O] }), r.attr({ text: C3.call(N2, N2) }), r.getBBox().width < e2.getSlotWidth(c2) - 2 * b.padding)
                return;
            r.attr({ text: "" });
          } : void 0;
          v && e2._addedPlotLB && c2.moveLabel(g2, b);
          I2(r) || c2.movedLabel ? r && r.textStr !== g2 && !v && (!r.textWidth || b.style.width || r.styles.width || r.css({ width: null }), r.attr({ text: g2 }), r.textPxLength = r.getBBox().width) : (c2.label = r = c2.createLabel({ x: 0, y: 0 }, g2, b), c2.rotation = 0);
        };
        g.prototype.createLabel = function(c2, a2, g2) {
          var k2 = this.axis, f3 = k2.chart;
          if (c2 = I2(a2) && g2.enabled ? f3.renderer.text(a2, c2.x, c2.y, g2.useHTML).add(k2.labelGroup) : null)
            f3.styledMode || c2.css(e(g2.style)), c2.textPxLength = c2.getBBox().width;
          return c2;
        };
        g.prototype.destroy = function() {
          A(this, this.axis);
        };
        g.prototype.getPosition = function(c2, a2, e2, g2) {
          var k2 = this.axis, f3 = k2.chart, m = g2 && f3.oldChartHeight || f3.chartHeight;
          c2 = { x: c2 ? E2(k2.translate(a2 + e2, null, null, g2) + k2.transB) : k2.left + k2.offset + (k2.opposite ? (g2 && f3.oldChartWidth || f3.chartWidth) - k2.right - k2.left : 0), y: c2 ? m - k2.bottom + k2.offset - (k2.opposite ? k2.height : 0) : E2(m - k2.translate(a2 + e2, null, null, g2) - k2.transB) };
          c2.y = w(c2.y, -1e5, 1e5);
          n(this, "afterGetPosition", { pos: c2 });
          return c2;
        };
        g.prototype.getLabelPosition = function(c2, a2, e2, g2, k2, f3, m, h2) {
          var b = this.axis, l = b.transA, d = b.isLinked && b.linkedParent ? b.linkedParent.reversed : b.reversed, D = b.staggerLines, v = b.tickRotCorr || { x: 0, y: 0 }, r = g2 || b.reserveSpaceDefault ? 0 : -b.labelOffset * (b.labelAlign === "center" ? 0.5 : 1), p3 = {}, q2 = k2.y;
          I2(q2) || (q2 = b.side === 0 ? e2.rotation ? -8 : -e2.getBBox().height : b.side === 2 ? v.y + 8 : Math.cos(e2.rotation * C2) * (v.y - e2.getBBox(false, 0).height / 2));
          c2 = c2 + k2.x + r + v.x - (f3 && g2 ? f3 * l * (d ? -1 : 1) : 0);
          a2 = a2 + q2 - (f3 && !g2 ? f3 * l * (d ? 1 : -1) : 0);
          D && (e2 = m / (h2 || 1) % D, b.opposite && (e2 = D - e2 - 1), a2 += b.labelOffset / D * e2);
          p3.x = c2;
          p3.y = Math.round(a2);
          n(this, "afterGetLabelPosition", { pos: p3, tickmarkOffset: f3, index: m });
          return p3;
        };
        g.prototype.getLabelSize = function() {
          return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0;
        };
        g.prototype.getMarkPath = function(c2, a2, e2, g2, k2, f3) {
          return f3.crispLine([["M", c2, a2], ["L", c2 + (k2 ? 0 : -e2), a2 + (k2 ? e2 : 0)]], g2);
        };
        g.prototype.handleOverflow = function(c2) {
          var a2 = this.axis, e2 = a2.options.labels, g2 = c2.x, k2 = a2.chart.chartWidth, f3 = a2.chart.spacing, m = p2(a2.labelLeft, Math.min(a2.pos, f3[3]));
          f3 = p2(a2.labelRight, Math.max(a2.isRadial ? 0 : a2.pos + a2.len, k2 - f3[1]));
          var h2 = this.label, b = this.rotation, l = { left: 0, center: 0.5, right: 1 }[a2.labelAlign || h2.attr("align")], d = h2.getBBox().width, D = a2.getSlotWidth(this), v = {}, r = D, n2 = 1, t;
          if (b || e2.overflow !== "justify")
            0 > b && g2 - l * d < m ? t = Math.round(g2 / Math.cos(b * C2) - m) : 0 < b && g2 + l * d > f3 && (t = Math.round((k2 - g2) / Math.cos(b * C2)));
          else if (k2 = g2 + (1 - l) * d, g2 - l * d < m ? r = c2.x + r * (1 - l) - m : k2 > f3 && (r = f3 - c2.x + r * l, n2 = -1), r = Math.min(D, r), r < D && a2.labelAlign === "center" && (c2.x += n2 * (D - r - l * (D - Math.min(d, r)))), d > r || a2.autoRotation && (h2.styles || {}).width)
            t = r;
          t && (this.shortenLabel ? this.shortenLabel() : (v.width = Math.floor(t) + "px", (e2.style || {}).textOverflow || (v.textOverflow = "ellipsis"), h2.css(v)));
        };
        g.prototype.moveLabel = function(a2, e2) {
          var g2 = this, k2 = g2.label, f3 = g2.axis, p3 = f3.reversed, m = false;
          k2 && k2.textStr === a2 ? (g2.movedLabel = k2, m = true, delete g2.label) : c(f3.ticks, function(b) {
            m || b.isNew || b === g2 || !b.label || b.label.textStr !== a2 || (g2.movedLabel = b.label, m = true, b.labelPos = g2.movedLabel.xy, delete b.label);
          });
          if (!m && (g2.labelPos || k2)) {
            var h2 = g2.labelPos || k2.xy;
            k2 = f3.horiz ? p3 ? 0 : f3.width + f3.left : h2.x;
            f3 = f3.horiz ? h2.y : p3 ? f3.width + f3.left : 0;
            g2.movedLabel = g2.createLabel({ x: k2, y: f3 }, a2, e2);
            g2.movedLabel && g2.movedLabel.attr({ opacity: 0 });
          }
        };
        g.prototype.render = function(c2, a2, e2) {
          var g2 = this.axis, k2 = g2.horiz, f3 = this.pos, m = p2(this.tickmarkOffset, g2.tickmarkOffset);
          f3 = this.getPosition(k2, f3, m, a2);
          m = f3.x;
          var h2 = f3.y;
          g2 = k2 && m === g2.pos + g2.len || !k2 && h2 === g2.pos ? -1 : 1;
          k2 = p2(e2, this.label && this.label.newOpacity, 1);
          e2 = p2(e2, 1);
          this.isActive = true;
          this.renderGridLine(a2, e2, g2);
          this.renderMark(f3, e2, g2);
          this.renderLabel(f3, a2, k2, c2);
          this.isNew = false;
          n(this, "afterRender");
        };
        g.prototype.renderGridLine = function(c2, a2, e2) {
          var g2 = this.axis, k2 = g2.options, f3 = {}, m = this.pos, h2 = this.type, b = p2(this.tickmarkOffset, g2.tickmarkOffset), l = g2.chart.renderer, d = this.gridLine, D = k2.gridLineWidth, v = k2.gridLineColor, r = k2.gridLineDashStyle;
          this.type === "minor" && (D = k2.minorGridLineWidth, v = k2.minorGridLineColor, r = k2.minorGridLineDashStyle);
          d || (g2.chart.styledMode || (f3.stroke = v, f3["stroke-width"] = D || 0, f3.dashstyle = r), h2 || (f3.zIndex = 1), c2 && (a2 = 0), this.gridLine = d = l.path().attr(f3).addClass("highcharts-" + (h2 ? h2 + "-" : "") + "grid-line").add(g2.gridGroup));
          if (d && (e2 = g2.getPlotLinePath({ value: m + b, lineWidth: d.strokeWidth() * e2, force: "pass", old: c2 })))
            d[c2 || this.isNew ? "attr" : "animate"]({ d: e2, opacity: a2 });
        };
        g.prototype.renderMark = function(c2, a2, e2) {
          var g2 = this.axis, k2 = g2.options, f3 = g2.chart.renderer, m = this.type, h2 = g2.tickSize(m ? m + "Tick" : "tick"), b = c2.x;
          c2 = c2.y;
          var l = p2(k2[m !== "minor" ? "tickWidth" : "minorTickWidth"], !m && g2.isXAxis ? 1 : 0);
          k2 = k2[m !== "minor" ? "tickColor" : "minorTickColor"];
          var d = this.mark, D = !d;
          h2 && (g2.opposite && (h2[0] = -h2[0]), d || (this.mark = d = f3.path().addClass("highcharts-" + (m ? m + "-" : "") + "tick").add(g2.axisGroup), g2.chart.styledMode || d.attr({ stroke: k2, "stroke-width": l })), d[D ? "attr" : "animate"]({ d: this.getMarkPath(b, c2, h2[0], d.strokeWidth() * e2, g2.horiz, f3), opacity: a2 }));
        };
        g.prototype.renderLabel = function(c2, a2, e2, g2) {
          var f3 = this.axis, q2 = f3.horiz, m = f3.options, h2 = this.label, b = m.labels, l = b.step;
          f3 = p2(this.tickmarkOffset, f3.tickmarkOffset);
          var d = c2.x;
          c2 = c2.y;
          var D = true;
          h2 && k(d) && (h2.xy = c2 = this.getLabelPosition(d, c2, h2, q2, b, f3, g2, l), this.isFirst && !this.isLast && !m.showFirstLabel || this.isLast && !this.isFirst && !m.showLastLabel ? D = false : !q2 || b.step || b.rotation || a2 || e2 === 0 || this.handleOverflow(c2), l && g2 % l && (D = false), D && k(c2.y) ? (c2.opacity = e2, h2[this.isNewLabel ? "attr" : "animate"](c2).show(true), this.isNewLabel = false) : (h2.hide(), this.isNewLabel = true));
        };
        g.prototype.replaceMovedLabel = function() {
          var c2 = this.label, a2 = this.axis, e2 = a2.reversed;
          if (c2 && !this.isNew) {
            var g2 = a2.horiz ? e2 ? a2.left : a2.width + a2.left : c2.xy.x;
            e2 = a2.horiz ? c2.xy.y : e2 ? a2.width + a2.top : a2.top;
            c2.animate({ x: g2, y: e2, opacity: 0 }, void 0, c2.destroy);
            delete this.label;
          }
          a2.isDirty = true;
          this.label = this.movedLabel;
          delete this.movedLabel;
        };
        return g;
      }();
      return f2;
    });
    K2(f, "Core/Axis/Axis.js", [
      f["Core/Animation/AnimationUtilities.js"],
      f["Core/Axis/AxisDefaults.js"],
      f["Core/Color/Color.js"],
      f["Core/DefaultOptions.js"],
      f["Core/Foundation.js"],
      f["Core/Globals.js"],
      f["Core/Axis/Tick.js"],
      f["Core/Utilities.js"]
    ], function(a, f2, B2, H2, w, E2, I2, A) {
      var u = a.animObject, n = H2.defaultOptions, k = w.registerEventOptions, e = E2.deg2rad, c = A.arrayMax, p2 = A.arrayMin, g = A.clamp, t = A.correctFloat, q2 = A.defined, F = A.destroyObjectProperties, y = A.erase, x = A.error, z = A.extend, m = A.fireEvent, h2 = A.isArray, b = A.isNumber, l = A.isString, d = A.merge, D = A.normalizeTickInterval, v = A.objectEach, r = A.pick, O = A.relativeLength, P2 = A.removeEvent, S = A.splat, N2 = A.syncTimeout, C2 = function(b2, d2) {
        return D(d2, void 0, void 0, r(b2.options.allowDecimals, 0.5 > d2 || b2.tickAmount !== void 0), !!b2.tickAmount);
      };
      a = function() {
        function a2(b2, d2) {
          this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;
          this.init(b2, d2);
        }
        a2.prototype.init = function(d2, c2) {
          var a3 = c2.isX;
          this.chart = d2;
          this.horiz = d2.inverted && !this.isZAxis ? !a3 : a3;
          this.isXAxis = a3;
          this.coll = this.coll || (a3 ? "xAxis" : "yAxis");
          m(this, "init", { userOptions: c2 });
          this.opposite = r(c2.opposite, this.opposite);
          this.side = r(c2.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);
          this.setOptions(c2);
          var e2 = this.options, h3 = e2.labels, l2 = e2.type;
          this.userOptions = c2;
          this.minPixelPadding = 0;
          this.reversed = r(e2.reversed, this.reversed);
          this.visible = e2.visible;
          this.zoomEnabled = e2.zoomEnabled;
          this.hasNames = l2 === "category" || e2.categories === true;
          this.categories = e2.categories || (this.hasNames ? [] : void 0);
          this.names || (this.names = [], this.names.keys = {});
          this.plotLinesAndBandsGroups = {};
          this.positiveValuesOnly = !!this.logarithmic;
          this.isLinked = q2(e2.linkedTo);
          this.ticks = {};
          this.labelEdge = [];
          this.minorTicks = {};
          this.plotLinesAndBands = [];
          this.alternateBands = {};
          this.len = 0;
          this.minRange = this.userMinRange = e2.minRange || e2.maxZoom;
          this.range = e2.range;
          this.offset = e2.offset || 0;
          this.min = this.max = null;
          c2 = r(e2.crosshair, S(d2.options.tooltip.crosshairs)[a3 ? 0 : 1]);
          this.crosshair = c2 === true ? {} : c2;
          d2.axes.indexOf(this) === -1 && (a3 ? d2.axes.splice(d2.xAxis.length, 0, this) : d2.axes.push(this), d2[this.coll].push(this));
          this.series = this.series || [];
          d2.inverted && !this.isZAxis && a3 && typeof this.reversed === "undefined" && (this.reversed = true);
          this.labelRotation = b(h3.rotation) ? h3.rotation : void 0;
          k(this, e2);
          m(this, "afterInit");
        };
        a2.prototype.setOptions = function(b2) {
          this.options = d(f2.defaultXAxisOptions, this.coll === "yAxis" && f2.defaultYAxisOptions, [f2.defaultTopAxisOptions, f2.defaultRightAxisOptions, f2.defaultBottomAxisOptions, f2.defaultLeftAxisOptions][this.side], d(n[this.coll], b2));
          m(this, "afterSetOptions", { userOptions: b2 });
        };
        a2.prototype.defaultLabelFormatter = function(d2) {
          var c2 = this.axis;
          d2 = this.chart.numberFormatter;
          var a3 = b(this.value) ? this.value : NaN, e2 = c2.chart.time, h3 = this.dateTimeLabelFormat, l2 = n.lang, g2 = l2.numericSymbols;
          l2 = l2.numericSymbolMagnitude || 1e3;
          var r2 = c2.logarithmic ? Math.abs(a3) : c2.tickInterval, m2 = g2 && g2.length;
          if (c2.categories)
            var J2 = "" + this.value;
          else if (h3)
            J2 = e2.dateFormat(h3, a3);
          else if (m2 && 1e3 <= r2)
            for (; m2-- && typeof J2 === "undefined"; )
              c2 = Math.pow(l2, m2 + 1), r2 >= c2 && 10 * a3 % c2 === 0 && g2[m2] !== null && a3 !== 0 && (J2 = d2(a3 / c2, -1) + g2[m2]);
          typeof J2 === "undefined" && (J2 = 1e4 <= Math.abs(a3) ? d2(a3, -1) : d2(a3, -1, void 0, ""));
          return J2;
        };
        a2.prototype.getSeriesExtremes = function() {
          var d2 = this, c2 = d2.chart, a3;
          m(this, "getSeriesExtremes", null, function() {
            d2.hasVisibleSeries = false;
            d2.dataMin = d2.dataMax = d2.threshold = null;
            d2.softThreshold = !d2.isXAxis;
            d2.stacking && d2.stacking.buildStacks();
            d2.series.forEach(function(e2) {
              if (e2.visible || !c2.options.chart.ignoreHiddenSeries) {
                var h3 = e2.options, l2 = h3.threshold;
                d2.hasVisibleSeries = true;
                d2.positiveValuesOnly && 0 >= l2 && (l2 = null);
                if (d2.isXAxis) {
                  if (h3 = e2.xData, h3.length) {
                    h3 = d2.logarithmic ? h3.filter(d2.validatePositiveValue) : h3;
                    a3 = e2.getXExtremes(h3);
                    var g2 = a3.min;
                    var m2 = a3.max;
                    b(g2) || g2 instanceof Date || (h3 = h3.filter(b), a3 = e2.getXExtremes(h3), g2 = a3.min, m2 = a3.max);
                    h3.length && (d2.dataMin = Math.min(r(d2.dataMin, g2), g2), d2.dataMax = Math.max(r(d2.dataMax, m2), m2));
                  }
                } else if (e2 = e2.applyExtremes(), b(e2.dataMin) && (g2 = e2.dataMin, d2.dataMin = Math.min(r(d2.dataMin, g2), g2)), b(e2.dataMax) && (m2 = e2.dataMax, d2.dataMax = Math.max(r(d2.dataMax, m2), m2)), q2(l2) && (d2.threshold = l2), !h3.softThreshold || d2.positiveValuesOnly)
                  d2.softThreshold = false;
              }
            });
          });
          m(this, "afterGetSeriesExtremes");
        };
        a2.prototype.translate = function(d2, c2, a3, e2, h3, l2) {
          var g2 = this.linkedParent || this, m2 = e2 && g2.old ? g2.old.min : g2.min, r2 = g2.minPixelPadding;
          h3 = (g2.isOrdinal || g2.brokenAxis && g2.brokenAxis.hasBreaks || g2.logarithmic && h3) && g2.lin2val;
          var k2 = 1, J2 = 0;
          e2 = e2 && g2.old ? g2.old.transA : g2.transA;
          e2 || (e2 = g2.transA);
          a3 && (k2 *= -1, J2 = g2.len);
          g2.reversed && (k2 *= -1, J2 -= k2 * (g2.sector || g2.len));
          c2 ? (l2 = (d2 * k2 + J2 - r2) / e2 + m2, h3 && (l2 = g2.lin2val(l2))) : (h3 && (d2 = g2.val2lin(d2)), d2 = k2 * (d2 - m2) * e2, l2 = b(m2) ? (g2.isRadial ? d2 : t(d2)) + J2 + k2 * r2 + (b(l2) ? e2 * l2 : 0) : void 0);
          return l2;
        };
        a2.prototype.toPixels = function(b2, d2) {
          return this.translate(b2, false, !this.horiz, null, true) + (d2 ? 0 : this.pos);
        };
        a2.prototype.toValue = function(b2, d2) {
          return this.translate(b2 - (d2 ? 0 : this.pos), true, !this.horiz, null, true);
        };
        a2.prototype.getPlotLinePath = function(d2) {
          function c2(b2, d3, c3) {
            if (n2 !== "pass" && b2 < d3 || b2 > c3)
              n2 ? b2 = g(b2, d3, c3) : P3 = true;
            return b2;
          }
          var a3 = this, e2 = a3.chart, h3 = a3.left, l2 = a3.top, k2 = d2.old, J2 = d2.value, f3 = d2.lineWidth, v2 = k2 && e2.oldChartHeight || e2.chartHeight, D2 = k2 && e2.oldChartWidth || e2.chartWidth, p3 = a3.transB, q3 = d2.translatedValue, n2 = d2.force, t2, z2, y2, O2, P3;
          d2 = {
            value: J2,
            lineWidth: f3,
            old: k2,
            force: n2,
            acrossPanes: d2.acrossPanes,
            translatedValue: q3
          };
          m(this, "getPlotLinePath", d2, function(d3) {
            q3 = r(q3, a3.translate(J2, null, null, k2));
            q3 = g(q3, -1e5, 1e5);
            t2 = y2 = Math.round(q3 + p3);
            z2 = O2 = Math.round(v2 - q3 - p3);
            b(q3) ? a3.horiz ? (z2 = l2, O2 = v2 - a3.bottom, t2 = y2 = c2(t2, h3, h3 + a3.width)) : (t2 = h3, y2 = D2 - a3.right, z2 = O2 = c2(z2, l2, l2 + a3.height)) : (P3 = true, n2 = false);
            d3.path = P3 && !n2 ? null : e2.renderer.crispLine([["M", t2, z2], ["L", y2, O2]], f3 || 1);
          });
          return d2.path;
        };
        a2.prototype.getLinearTickPositions = function(b2, d2, c2) {
          var a3 = t(Math.floor(d2 / b2) * b2);
          c2 = t(Math.ceil(c2 / b2) * b2);
          var e2 = [], h3;
          t(a3 + b2) === a3 && (h3 = 20);
          if (this.single)
            return [d2];
          for (d2 = a3; d2 <= c2; ) {
            e2.push(d2);
            d2 = t(d2 + b2, h3);
            if (d2 === l2)
              break;
            var l2 = d2;
          }
          return e2;
        };
        a2.prototype.getMinorTickInterval = function() {
          var b2 = this.options;
          return b2.minorTicks === true ? r(b2.minorTickInterval, "auto") : b2.minorTicks === false ? null : b2.minorTickInterval;
        };
        a2.prototype.getMinorTickPositions = function() {
          var b2 = this.options, d2 = this.tickPositions, c2 = this.minorTickInterval, a3 = this.pointRangePadding || 0, e2 = this.min - a3;
          a3 = this.max + a3;
          var h3 = a3 - e2, l2 = [];
          if (h3 && h3 / c2 < this.len / 3) {
            var g2 = this.logarithmic;
            if (g2)
              this.paddedTicks.forEach(function(b3, d3, a4) {
                d3 && l2.push.apply(l2, g2.getLogTickPositions(c2, a4[d3 - 1], a4[d3], true));
              });
            else if (this.dateTime && this.getMinorTickInterval() === "auto")
              l2 = l2.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(c2), e2, a3, b2.startOfWeek));
            else
              for (b2 = e2 + (d2[0] - e2) % c2; b2 <= a3 && b2 !== l2[0]; b2 += c2)
                l2.push(b2);
          }
          l2.length !== 0 && this.trimTicks(l2);
          return l2;
        };
        a2.prototype.adjustForMinRange = function() {
          var b2 = this.options, d2 = this.logarithmic, a3 = this.min, e2 = this.max, h3 = 0, l2, g2, m2, k2;
          this.isXAxis && typeof this.minRange === "undefined" && !d2 && (q2(b2.min) || q2(b2.max) || q2(b2.floor) || q2(b2.ceiling) ? this.minRange = null : (this.series.forEach(function(b3) {
            m2 = b3.xData;
            k2 = b3.xIncrement ? 1 : m2.length - 1;
            if (1 < m2.length) {
              for (l2 = k2; 0 < l2; l2--)
                if (g2 = m2[l2] - m2[l2 - 1], !h3 || g2 < h3)
                  h3 = g2;
            }
          }), this.minRange = Math.min(5 * h3, this.dataMax - this.dataMin)));
          if (e2 - a3 < this.minRange) {
            var f3 = this.dataMax - this.dataMin >= this.minRange;
            var v2 = this.minRange;
            var D2 = (v2 - e2 + a3) / 2;
            D2 = [a3 - D2, r(b2.min, a3 - D2)];
            f3 && (D2[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);
            a3 = c(D2);
            e2 = [a3 + v2, r(b2.max, a3 + v2)];
            f3 && (e2[2] = d2 ? d2.log2lin(this.dataMax) : this.dataMax);
            e2 = p2(e2);
            e2 - a3 < v2 && (D2[0] = e2 - v2, D2[1] = r(b2.min, e2 - v2), a3 = c(D2));
          }
          this.min = a3;
          this.max = e2;
        };
        a2.prototype.getClosest = function() {
          var b2;
          this.categories ? b2 = 1 : this.series.forEach(function(d2) {
            var c2 = d2.closestPointRange, a3 = d2.visible || !d2.chart.options.chart.ignoreHiddenSeries;
            !d2.noSharedTooltip && q2(c2) && a3 && (b2 = q2(b2) ? Math.min(b2, c2) : c2);
          });
          return b2;
        };
        a2.prototype.nameToX = function(b2) {
          var d2 = h2(this.options.categories), c2 = d2 ? this.categories : this.names, a3 = b2.options.x;
          b2.series.requireSorting = false;
          q2(a3) || (a3 = this.options.uniqueNames && c2 ? d2 ? c2.indexOf(b2.name) : r(c2.keys[b2.name], -1) : b2.series.autoIncrement());
          if (a3 === -1) {
            if (!d2 && c2)
              var e2 = c2.length;
          } else
            e2 = a3;
          typeof e2 !== "undefined" && (this.names[e2] = b2.name, this.names.keys[b2.name] = e2);
          return e2;
        };
        a2.prototype.updateNames = function() {
          var b2 = this, d2 = this.names;
          0 < d2.length && (Object.keys(d2.keys).forEach(function(b3) {
            delete d2.keys[b3];
          }), d2.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function(d3) {
            d3.xIncrement = null;
            if (!d3.points || d3.isDirtyData)
              b2.max = Math.max(b2.max, d3.xData.length - 1), d3.processData(), d3.generatePoints();
            d3.data.forEach(function(c2, a3) {
              if (c2 && c2.options && typeof c2.name !== "undefined") {
                var e2 = b2.nameToX(c2);
                typeof e2 !== "undefined" && e2 !== c2.x && (c2.x = e2, d3.xData[a3] = e2);
              }
            });
          }));
        };
        a2.prototype.setAxisTranslation = function() {
          var b2 = this, d2 = b2.max - b2.min, c2 = b2.linkedParent, a3 = !!b2.categories, e2 = b2.isXAxis, h3 = b2.axisPointRange || 0, g2 = 0, k2 = 0, f3 = b2.transA;
          if (e2 || a3 || h3) {
            var v2 = b2.getClosest();
            c2 ? (g2 = c2.minPointOffset, k2 = c2.pointRangePadding) : b2.series.forEach(function(d3) {
              var c3 = a3 ? 1 : e2 ? r(d3.options.pointRange, v2, 0) : b2.axisPointRange || 0, m2 = d3.options.pointPlacement;
              h3 = Math.max(h3, c3);
              if (!b2.single || a3)
                d3 = d3.is("xrange") ? !e2 : e2, g2 = Math.max(g2, d3 && l(m2) ? 0 : c3 / 2), k2 = Math.max(k2, d3 && m2 === "on" ? 0 : c3);
            });
            c2 = b2.ordinal && b2.ordinal.slope && v2 ? b2.ordinal.slope / v2 : 1;
            b2.minPointOffset = g2 *= c2;
            b2.pointRangePadding = k2 *= c2;
            b2.pointRange = Math.min(h3, b2.single && a3 ? 1 : d2);
            e2 && (b2.closestPointRange = v2);
          }
          b2.translationSlope = b2.transA = f3 = b2.staticScale || b2.len / (d2 + k2 || 1);
          b2.transB = b2.horiz ? b2.left : b2.bottom;
          b2.minPixelPadding = f3 * g2;
          m(this, "afterSetAxisTranslation");
        };
        a2.prototype.minFromRange = function() {
          return this.max - this.range;
        };
        a2.prototype.setTickInterval = function(d2) {
          var c2 = this.chart, a3 = this.logarithmic, e2 = this.options, h3 = this.isXAxis, l2 = this.isLinked, g2 = e2.tickPixelInterval, k2 = this.categories, f3 = this.softThreshold, v2 = e2.maxPadding, D2 = e2.minPadding, J2 = b(e2.tickInterval) && 0 <= e2.tickInterval ? e2.tickInterval : void 0, p3 = b(this.threshold) ? this.threshold : null;
          this.dateTime || k2 || l2 || this.getTickAmount();
          var n2 = r(this.userMin, e2.min);
          var z2 = r(this.userMax, e2.max);
          if (l2) {
            this.linkedParent = c2[this.coll][e2.linkedTo];
            var y2 = this.linkedParent.getExtremes();
            this.min = r(y2.min, y2.dataMin);
            this.max = r(y2.max, y2.dataMax);
            e2.type !== this.linkedParent.options.type && x(11, 1, c2);
          } else {
            if (f3 && q2(p3)) {
              if (this.dataMin >= p3)
                y2 = p3, D2 = 0;
              else if (this.dataMax <= p3) {
                var O2 = p3;
                v2 = 0;
              }
            }
            this.min = r(n2, y2, this.dataMin);
            this.max = r(z2, O2, this.dataMax);
          }
          a3 && (this.positiveValuesOnly && !d2 && 0 >= Math.min(this.min, r(this.dataMin, this.min)) && x(10, 1, c2), this.min = t(a3.log2lin(this.min), 16), this.max = t(a3.log2lin(this.max), 16));
          this.range && q2(this.max) && (this.userMin = this.min = n2 = Math.max(this.dataMin, this.minFromRange()), this.userMax = z2 = this.max, this.range = null);
          m(this, "foundExtremes");
          this.beforePadding && this.beforePadding();
          this.adjustForMinRange();
          !(k2 || this.axisPointRange || this.stacking && this.stacking.usePercentage || l2) && q2(this.min) && q2(this.max) && (c2 = this.max - this.min) && (!q2(n2) && D2 && (this.min -= c2 * D2), !q2(z2) && v2 && (this.max += c2 * v2));
          b(this.userMin) || (b(e2.softMin) && e2.softMin < this.min && (this.min = n2 = e2.softMin), b(e2.floor) && (this.min = Math.max(this.min, e2.floor)));
          b(this.userMax) || (b(e2.softMax) && e2.softMax > this.max && (this.max = z2 = e2.softMax), b(e2.ceiling) && (this.max = Math.min(this.max, e2.ceiling)));
          f3 && q2(this.dataMin) && (p3 = p3 || 0, !q2(n2) && this.min < p3 && this.dataMin >= p3 ? this.min = this.options.minRange ? Math.min(p3, this.max - this.minRange) : p3 : !q2(z2) && this.max > p3 && this.dataMax <= p3 && (this.max = this.options.minRange ? Math.max(p3, this.min + this.minRange) : p3));
          b(this.min) && b(this.max) && !this.chart.polar && this.min > this.max && (q2(this.options.min) ? this.max = this.min : q2(this.options.max) && (this.min = this.max));
          this.tickInterval = this.min === this.max || typeof this.min === "undefined" || typeof this.max === "undefined" ? 1 : l2 && this.linkedParent && !J2 && g2 === this.linkedParent.options.tickPixelInterval ? J2 = this.linkedParent.tickInterval : r(J2, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, k2 ? 1 : (this.max - this.min) * g2 / Math.max(this.len, g2));
          if (h3 && !d2) {
            var P3 = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);
            this.series.forEach(function(b2) {
              b2.forceCrop = b2.forceCropping && b2.forceCropping();
              b2.processData(P3);
            });
            m(this, "postProcessData", { hasExtemesChanged: P3 });
          }
          this.setAxisTranslation();
          m(this, "initialAxisTranslation");
          this.pointRange && !J2 && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));
          d2 = r(e2.minTickInterval, this.dateTime && !this.series.some(function(b2) {
            return b2.noSharedTooltip;
          }) ? this.closestPointRange : 0);
          !J2 && this.tickInterval < d2 && (this.tickInterval = d2);
          this.dateTime || this.logarithmic || J2 || (this.tickInterval = C2(this, this.tickInterval));
          this.tickAmount || (this.tickInterval = this.unsquish());
          this.setTickPositions();
        };
        a2.prototype.setTickPositions = function() {
          var b2 = this.options, d2 = b2.tickPositions, c2 = this.getMinorTickInterval(), a3 = this.hasVerticalPanning(), e2 = this.coll === "colorAxis", h3 = (e2 || !a3) && b2.startOnTick;
          a3 = (e2 || !a3) && b2.endOnTick;
          e2 = b2.tickPositioner;
          this.tickmarkOffset = this.categories && b2.tickmarkPlacement === "between" && this.tickInterval === 1 ? 0.5 : 0;
          this.minorTickInterval = c2 === "auto" && this.tickInterval ? this.tickInterval / 5 : c2;
          this.single = this.min === this.max && q2(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || b2.allowDecimals !== false);
          this.tickPositions = c2 = d2 && d2.slice();
          if (!c2) {
            if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)))
              if (this.dateTime)
                c2 = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, b2.units), this.min, this.max, b2.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, true);
              else if (this.logarithmic)
                c2 = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);
              else
                for (var l2 = b2 = this.tickInterval; l2 <= 2 * b2; )
                  if (c2 = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && c2.length > this.tickAmount)
                    this.tickInterval = C2(this, l2 *= 1.1);
                  else
                    break;
            else
              c2 = [this.min, this.max], x(19, false, this.chart);
            c2.length > this.len && (c2 = [c2[0], c2.pop()], c2[0] === c2[1] && (c2.length = 1));
            this.tickPositions = c2;
            e2 && (e2 = e2.apply(this, [this.min, this.max])) && (this.tickPositions = c2 = e2);
          }
          this.paddedTicks = c2.slice(0);
          this.trimTicks(c2, h3, a3);
          this.isLinked || (this.single && 2 > c2.length && !this.categories && !this.series.some(function(b3) {
            return b3.is("heatmap") && b3.options.pointPlacement === "between";
          }) && (this.min -= 0.5, this.max += 0.5), d2 || e2 || this.adjustTickAmount());
          m(this, "afterSetTickPositions");
        };
        a2.prototype.trimTicks = function(b2, d2, c2) {
          var a3 = b2[0], e2 = b2[b2.length - 1], h3 = !this.isOrdinal && this.minPointOffset || 0;
          m(this, "trimTicks");
          if (!this.isLinked) {
            if (d2 && a3 !== -Infinity)
              this.min = a3;
            else
              for (; this.min - h3 > b2[0]; )
                b2.shift();
            if (c2)
              this.max = e2;
            else
              for (; this.max + h3 < b2[b2.length - 1]; )
                b2.pop();
            b2.length === 0 && q2(a3) && !this.options.tickPositions && b2.push((e2 + a3) / 2);
          }
        };
        a2.prototype.alignToOthers = function() {
          var d2 = this, c2 = [this], a3 = d2.options, e2 = this.coll === "yAxis" && this.chart.options.chart.alignThresholds, h3 = [], l2;
          d2.thresholdAlignment = void 0;
          if ((this.chart.options.chart.alignTicks !== false && a3.alignTicks || e2) && a3.startOnTick !== false && a3.endOnTick !== false && !d2.logarithmic) {
            var g2 = function(b2) {
              var d3 = b2.options;
              return [b2.horiz ? d3.left : d3.top, d3.width, d3.height, d3.pane].join();
            }, m2 = g2(this);
            this.chart[this.coll].forEach(function(b2) {
              var a4 = b2.series;
              a4.length && a4.some(function(b3) {
                return b3.visible;
              }) && b2 !== d2 && g2(b2) === m2 && (l2 = true, c2.push(b2));
            });
          }
          if (l2 && e2) {
            c2.forEach(function(c3) {
              c3 = c3.getThresholdAlignment(d2);
              b(c3) && h3.push(c3);
            });
            var r2 = 1 < h3.length ? h3.reduce(function(b2, d3) {
              return b2 + d3;
            }, 0) / h3.length : void 0;
            c2.forEach(function(b2) {
              b2.thresholdAlignment = r2;
            });
          }
          return l2;
        };
        a2.prototype.getThresholdAlignment = function(d2) {
          (!b(this.dataMin) || this !== d2 && this.series.some(function(b2) {
            return b2.isDirty || b2.isDirtyData;
          })) && this.getSeriesExtremes();
          if (b(this.threshold))
            return d2 = g((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (d2 = 1 - d2), d2;
        };
        a2.prototype.getTickAmount = function() {
          var b2 = this.options, d2 = b2.tickPixelInterval, c2 = b2.tickAmount;
          !q2(b2.tickInterval) && !c2 && this.len < d2 && !this.isRadial && !this.logarithmic && b2.startOnTick && b2.endOnTick && (c2 = 2);
          !c2 && this.alignToOthers() && (c2 = Math.ceil(this.len / d2) + 1);
          4 > c2 && (this.finalTickAmt = c2, c2 = 5);
          this.tickAmount = c2;
        };
        a2.prototype.adjustTickAmount = function() {
          var d2 = this, c2 = d2.finalTickAmt, a3 = d2.max, e2 = d2.min, h3 = d2.options, l2 = d2.tickPositions, g2 = d2.tickAmount, m2 = d2.thresholdAlignment, k2 = l2 && l2.length, f3 = r(d2.threshold, d2.softThreshold ? 0 : null);
          var v2 = d2.tickInterval;
          if (b(m2)) {
            var D2 = 0.5 > m2 ? Math.ceil(m2 * (g2 - 1)) : Math.floor(m2 * (g2 - 1));
            h3.reversed && (D2 = g2 - 1 - D2);
          }
          if (d2.hasData() && b(e2) && b(a3)) {
            m2 = function() {
              d2.transA *= (k2 - 1) / (g2 - 1);
              d2.min = h3.startOnTick ? l2[0] : Math.min(e2, l2[0]);
              d2.max = h3.endOnTick ? l2[l2.length - 1] : Math.max(a3, l2[l2.length - 1]);
            };
            if (b(D2) && b(d2.threshold)) {
              for (; l2[D2] !== f3 || l2.length !== g2 || l2[0] > e2 || l2[l2.length - 1] < a3; ) {
                l2.length = 0;
                for (l2.push(d2.threshold); l2.length < g2; )
                  l2[D2] === void 0 || l2[D2] > d2.threshold ? l2.unshift(t(l2[0] - v2)) : l2.push(t(l2[l2.length - 1] + v2));
                if (v2 > 8 * d2.tickInterval)
                  break;
                v2 *= 2;
              }
              m2();
            } else if (k2 < g2) {
              for (; l2.length < g2; )
                l2.length % 2 || e2 === f3 ? l2.push(t(l2[l2.length - 1] + v2)) : l2.unshift(t(l2[0] - v2));
              m2();
            }
            if (q2(c2)) {
              for (v2 = f3 = l2.length; v2--; )
                (c2 === 3 && v2 % 2 === 1 || 2 >= c2 && 0 < v2 && v2 < f3 - 1) && l2.splice(v2, 1);
              d2.finalTickAmt = void 0;
            }
          }
        };
        a2.prototype.setScale = function() {
          var b2 = false, d2 = false;
          this.series.forEach(function(c3) {
            b2 = b2 || c3.isDirtyData || c3.isDirty;
            d2 = d2 || c3.xAxis && c3.xAxis.isDirty || false;
          });
          this.setAxisSize();
          var c2 = this.len !== (this.old && this.old.len);
          c2 || b2 || d2 || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = false, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = c2 || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();
          b2 && this.panningState && (this.panningState.isDirty = true);
          m(this, "afterSetScale");
        };
        a2.prototype.setExtremes = function(b2, d2, c2, a3, e2) {
          var h3 = this, l2 = h3.chart;
          c2 = r(c2, true);
          h3.series.forEach(function(b3) {
            delete b3.kdTree;
          });
          e2 = z(e2, { min: b2, max: d2 });
          m(h3, "setExtremes", e2, function() {
            h3.userMin = b2;
            h3.userMax = d2;
            h3.eventArgs = e2;
            c2 && l2.redraw(a3);
          });
        };
        a2.prototype.zoom = function(b2, d2) {
          var c2 = this, a3 = this.dataMin, e2 = this.dataMax, h3 = this.options, l2 = Math.min(a3, r(h3.min, a3)), g2 = Math.max(e2, r(h3.max, e2));
          b2 = { newMin: b2, newMax: d2 };
          m(this, "zoom", b2, function(b3) {
            var d3 = b3.newMin, h4 = b3.newMax;
            if (d3 !== c2.min || h4 !== c2.max)
              c2.allowZoomOutside || (q2(a3) && (d3 < l2 && (d3 = l2), d3 > g2 && (d3 = g2)), q2(e2) && (h4 < l2 && (h4 = l2), h4 > g2 && (h4 = g2))), c2.displayBtn = typeof d3 !== "undefined" || typeof h4 !== "undefined", c2.setExtremes(d3, h4, false, void 0, { trigger: "zoom" });
            b3.zoomed = true;
          });
          return b2.zoomed;
        };
        a2.prototype.setAxisSize = function() {
          var b2 = this.chart, d2 = this.options, c2 = d2.offsets || [0, 0, 0, 0], a3 = this.horiz, e2 = this.width = Math.round(O(r(d2.width, b2.plotWidth - c2[3] + c2[1]), b2.plotWidth)), h3 = this.height = Math.round(O(r(d2.height, b2.plotHeight - c2[0] + c2[2]), b2.plotHeight)), l2 = this.top = Math.round(O(r(d2.top, b2.plotTop + c2[0]), b2.plotHeight, b2.plotTop));
          d2 = this.left = Math.round(O(r(d2.left, b2.plotLeft + c2[3]), b2.plotWidth, b2.plotLeft));
          this.bottom = b2.chartHeight - h3 - l2;
          this.right = b2.chartWidth - e2 - d2;
          this.len = Math.max(a3 ? e2 : h3, 0);
          this.pos = a3 ? d2 : l2;
        };
        a2.prototype.getExtremes = function() {
          var b2 = this.logarithmic;
          return { min: b2 ? t(b2.lin2log(this.min)) : this.min, max: b2 ? t(b2.lin2log(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax };
        };
        a2.prototype.getThreshold = function(b2) {
          var d2 = this.logarithmic, c2 = d2 ? d2.lin2log(this.min) : this.min;
          d2 = d2 ? d2.lin2log(this.max) : this.max;
          b2 === null || b2 === -Infinity ? b2 = c2 : b2 === Infinity ? b2 = d2 : c2 > b2 ? b2 = c2 : d2 < b2 && (b2 = d2);
          return this.translate(b2, 0, 1, 0, 1);
        };
        a2.prototype.autoLabelAlign = function(b2) {
          var d2 = (r(b2, 0) - 90 * this.side + 720) % 360;
          b2 = { align: "center" };
          m(this, "autoLabelAlign", b2, function(b3) {
            15 < d2 && 165 > d2 ? b3.align = "right" : 195 < d2 && 345 > d2 && (b3.align = "left");
          });
          return b2.align;
        };
        a2.prototype.tickSize = function(b2) {
          var d2 = this.options, c2 = r(d2[b2 === "tick" ? "tickWidth" : "minorTickWidth"], b2 === "tick" && this.isXAxis && !this.categories ? 1 : 0), a3 = d2[b2 === "tick" ? "tickLength" : "minorTickLength"];
          if (c2 && a3) {
            d2[b2 + "Position"] === "inside" && (a3 = -a3);
            var e2 = [a3, c2];
          }
          b2 = { tickSize: e2 };
          m(this, "afterTickSize", b2);
          return b2.tickSize;
        };
        a2.prototype.labelMetrics = function() {
          var b2 = this.tickPositions && this.tickPositions[0] || 0;
          return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[b2] && this.ticks[b2].label);
        };
        a2.prototype.unsquish = function() {
          var d2 = this.options.labels, c2 = this.horiz, a3 = this.tickInterval, h3 = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / a3), l2 = d2.rotation, g2 = this.labelMetrics(), m2 = Math.max(this.max - this.min, 0), k2 = function(b2) {
            var d3 = b2 / (h3 || 1);
            d3 = 1 < d3 ? Math.ceil(d3) : 1;
            d3 * a3 > m2 && b2 !== Infinity && h3 !== Infinity && m2 && (d3 = Math.ceil(m2 / a3));
            return t(d3 * a3);
          }, v2 = a3, f3, D2, p3 = Number.MAX_VALUE;
          if (c2) {
            if (!d2.staggerLines && !d2.step)
              if (b(l2))
                var q3 = [l2];
              else
                h3 < d2.autoRotationLimit && (q3 = d2.autoRotation);
            q3 && q3.forEach(function(b2) {
              if (b2 === l2 || b2 && -90 <= b2 && 90 >= b2) {
                D2 = k2(Math.abs(g2.h / Math.sin(e * b2)));
                var d3 = D2 + Math.abs(b2 / 360);
                d3 < p3 && (p3 = d3, f3 = b2, v2 = D2);
              }
            });
          } else
            d2.step || (v2 = k2(g2.h));
          this.autoRotation = q3;
          this.labelRotation = r(f3, b(l2) ? l2 : 0);
          return v2;
        };
        a2.prototype.getSlotWidth = function(d2) {
          var c2 = this.chart, a3 = this.horiz, e2 = this.options.labels, h3 = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1), l2 = c2.margin[3];
          if (d2 && b(d2.slotWidth))
            return d2.slotWidth;
          if (a3 && 2 > e2.step)
            return e2.rotation ? 0 : (this.staggerLines || 1) * this.len / h3;
          if (!a3) {
            d2 = e2.style.width;
            if (d2 !== void 0)
              return parseInt(String(d2), 10);
            if (l2)
              return l2 - c2.spacing[3];
          }
          return 0.33 * c2.chartWidth;
        };
        a2.prototype.renderUnsquish = function() {
          var b2 = this.chart, d2 = b2.renderer, c2 = this.tickPositions, a3 = this.ticks, e2 = this.options.labels, h3 = e2.style, g2 = this.horiz, m2 = this.getSlotWidth(), r2 = Math.max(1, Math.round(m2 - 2 * e2.padding)), k2 = {}, v2 = this.labelMetrics(), f3 = h3.textOverflow, D2 = 0;
          l(e2.rotation) || (k2.rotation = e2.rotation || 0);
          c2.forEach(function(b3) {
            b3 = a3[b3];
            b3.movedLabel && b3.replaceMovedLabel();
            b3 && b3.label && b3.label.textPxLength > D2 && (D2 = b3.label.textPxLength);
          });
          this.maxLabelLength = D2;
          if (this.autoRotation)
            D2 > r2 && D2 > v2.h ? k2.rotation = this.labelRotation : this.labelRotation = 0;
          else if (m2) {
            var p3 = r2;
            if (!f3) {
              var q3 = "clip";
              for (r2 = c2.length; !g2 && r2--; ) {
                var n2 = c2[r2];
                if (n2 = a3[n2].label)
                  n2.styles && n2.styles.textOverflow === "ellipsis" ? n2.css({ textOverflow: "clip" }) : n2.textPxLength > m2 && n2.css({ width: m2 + "px" }), n2.getBBox().height > this.len / c2.length - (v2.h - v2.f) && (n2.specificTextOverflow = "ellipsis");
              }
            }
          }
          k2.rotation && (p3 = D2 > 0.5 * b2.chartHeight ? 0.33 * b2.chartHeight : D2, f3 || (q3 = "ellipsis"));
          if (this.labelAlign = e2.align || this.autoLabelAlign(this.labelRotation))
            k2.align = this.labelAlign;
          c2.forEach(function(b3) {
            var d3 = (b3 = a3[b3]) && b3.label, c3 = h3.width, e3 = {};
            d3 && (d3.attr(k2), b3.shortenLabel ? b3.shortenLabel() : p3 && !c3 && h3.whiteSpace !== "nowrap" && (p3 < d3.textPxLength || d3.element.tagName === "SPAN") ? (e3.width = p3 + "px", f3 || (e3.textOverflow = d3.specificTextOverflow || q3), d3.css(e3)) : d3.styles && d3.styles.width && !e3.width && !c3 && d3.css({ width: null }), delete d3.specificTextOverflow, b3.rotation = k2.rotation);
          }, this);
          this.tickRotCorr = d2.rotCorr(v2.b, this.labelRotation || 0, this.side !== 0);
        };
        a2.prototype.hasData = function() {
          return this.series.some(function(b2) {
            return b2.hasData();
          }) || this.options.showEmpty && q2(this.min) && q2(this.max);
        };
        a2.prototype.addTitle = function(b2) {
          var c2 = this.chart.renderer, a3 = this.horiz, e2 = this.opposite, h3 = this.options.title, l2 = this.chart.styledMode, g2;
          this.axisTitle || ((g2 = h3.textAlign) || (g2 = (a3 ? { low: "left", middle: "center", high: "right" } : { low: e2 ? "right" : "left", middle: "center", high: e2 ? "left" : "right" })[h3.align]), this.axisTitle = c2.text(h3.text || "", 0, 0, h3.useHTML).attr({ zIndex: 7, rotation: h3.rotation, align: g2 }).addClass("highcharts-axis-title"), l2 || this.axisTitle.css(d(h3.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = true);
          l2 || h3.style.width || this.isRadial || this.axisTitle.css({ width: this.len + "px" });
          this.axisTitle[b2 ? "show" : "hide"](b2);
        };
        a2.prototype.generateTick = function(b2) {
          var d2 = this.ticks;
          d2[b2] ? d2[b2].addLabel() : d2[b2] = new I2(this, b2);
        };
        a2.prototype.getOffset = function() {
          var b2 = this, d2 = this, c2 = d2.chart, a3 = d2.horiz, e2 = d2.options, h3 = d2.side, l2 = d2.ticks, g2 = d2.tickPositions, k2 = d2.coll, f3 = d2.axisParent, D2 = c2.renderer, p3 = c2.inverted && !d2.isZAxis ? [1, 0, 3, 2][h3] : h3, n2 = d2.hasData(), t2 = e2.title, z2 = e2.labels, y2 = c2.axisOffset;
          c2 = c2.clipOffset;
          var O2 = [
            -1,
            1,
            1,
            -1
          ][h3], P3 = e2.className, x2, F2 = 0, fa = 0, ca = 0;
          d2.showAxis = x2 = n2 || e2.showEmpty;
          d2.staggerLines = d2.horiz && z2.staggerLines || void 0;
          if (!d2.axisGroup) {
            var N3 = function(d3, c3, a4) {
              return D2.g(d3).attr({ zIndex: a4 }).addClass("highcharts-" + k2.toLowerCase() + c3 + " " + (b2.isRadial ? "highcharts-radial-axis" + c3 + " " : "") + (P3 || "")).add(f3);
            };
            d2.gridGroup = N3("grid", "-grid", e2.gridZIndex);
            d2.axisGroup = N3("axis", "", e2.zIndex);
            d2.labelGroup = N3("axis-labels", "-labels", z2.zIndex);
          }
          n2 || d2.isLinked ? (g2.forEach(function(b3) {
            d2.generateTick(b3);
          }), d2.renderUnsquish(), d2.reserveSpaceDefault = h3 === 0 || h3 === 2 || { 1: "left", 3: "right" }[h3] === d2.labelAlign, r(z2.reserveSpace, d2.labelAlign === "center" ? true : null, d2.reserveSpaceDefault) && g2.forEach(function(b3) {
            ca = Math.max(l2[b3].getLabelSize(), ca);
          }), d2.staggerLines && (ca *= d2.staggerLines), d2.labelOffset = ca * (d2.opposite ? -1 : 1)) : v(l2, function(b3, d3) {
            b3.destroy();
            delete l2[d3];
          });
          if (t2 && t2.text && t2.enabled !== false && (d2.addTitle(x2), x2 && t2.reserveSpace !== false)) {
            d2.titleOffset = F2 = d2.axisTitle.getBBox()[a3 ? "height" : "width"];
            var u2 = t2.offset;
            fa = q2(u2) ? 0 : r(t2.margin, a3 ? 5 : 10);
          }
          d2.renderLine();
          d2.offset = O2 * r(e2.offset, y2[h3] ? y2[h3] + (e2.margin || 0) : 0);
          d2.tickRotCorr = d2.tickRotCorr || { x: 0, y: 0 };
          t2 = h3 === 0 ? -d2.labelMetrics().h : h3 === 2 ? d2.tickRotCorr.y : 0;
          n2 = Math.abs(ca) + fa;
          ca && (n2 = n2 - t2 + O2 * (a3 ? r(z2.y, d2.tickRotCorr.y + 8 * O2) : z2.x));
          d2.axisTitleMargin = r(u2, n2);
          d2.getMaxLabelDimensions && (d2.maxLabelDimensions = d2.getMaxLabelDimensions(l2, g2));
          k2 !== "colorAxis" && (a3 = this.tickSize("tick"), y2[h3] = Math.max(y2[h3], (d2.axisTitleMargin || 0) + F2 + O2 * d2.offset, n2, g2 && g2.length && a3 ? a3[0] + O2 * d2.offset : 0), e2 = !d2.axisLine || e2.offset ? 0 : 2 * Math.floor(d2.axisLine.strokeWidth() / 2), c2[p3] = Math.max(c2[p3], e2));
          m(this, "afterGetOffset");
        };
        a2.prototype.getLinePath = function(b2) {
          var d2 = this.chart, c2 = this.opposite, a3 = this.offset, e2 = this.horiz, h3 = this.left + (c2 ? this.width : 0) + a3;
          a3 = d2.chartHeight - this.bottom - (c2 ? this.height : 0) + a3;
          c2 && (b2 *= -1);
          return d2.renderer.crispLine([["M", e2 ? this.left : h3, e2 ? a3 : this.top], ["L", e2 ? d2.chartWidth - this.right : h3, e2 ? a3 : d2.chartHeight - this.bottom]], b2);
        };
        a2.prototype.renderLine = function() {
          this.axisLine || (this.axisLine = this.chart.renderer.path().addClass("highcharts-axis-line").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({ stroke: this.options.lineColor, "stroke-width": this.options.lineWidth, zIndex: 7 }));
        };
        a2.prototype.getTitlePosition = function() {
          var b2 = this.horiz, d2 = this.left, c2 = this.top, a3 = this.len, e2 = this.options.title, h3 = b2 ? d2 : c2, l2 = this.opposite, g2 = this.offset, r2 = e2.x, k2 = e2.y, v2 = this.axisTitle, f3 = this.chart.renderer.fontMetrics(e2.style.fontSize, v2);
          v2 = v2 ? Math.max(v2.getBBox(false, 0).height - f3.h - 1, 0) : 0;
          a3 = { low: h3 + (b2 ? 0 : a3), middle: h3 + a3 / 2, high: h3 + (b2 ? a3 : 0) }[e2.align];
          d2 = (b2 ? c2 + this.height : d2) + (b2 ? 1 : -1) * (l2 ? -1 : 1) * (this.axisTitleMargin || 0) + [-v2, v2, f3.f, -v2][this.side];
          b2 = { x: b2 ? a3 + r2 : d2 + (l2 ? this.width : 0) + g2 + r2, y: b2 ? d2 + k2 - (l2 ? this.height : 0) + g2 : a3 + k2 };
          m(this, "afterGetTitlePosition", { titlePosition: b2 });
          return b2;
        };
        a2.prototype.renderMinorTick = function(b2, d2) {
          var c2 = this.minorTicks;
          c2[b2] || (c2[b2] = new I2(this, b2, "minor"));
          d2 && c2[b2].isNew && c2[b2].render(null, true);
          c2[b2].render(null, false, 1);
        };
        a2.prototype.renderTick = function(b2, d2, c2) {
          var a3 = this.ticks;
          if (!this.isLinked || b2 >= this.min && b2 <= this.max || this.grid && this.grid.isColumn)
            a3[b2] || (a3[b2] = new I2(this, b2)), c2 && a3[b2].isNew && a3[b2].render(d2, true, -1), a3[b2].render(d2);
        };
        a2.prototype.render = function() {
          var d2 = this, c2 = d2.chart, a3 = d2.logarithmic, e2 = d2.options, h3 = d2.isLinked, l2 = d2.tickPositions, g2 = d2.axisTitle, r2 = d2.ticks, k2 = d2.minorTicks, f3 = d2.alternateBands, D2 = e2.stackLabels, p3 = e2.alternateGridColor, q3 = d2.tickmarkOffset, n2 = d2.axisLine, t2 = d2.showAxis, z2 = u(c2.renderer.globalAnimation), y2, O2;
          d2.labelEdge.length = 0;
          d2.overlap = false;
          [r2, k2, f3].forEach(function(b2) {
            v(b2, function(b3) {
              b3.isActive = false;
            });
          });
          if (d2.hasData() || h3) {
            var P3 = d2.chart.hasRendered && d2.old && b(d2.old.min);
            d2.minorTickInterval && !d2.categories && d2.getMinorTickPositions().forEach(function(b2) {
              d2.renderMinorTick(b2, P3);
            });
            l2.length && (l2.forEach(function(b2, c3) {
              d2.renderTick(b2, c3, P3);
            }), q3 && (d2.min === 0 || d2.single) && (r2[-1] || (r2[-1] = new I2(d2, -1, null, true)), r2[-1].render(-1)));
            p3 && l2.forEach(function(b2, e3) {
              O2 = typeof l2[e3 + 1] !== "undefined" ? l2[e3 + 1] + q3 : d2.max - q3;
              e3 % 2 === 0 && b2 < d2.max && O2 <= d2.max + (c2.polar ? -q3 : q3) && (f3[b2] || (f3[b2] = new E2.PlotLineOrBand(d2)), y2 = b2 + q3, f3[b2].options = { from: a3 ? a3.lin2log(y2) : y2, to: a3 ? a3.lin2log(O2) : O2, color: p3, className: "highcharts-alternate-grid" }, f3[b2].render(), f3[b2].isActive = true);
            });
            d2._addedPlotLB || (d2._addedPlotLB = true, (e2.plotLines || []).concat(e2.plotBands || []).forEach(function(b2) {
              d2.addPlotBandOrLine(b2);
            }));
          }
          [r2, k2, f3].forEach(function(b2) {
            var d3 = [], a4 = z2.duration;
            v(b2, function(b3, c3) {
              b3.isActive || (b3.render(c3, false, 0), b3.isActive = false, d3.push(c3));
            });
            N2(function() {
              for (var c3 = d3.length; c3--; )
                b2[d3[c3]] && !b2[d3[c3]].isActive && (b2[d3[c3]].destroy(), delete b2[d3[c3]]);
            }, b2 !== f3 && c2.hasRendered && a4 ? a4 : 0);
          });
          n2 && (n2[n2.isPlaced ? "animate" : "attr"]({ d: this.getLinePath(n2.strokeWidth()) }), n2.isPlaced = true, n2[t2 ? "show" : "hide"](t2));
          g2 && t2 && (e2 = d2.getTitlePosition(), g2[g2.isNew ? "attr" : "animate"](e2), g2.isNew = false);
          D2 && D2.enabled && d2.stacking && d2.stacking.renderStackTotals();
          d2.old = { len: d2.len, max: d2.max, min: d2.min, transA: d2.transA, userMax: d2.userMax, userMin: d2.userMin };
          d2.isDirty = false;
          m(this, "afterRender");
        };
        a2.prototype.redraw = function() {
          this.visible && (this.render(), this.plotLinesAndBands.forEach(function(b2) {
            b2.render();
          }));
          this.series.forEach(function(b2) {
            b2.isDirty = true;
          });
        };
        a2.prototype.getKeepProps = function() {
          return this.keepProps || a2.keepProps;
        };
        a2.prototype.destroy = function(b2) {
          var d2 = this, c2 = d2.plotLinesAndBands, a3 = this.eventOptions;
          m(this, "destroy", { keepEvents: b2 });
          b2 || P2(d2);
          [d2.ticks, d2.minorTicks, d2.alternateBands].forEach(function(b3) {
            F(b3);
          });
          if (c2)
            for (b2 = c2.length; b2--; )
              c2[b2].destroy();
          "axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar".split(" ").forEach(function(b3) {
            d2[b3] && (d2[b3] = d2[b3].destroy());
          });
          for (var e2 in d2.plotLinesAndBandsGroups)
            d2.plotLinesAndBandsGroups[e2] = d2.plotLinesAndBandsGroups[e2].destroy();
          v(d2, function(b3, c3) {
            d2.getKeepProps().indexOf(c3) === -1 && delete d2[c3];
          });
          this.eventOptions = a3;
        };
        a2.prototype.drawCrosshair = function(b2, d2) {
          var c2 = this.crosshair, a3 = r(c2 && c2.snap, true), e2 = this.chart, h3, l2 = this.cross;
          m(this, "drawCrosshair", { e: b2, point: d2 });
          b2 || (b2 = this.cross && this.cross.e);
          if (c2 && (q2(d2) || !a3) !== false) {
            a3 ? q2(d2) && (h3 = r(this.coll !== "colorAxis" ? d2.crosshairPos : null, this.isXAxis ? d2.plotX : this.len - d2.plotY)) : h3 = b2 && (this.horiz ? b2.chartX - this.pos : this.len - b2.chartY + this.pos);
            if (q2(h3)) {
              var g2 = { value: d2 && (this.isXAxis ? d2.x : r(d2.stackY, d2.y)), translatedValue: h3 };
              e2.polar && z(g2, {
                isCrosshair: true,
                chartX: b2 && b2.chartX,
                chartY: b2 && b2.chartY,
                point: d2
              });
              g2 = this.getPlotLinePath(g2) || null;
            }
            if (!q2(g2)) {
              this.hideCrosshair();
              return;
            }
            a3 = this.categories && !this.isRadial;
            l2 || (this.cross = l2 = e2.renderer.path().addClass("highcharts-crosshair highcharts-crosshair-" + (a3 ? "category " : "thin ") + (c2.className || "")).attr({ zIndex: r(c2.zIndex, 2) }).add(), e2.styledMode || (l2.attr({ stroke: c2.color || (a3 ? B2.parse("#ccd6eb").setOpacity(0.25).get() : "#cccccc"), "stroke-width": r(c2.width, 1) }).css({ "pointer-events": "none" }), c2.dashStyle && l2.attr({ dashstyle: c2.dashStyle })));
            l2.show().attr({ d: g2 });
            a3 && !c2.width && l2.attr({ "stroke-width": this.transA });
            this.cross.e = b2;
          } else
            this.hideCrosshair();
          m(this, "afterDrawCrosshair", { e: b2, point: d2 });
        };
        a2.prototype.hideCrosshair = function() {
          this.cross && this.cross.hide();
          m(this, "afterHideCrosshair");
        };
        a2.prototype.hasVerticalPanning = function() {
          var b2 = this.chart.options.chart.panning;
          return !!(b2 && b2.enabled && /y/.test(b2.type));
        };
        a2.prototype.validatePositiveValue = function(d2) {
          return b(d2) && 0 < d2;
        };
        a2.prototype.update = function(b2, c2) {
          var a3 = this.chart;
          b2 = d(this.userOptions, b2);
          this.destroy(true);
          this.init(a3, b2);
          a3.isDirtyBox = true;
          r(c2, true) && a3.redraw();
        };
        a2.prototype.remove = function(b2) {
          for (var d2 = this.chart, c2 = this.coll, a3 = this.series, e2 = a3.length; e2--; )
            a3[e2] && a3[e2].remove(false);
          y(d2.axes, this);
          y(d2[c2], this);
          d2[c2].forEach(function(b3, d3) {
            b3.options.index = b3.userOptions.index = d3;
          });
          this.destroy();
          d2.isDirtyBox = true;
          r(b2, true) && d2.redraw();
        };
        a2.prototype.setTitle = function(b2, d2) {
          this.update({ title: b2 }, d2);
        };
        a2.prototype.setCategories = function(b2, d2) {
          this.update({ categories: b2 }, d2);
        };
        a2.defaultOptions = f2.defaultXAxisOptions;
        a2.keepProps = "extKey hcEvents names series userMax userMin".split(" ");
        return a2;
      }();
      return a;
    });
    K2(f, "Core/Axis/DateTimeAxis.js", [f["Core/Utilities.js"]], function(a) {
      var f2 = a.addEvent, B2 = a.getMagnitude, H2 = a.normalizeTickInterval, w = a.timeUnits, E2;
      (function(a2) {
        function A() {
          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);
        }
        function u(a3) {
          a3.userOptions.type !== "datetime" ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new k(this));
        }
        var n = [];
        a2.compose = function(a3) {
          n.indexOf(a3) === -1 && (n.push(a3), a3.keepProps.push("dateTime"), a3.prototype.getTimeTicks = A, f2(a3, "init", u));
          return a3;
        };
        var k = function() {
          function a3(c) {
            this.axis = c;
          }
          a3.prototype.normalizeTimeTickInterval = function(c, a4) {
            var e = a4 || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]];
            a4 = e[e.length - 1];
            var k2 = w[a4[0]], f3 = a4[1], p2;
            for (p2 = 0; p2 < e.length && !(a4 = e[p2], k2 = w[a4[0]], f3 = a4[1], e[p2 + 1] && c <= (k2 * f3[f3.length - 1] + w[e[p2 + 1][0]]) / 2); p2++)
              ;
            k2 === w.year && c < 5 * k2 && (f3 = [1, 2, 5]);
            c = H2(c / k2, f3, a4[0] === "year" ? Math.max(B2(c / k2), 1) : 1);
            return { unitRange: k2, count: c, unitName: a4[0] };
          };
          a3.prototype.getXDateFormat = function(c, a4) {
            var e = this.axis;
            return e.closestPointRange ? e.chart.time.getDateFormat(e.closestPointRange, c, e.options.startOfWeek, a4) || a4.year : a4.day;
          };
          return a3;
        }();
        a2.Additions = k;
      })(E2 || (E2 = {}));
      return E2;
    });
    K2(f, "Core/Axis/LogarithmicAxis.js", [f["Core/Utilities.js"]], function(a) {
      var f2 = a.addEvent, B2 = a.normalizeTickInterval, H2 = a.pick, w;
      (function(a2) {
        function w2(a3) {
          var e = this.logarithmic;
          a3.userOptions.type !== "logarithmic" ? this.logarithmic = void 0 : e || (this.logarithmic = new n(this));
        }
        function A() {
          var a3 = this.logarithmic;
          a3 && (this.lin2val = function(e) {
            return a3.lin2log(e);
          }, this.val2lin = function(e) {
            return a3.log2lin(e);
          });
        }
        var u = [];
        a2.compose = function(a3) {
          u.indexOf(a3) === -1 && (u.push(a3), a3.keepProps.push("logarithmic"), f2(a3, "init", w2), f2(a3, "afterInit", A));
          return a3;
        };
        var n = function() {
          function a3(a4) {
            this.axis = a4;
          }
          a3.prototype.getLogTickPositions = function(a4, c, k, g) {
            var e = this.axis, f3 = e.len, p2 = e.options, n2 = [];
            g || (this.minorAutoInterval = void 0);
            if (0.5 <= a4)
              a4 = Math.round(a4), n2 = e.getLinearTickPositions(a4, c, k);
            else if (0.08 <= a4) {
              var x = Math.floor(c), z, m = p2 = void 0;
              for (f3 = 0.3 < a4 ? [1, 2, 4] : 0.15 < a4 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; x < k + 1 && !m; x++) {
                var h2 = f3.length;
                for (z = 0; z < h2 && !m; z++) {
                  var b = this.log2lin(this.lin2log(x) * f3[z]);
                  b > c && (!g || p2 <= k) && typeof p2 !== "undefined" && n2.push(p2);
                  p2 > k && (m = true);
                  p2 = b;
                }
              }
            } else
              c = this.lin2log(c), k = this.lin2log(k), a4 = g ? e.getMinorTickInterval() : p2.tickInterval, a4 = H2(a4 === "auto" ? null : a4, this.minorAutoInterval, p2.tickPixelInterval / (g ? 5 : 1) * (k - c) / ((g ? f3 / e.tickPositions.length : f3) || 1)), a4 = B2(a4), n2 = e.getLinearTickPositions(a4, c, k).map(this.log2lin), g || (this.minorAutoInterval = a4 / 5);
            g || (e.tickInterval = a4);
            return n2;
          };
          a3.prototype.lin2log = function(a4) {
            return Math.pow(10, a4);
          };
          a3.prototype.log2lin = function(a4) {
            return Math.log(a4) / Math.LN10;
          };
          return a3;
        }();
        a2.Additions = n;
      })(w || (w = {}));
      return w;
    });
    K2(f, "Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js", [f["Core/Utilities.js"]], function(a) {
      var f2 = a.erase, B2 = a.extend, H2 = a.isNumber, w;
      (function(a2) {
        var w2 = [], A;
        a2.compose = function(a3, k) {
          A || (A = a3);
          w2.indexOf(k) === -1 && (w2.push(k), B2(k.prototype, u.prototype));
          return k;
        };
        var u = function() {
          function a3() {
          }
          a3.prototype.getPlotBandPath = function(a4, e, c) {
            c === void 0 && (c = this.options);
            var k = this.getPlotLinePath({ value: e, force: true, acrossPanes: c.acrossPanes }), g = [], f3 = this.horiz;
            e = !H2(this.min) || !H2(this.max) || a4 < this.min && e < this.min || a4 > this.max && e > this.max;
            a4 = this.getPlotLinePath({ value: a4, force: true, acrossPanes: c.acrossPanes });
            c = 1;
            if (a4 && k) {
              if (e) {
                var q2 = a4.toString() === k.toString();
                c = 0;
              }
              for (e = 0; e < a4.length; e += 2) {
                var n = a4[e], y = a4[e + 1], x = k[e], z = k[e + 1];
                n[0] !== "M" && n[0] !== "L" || y[0] !== "M" && y[0] !== "L" || x[0] !== "M" && x[0] !== "L" || z[0] !== "M" && z[0] !== "L" || (f3 && x[1] === n[1] ? (x[1] += c, z[1] += c) : f3 || x[2] !== n[2] || (x[2] += c, z[2] += c), g.push(["M", n[1], n[2]], ["L", y[1], y[2]], ["L", z[1], z[2]], ["L", x[1], x[2]], ["Z"]));
                g.isFlat = q2;
              }
            }
            return g;
          };
          a3.prototype.addPlotBand = function(a4) {
            return this.addPlotBandOrLine(a4, "plotBands");
          };
          a3.prototype.addPlotLine = function(a4) {
            return this.addPlotBandOrLine(a4, "plotLines");
          };
          a3.prototype.addPlotBandOrLine = function(a4, e) {
            var c = this, k = this.userOptions, g = new A(this, a4);
            this.visible && (g = g.render());
            if (g) {
              this._addedPlotLB || (this._addedPlotLB = true, (k.plotLines || []).concat(k.plotBands || []).forEach(function(a5) {
                c.addPlotBandOrLine(a5);
              }));
              if (e) {
                var f3 = k[e] || [];
                f3.push(a4);
                k[e] = f3;
              }
              this.plotLinesAndBands.push(g);
            }
            return g;
          };
          a3.prototype.removePlotBandOrLine = function(a4) {
            var e = this.plotLinesAndBands, c = this.options, k = this.userOptions;
            if (e) {
              for (var g = e.length; g--; )
                e[g].id === a4 && e[g].destroy();
              [c.plotLines || [], k.plotLines || [], c.plotBands || [], k.plotBands || []].forEach(function(c2) {
                for (g = c2.length; g--; )
                  (c2[g] || {}).id === a4 && f2(c2, c2[g]);
              });
            }
          };
          a3.prototype.removePlotBand = function(a4) {
            this.removePlotBandOrLine(a4);
          };
          a3.prototype.removePlotLine = function(a4) {
            this.removePlotBandOrLine(a4);
          };
          return a3;
        }();
      })(w || (w = {}));
      return w;
    });
    K2(f, "Core/Axis/PlotLineOrBand/PlotLineOrBand.js", [f["Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js"], f["Core/Utilities.js"]], function(a, f2) {
      var C2 = f2.arrayMax, H2 = f2.arrayMin, w = f2.defined, E2 = f2.destroyObjectProperties, I2 = f2.erase, A = f2.fireEvent, u = f2.merge, n = f2.objectEach, k = f2.pick;
      f2 = function() {
        function e(c, a2) {
          this.axis = c;
          a2 && (this.options = a2, this.id = a2.id);
        }
        e.compose = function(c) {
          return a.compose(e, c);
        };
        e.prototype.render = function() {
          A(this, "render");
          var c = this, a2 = c.axis, e2 = a2.horiz, f3 = a2.logarithmic, q2 = c.options, F = q2.color, y = k(q2.zIndex, 0), x = q2.events, z = {}, m = a2.chart.renderer, h2 = q2.label, b = c.label, l = q2.to, d = q2.from, D = q2.value, v = c.svgElem, r = [], O = w(d) && w(l);
          r = w(D);
          var P2 = !v, S = { "class": "highcharts-plot-" + (O ? "band " : "line ") + (q2.className || "") }, N2 = O ? "bands" : "lines";
          f3 && (d = f3.log2lin(d), l = f3.log2lin(l), D = f3.log2lin(D));
          a2.chart.styledMode || (r ? (S.stroke = F || "#999999", S["stroke-width"] = k(q2.width, 1), q2.dashStyle && (S.dashstyle = q2.dashStyle)) : O && (S.fill = F || "#e6ebf5", q2.borderWidth && (S.stroke = q2.borderColor, S["stroke-width"] = q2.borderWidth)));
          z.zIndex = y;
          N2 += "-" + y;
          (f3 = a2.plotLinesAndBandsGroups[N2]) || (a2.plotLinesAndBandsGroups[N2] = f3 = m.g("plot-" + N2).attr(z).add());
          P2 && (c.svgElem = v = m.path().attr(S).add(f3));
          if (r)
            r = a2.getPlotLinePath({ value: D, lineWidth: v.strokeWidth(), acrossPanes: q2.acrossPanes });
          else if (O)
            r = a2.getPlotBandPath(d, l, q2);
          else
            return;
          !c.eventsAdded && x && (n(x, function(b2, d2) {
            v.on(d2, function(b3) {
              x[d2].apply(c, [b3]);
            });
          }), c.eventsAdded = true);
          (P2 || !v.d) && r && r.length ? v.attr({ d: r }) : v && (r ? (v.show(), v.animate({ d: r })) : v.d && (v.hide(), b && (c.label = b = b.destroy())));
          h2 && (w(h2.text) || w(h2.formatter)) && r && r.length && 0 < a2.width && 0 < a2.height && !r.isFlat ? (h2 = u({ align: e2 && O && "center", x: e2 ? !O && 4 : 10, verticalAlign: !e2 && O && "middle", y: e2 ? O ? 16 : 10 : O ? 6 : -4, rotation: e2 && !O && 90 }, h2), this.renderLabel(h2, r, O, y)) : b && b.hide();
          return c;
        };
        e.prototype.renderLabel = function(c, a2, e2, f3) {
          var g = this.axis, k2 = g.chart.renderer, p2 = this.label;
          p2 || (this.label = p2 = k2.text(this.getLabelText(c), 0, 0, c.useHTML).attr({ align: c.textAlign || c.align, rotation: c.rotation, "class": "highcharts-plot-" + (e2 ? "band" : "line") + "-label " + (c.className || ""), zIndex: f3 }).add(), g.chart.styledMode || p2.css(u({ textOverflow: "ellipsis" }, c.style)));
          f3 = a2.xBounds || [a2[0][1], a2[1][1], e2 ? a2[2][1] : a2[0][1]];
          a2 = a2.yBounds || [a2[0][2], a2[1][2], e2 ? a2[2][2] : a2[0][2]];
          e2 = H2(f3);
          k2 = H2(a2);
          p2.align(c, false, { x: e2, y: k2, width: C2(f3) - e2, height: C2(a2) - k2 });
          p2.alignValue && p2.alignValue !== "left" || p2.css({ width: (p2.rotation === 90 ? g.height - (p2.alignAttr.y - g.top) : g.width - (p2.alignAttr.x - g.left)) + "px" });
          p2.show(true);
        };
        e.prototype.getLabelText = function(a2) {
          return w(a2.formatter) ? a2.formatter.call(this) : a2.text;
        };
        e.prototype.destroy = function() {
          I2(this.axis.plotLinesAndBands, this);
          delete this.axis;
          E2(this);
        };
        return e;
      }();
      return f2;
    });
    K2(f, "Core/Tooltip.js", [f["Core/FormatUtilities.js"], f["Core/Globals.js"], f["Core/Renderer/RendererUtilities.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2, w) {
      var C2 = a.format, I2 = f2.doc, A = B2.distribute, u = w.addEvent, n = w.clamp, k = w.css, e = w.defined, c = w.discardElement, p2 = w.extend, g = w.fireEvent, t = w.isArray, q2 = w.isNumber, F = w.isString, y = w.merge, x = w.pick, z = w.splat, m = w.syncTimeout;
      a = function() {
        function a2(b, a3) {
          this.allowShared = true;
          this.container = void 0;
          this.crosshairs = [];
          this.distance = 0;
          this.isHidden = true;
          this.isSticky = false;
          this.now = {};
          this.options = {};
          this.outside = false;
          this.chart = b;
          this.init(b, a3);
        }
        a2.prototype.applyFilter = function() {
          var b = this.chart;
          b.renderer.definition({
            tagName: "filter",
            attributes: { id: "drop-shadow-" + b.index, opacity: 0.5 },
            children: [{ tagName: "feGaussianBlur", attributes: { "in": "SourceAlpha", stdDeviation: 1 } }, { tagName: "feOffset", attributes: { dx: 1, dy: 1 } }, { tagName: "feComponentTransfer", children: [{ tagName: "feFuncA", attributes: { type: "linear", slope: 0.3 } }] }, { tagName: "feMerge", children: [{ tagName: "feMergeNode" }, { tagName: "feMergeNode", attributes: { "in": "SourceGraphic" } }] }]
          });
        };
        a2.prototype.bodyFormatter = function(b) {
          return b.map(function(b2) {
            var d = b2.series.tooltipOptions;
            return (d[(b2.point.formatPrefix || "point") + "Formatter"] || b2.point.tooltipFormatter).call(b2.point, d[(b2.point.formatPrefix || "point") + "Format"] || "");
          });
        };
        a2.prototype.cleanSplit = function(b) {
          this.chart.series.forEach(function(a3) {
            var d = a3 && a3.tt;
            d && (!d.isActive || b ? a3.tt = d.destroy() : d.isActive = false);
          });
        };
        a2.prototype.defaultFormatter = function(b) {
          var a3 = this.points || z(this);
          var d = [b.tooltipFooterHeaderFormatter(a3[0])];
          d = d.concat(b.bodyFormatter(a3));
          d.push(b.tooltipFooterHeaderFormatter(a3[0], true));
          return d;
        };
        a2.prototype.destroy = function() {
          this.label && (this.label = this.label.destroy());
          this.split && this.tt && (this.cleanSplit(true), this.tt = this.tt.destroy());
          this.renderer && (this.renderer = this.renderer.destroy(), c(this.container));
          w.clearTimeout(this.hideTimer);
          w.clearTimeout(this.tooltipTimeout);
        };
        a2.prototype.getAnchor = function(b, a3) {
          var d = this.chart, c2 = d.pointer, e2 = d.inverted, h2 = d.plotTop, l = d.plotLeft, g2, m2, f3 = 0, k2 = 0;
          b = z(b);
          this.followPointer && a3 ? (typeof a3.chartX === "undefined" && (a3 = c2.normalize(a3)), c2 = [a3.chartX - l, a3.chartY - h2]) : b[0].tooltipPos ? c2 = b[0].tooltipPos : (b.forEach(function(b2) {
            g2 = b2.series.yAxis;
            m2 = b2.series.xAxis;
            f3 += b2.plotX || 0;
            k2 += b2.plotLow ? (b2.plotLow + (b2.plotHigh || 0)) / 2 : b2.plotY || 0;
            m2 && g2 && (e2 ? (f3 += h2 + d.plotHeight - m2.len - m2.pos, k2 += l + d.plotWidth - g2.len - g2.pos) : (f3 += m2.pos - l, k2 += g2.pos - h2));
          }), f3 /= b.length, k2 /= b.length, c2 = [e2 ? d.plotWidth - k2 : f3, e2 ? d.plotHeight - f3 : k2], this.shared && 1 < b.length && a3 && (e2 ? c2[0] = a3.chartX - l : c2[1] = a3.chartY - h2));
          return c2.map(Math.round);
        };
        a2.prototype.getLabel = function() {
          var b = this, a3 = this.chart.styledMode, d = this.options, c2 = this.split && this.allowShared, h2 = "tooltip" + (e(d.className) ? " " + d.className : ""), g2 = d.style.pointerEvents || (!this.followPointer && d.stickOnContact ? "auto" : "none"), m2 = function() {
            b.inContact = true;
          }, p3 = function(d2) {
            var a4 = b.chart.hoverSeries;
            b.inContact = b.shouldStickOnContact() && b.chart.pointer.inClass(d2.relatedTarget, "highcharts-tooltip");
            if (!b.inContact && a4 && a4.onMouseOut)
              a4.onMouseOut();
          }, n2, q3 = this.chart.renderer;
          if (b.label) {
            var z2 = !b.label.hasClass("highcharts-label");
            (c2 && !z2 || !c2 && z2) && b.destroy();
          }
          if (!this.label) {
            if (this.outside) {
              z2 = this.chart.options.chart.style;
              var t2 = H2.getRendererType();
              this.container = n2 = f2.doc.createElement("div");
              n2.className = "highcharts-tooltip-container";
              k(n2, { position: "absolute", top: "1px", pointerEvents: g2, zIndex: Math.max(this.options.style.zIndex || 0, (z2 && z2.zIndex || 0) + 3) });
              u(n2, "mouseenter", m2);
              u(n2, "mouseleave", p3);
              f2.doc.body.appendChild(n2);
              this.renderer = q3 = new t2(n2, 0, 0, z2, void 0, void 0, q3.styledMode);
            }
            c2 ? this.label = q3.g(h2) : (this.label = q3.label("", 0, 0, d.shape, void 0, void 0, d.useHTML, void 0, h2).attr({ padding: d.padding, r: d.borderRadius }), a3 || this.label.attr({
              fill: d.backgroundColor,
              "stroke-width": d.borderWidth
            }).css(d.style).css({ pointerEvents: g2 }).shadow(d.shadow));
            a3 && d.shadow && (this.applyFilter(), this.label.attr({ filter: "url(#drop-shadow-" + this.chart.index + ")" }));
            if (b.outside && !b.split) {
              var y2 = this.label, x2 = y2.xSetter, F2 = y2.ySetter;
              y2.xSetter = function(d2) {
                x2.call(y2, b.distance);
                n2.style.left = d2 + "px";
              };
              y2.ySetter = function(d2) {
                F2.call(y2, b.distance);
                n2.style.top = d2 + "px";
              };
            }
            this.label.on("mouseenter", m2).on("mouseleave", p3).attr({ zIndex: 8 }).add();
          }
          return this.label;
        };
        a2.prototype.getPosition = function(b, a3, d) {
          var c2 = this.chart, e2 = this.distance, h2 = {}, l = c2.inverted && d.h || 0, g2 = this.outside, m2 = g2 ? I2.documentElement.clientWidth - 2 * e2 : c2.chartWidth, f3 = g2 ? Math.max(I2.body.scrollHeight, I2.documentElement.scrollHeight, I2.body.offsetHeight, I2.documentElement.offsetHeight, I2.documentElement.clientHeight) : c2.chartHeight, k2 = c2.pointer.getChartPosition(), p3 = function(h3) {
            var l2 = h3 === "x";
            return [h3, l2 ? m2 : f3, l2 ? b : a3].concat(g2 ? [l2 ? b * k2.scaleX : a3 * k2.scaleY, l2 ? k2.left - e2 + (d.plotX + c2.plotLeft) * k2.scaleX : k2.top - e2 + (d.plotY + c2.plotTop) * k2.scaleY, 0, l2 ? m2 : f3] : [l2 ? b : a3, l2 ? d.plotX + c2.plotLeft : d.plotY + c2.plotTop, l2 ? c2.plotLeft : c2.plotTop, l2 ? c2.plotLeft + c2.plotWidth : c2.plotTop + c2.plotHeight]);
          }, n2 = p3("y"), q3 = p3("x"), z2;
          p3 = !!d.negative;
          !c2.polar && c2.hoverSeries && c2.hoverSeries.yAxis && c2.hoverSeries.yAxis.reversed && (p3 = !p3);
          var t2 = !this.followPointer && x(d.ttBelow, !c2.inverted === p3), y2 = function(b2, d2, a4, c3, m3, f4, r) {
            var v = g2 ? b2 === "y" ? e2 * k2.scaleY : e2 * k2.scaleX : e2, D = (a4 - c3) / 2, G3 = c3 < m3 - e2, p4 = m3 + e2 + c3 < d2, n3 = m3 - v - a4 + D;
            m3 = m3 + v - D;
            if (t2 && p4)
              h2[b2] = m3;
            else if (!t2 && G3)
              h2[b2] = n3;
            else if (G3)
              h2[b2] = Math.min(r - c3, 0 > n3 - l ? n3 : n3 - l);
            else if (p4)
              h2[b2] = Math.max(f4, m3 + l + a4 > d2 ? m3 : m3 + l);
            else
              return false;
          }, F2 = function(b2, d2, a4, c3, l2) {
            var g3;
            l2 < e2 || l2 > d2 - e2 ? g3 = false : h2[b2] = l2 < a4 / 2 ? 1 : l2 > d2 - c3 / 2 ? d2 - c3 - 2 : l2 - a4 / 2;
            return g3;
          }, G2 = function(b2) {
            var d2 = n2;
            n2 = q3;
            q3 = d2;
            z2 = b2;
          }, T = function() {
            y2.apply(0, n2) !== false ? F2.apply(0, q3) !== false || z2 || (G2(true), T()) : z2 ? h2.x = h2.y = 0 : (G2(true), T());
          };
          (c2.inverted || 1 < this.len) && G2();
          T();
          return h2;
        };
        a2.prototype.hide = function(b) {
          var a3 = this;
          w.clearTimeout(this.hideTimer);
          b = x(b, this.options.hideDelay);
          this.isHidden || (this.hideTimer = m(function() {
            a3.getLabel().fadeOut(b ? void 0 : b);
            a3.isHidden = true;
          }, b));
        };
        a2.prototype.init = function(b, a3) {
          this.chart = b;
          this.options = a3;
          this.crosshairs = [];
          this.now = { x: 0, y: 0 };
          this.isHidden = true;
          this.split = a3.split && !b.inverted && !b.polar;
          this.shared = a3.shared || this.split;
          this.outside = x(a3.outside, !(!b.scrollablePixelsX && !b.scrollablePixelsY));
        };
        a2.prototype.shouldStickOnContact = function() {
          return !(this.followPointer || !this.options.stickOnContact);
        };
        a2.prototype.isStickyOnContact = function() {
          return !(!this.shouldStickOnContact() || !this.inContact);
        };
        a2.prototype.move = function(b, a3, d, c2) {
          var e2 = this, h2 = e2.now, l = e2.options.animation !== false && !e2.isHidden && (1 < Math.abs(b - h2.x) || 1 < Math.abs(a3 - h2.y)), g2 = e2.followPointer || 1 < e2.len;
          p2(h2, { x: l ? (2 * h2.x + b) / 3 : b, y: l ? (h2.y + a3) / 2 : a3, anchorX: g2 ? void 0 : l ? (2 * h2.anchorX + d) / 3 : d, anchorY: g2 ? void 0 : l ? (h2.anchorY + c2) / 2 : c2 });
          e2.getLabel().attr(h2);
          e2.drawTracker();
          l && (w.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function() {
            e2 && e2.move(b, a3, d, c2);
          }, 32));
        };
        a2.prototype.refresh = function(b, a3) {
          var d = this.chart, c2 = this.options, e2 = z(b), h2 = e2[0], l = [], m2 = c2.formatter || this.defaultFormatter, f3 = this.shared, k2 = d.styledMode, p3 = {};
          if (c2.enabled && h2.series) {
            w.clearTimeout(this.hideTimer);
            this.allowShared = !(!t(b) && b.series && b.series.noSharedTooltip);
            this.followPointer = !this.split && h2.series.tooltipOptions.followPointer;
            b = this.getAnchor(b, a3);
            var n2 = b[0], q3 = b[1];
            f3 && this.allowShared ? (d.pointer.applyInactiveState(e2), e2.forEach(function(b2) {
              b2.setState("hover");
              l.push(b2.getLabelConfig());
            }), p3 = { x: h2.category, y: h2.y }, p3.points = l) : p3 = h2.getLabelConfig();
            this.len = l.length;
            m2 = m2.call(p3, this);
            f3 = h2.series;
            this.distance = x(f3.tooltipOptions.distance, 16);
            if (m2 === false)
              this.hide();
            else {
              if (this.split && this.allowShared)
                this.renderSplit(m2, e2);
              else {
                var y2 = n2, F2 = q3;
                a3 && d.pointer.isDirectTouch && (y2 = a3.chartX - d.plotLeft, F2 = a3.chartY - d.plotTop);
                if (d.polar || f3.options.clip === false || e2.some(function(b2) {
                  return b2.series.shouldShowTooltip(y2, F2);
                }))
                  a3 = this.getLabel(), c2.style.width && !k2 || a3.css({ width: this.chart.spacingBox.width + "px" }), a3.attr({ text: m2 && m2.join ? m2.join("") : m2 }), a3.removeClass(/highcharts-color-[\d]+/g).addClass("highcharts-color-" + x(h2.colorIndex, f3.colorIndex)), k2 || a3.attr({ stroke: c2.borderColor || h2.color || f3.color || "#666666" }), this.updatePosition({ plotX: n2, plotY: q3, negative: h2.negative, ttBelow: h2.ttBelow, h: b[2] || 0 });
                else {
                  this.hide();
                  return;
                }
              }
              this.isHidden && this.label && this.label.attr({ opacity: 1 }).show();
              this.isHidden = false;
            }
            g(this, "refresh");
          }
        };
        a2.prototype.renderSplit = function(b, a3) {
          function d(b2, d2, a4, e3, h3) {
            h3 === void 0 && (h3 = true);
            a4 ? (d2 = Z2 ? 0 : E2, b2 = n(b2 - e3 / 2, M.left, M.right - e3 - (c2.outside ? R2 : 0))) : (d2 -= B3, b2 = h3 ? b2 - e3 - C3 : b2 + C3, b2 = n(b2, h3 ? b2 : M.left, M.right));
            return { x: b2, y: d2 };
          }
          var c2 = this, e2 = c2.chart, h2 = c2.chart, l = h2.chartWidth, g2 = h2.chartHeight, m2 = h2.plotHeight, f3 = h2.plotLeft, k2 = h2.plotTop, q3 = h2.pointer, z2 = h2.scrollablePixelsY;
          z2 = z2 === void 0 ? 0 : z2;
          var t2 = h2.scrollablePixelsX, y2 = h2.scrollingContainer;
          y2 = y2 === void 0 ? { scrollLeft: 0, scrollTop: 0 } : y2;
          var u2 = y2.scrollLeft;
          y2 = y2.scrollTop;
          var w2 = h2.styledMode, C3 = c2.distance, G2 = c2.options, T = c2.options.positioner, M = c2.outside && typeof t2 !== "number" ? I2.documentElement.getBoundingClientRect() : { left: u2, right: u2 + l, top: y2, bottom: y2 + g2 }, V = c2.getLabel(), W2 = this.renderer || e2.renderer, Z2 = !(!e2.xAxis[0] || !e2.xAxis[0].opposite);
          e2 = q3.getChartPosition();
          var R2 = e2.left;
          e2 = e2.top;
          var B3 = k2 + y2, aa = 0, E2 = m2 - z2;
          F(b) && (b = [false, b]);
          b = b.slice(0, a3.length + 1).reduce(function(b2, e3, h3) {
            if (e3 !== false && e3 !== "") {
              h3 = a3[h3 - 1] || { isHeader: true, plotX: a3[0].plotX, plotY: m2, series: {} };
              var l2 = h3.isHeader, g3 = l2 ? c2 : h3.series;
              e3 = e3.toString();
              var r = g3.tt, v = h3.isHeader;
              var D = h3.series;
              var p3 = "highcharts-color-" + x(h3.colorIndex, D.colorIndex, "none");
              r || (r = { padding: G2.padding, r: G2.borderRadius }, w2 || (r.fill = G2.backgroundColor, r["stroke-width"] = G2.borderWidth), r = W2.label("", 0, 0, G2[v ? "headerShape" : "shape"], void 0, void 0, G2.useHTML).addClass((v ? "highcharts-tooltip-header " : "") + "highcharts-tooltip-box " + p3).attr(r).add(V));
              r.isActive = true;
              r.attr({ text: e3 });
              w2 || r.css(G2.style).shadow(G2.shadow).attr({ stroke: G2.borderColor || h3.color || D.color || "#333333" });
              g3 = g3.tt = r;
              v = g3.getBBox();
              e3 = v.width + g3.strokeWidth();
              l2 && (aa = v.height, E2 += aa, Z2 && (B3 -= aa));
              D = h3.plotX;
              D = D === void 0 ? 0 : D;
              p3 = h3.plotY;
              p3 = p3 === void 0 ? 0 : p3;
              r = h3.series;
              if (h3.isHeader) {
                D = f3 + D;
                var q4 = k2 + m2 / 2;
              } else {
                var z3 = r.xAxis, fa = r.yAxis;
                D = z3.pos + n(D, -C3, z3.len + C3);
                r.shouldShowTooltip(0, fa.pos - k2 + p3, { ignoreX: true }) && (q4 = fa.pos + p3);
              }
              D = n(D, M.left - C3, M.right + C3);
              typeof q4 === "number" ? (v = v.height + 1, p3 = T ? T.call(c2, e3, v, h3) : d(D, q4, l2, e3), b2.push({ align: T ? 0 : void 0, anchorX: D, anchorY: q4, boxWidth: e3, point: h3, rank: x(p3.rank, l2 ? 1 : 0), size: v, target: p3.y, tt: g3, x: p3.x })) : g3.isActive = false;
            }
            return b2;
          }, []);
          !T && b.some(function(b2) {
            var d2 = (c2.outside ? R2 : 0) + b2.anchorX;
            return d2 < M.left && d2 + b2.boxWidth < M.right ? true : d2 < R2 - M.left + b2.boxWidth && M.right - d2 > d2;
          }) && (b = b.map(function(b2) {
            var a4 = d(b2.anchorX, b2.anchorY, b2.point.isHeader, b2.boxWidth, false);
            return p2(b2, { target: a4.y, x: a4.x });
          }));
          c2.cleanSplit();
          A(b, E2);
          var H3 = R2, ba = R2;
          b.forEach(function(b2) {
            var d2 = b2.x, a4 = b2.boxWidth;
            b2 = b2.isHeader;
            b2 || (c2.outside && R2 + d2 < H3 && (H3 = R2 + d2), !b2 && c2.outside && H3 + a4 > ba && (ba = R2 + d2));
          });
          b.forEach(function(b2) {
            var d2 = b2.x, a4 = b2.anchorX, e3 = b2.pos, h3 = b2.point.isHeader;
            e3 = { visibility: typeof e3 === "undefined" ? "hidden" : "inherit", x: d2, y: e3 + B3, anchorX: a4, anchorY: b2.anchorY };
            if (c2.outside && d2 < a4) {
              var l2 = R2 - H3;
              0 < l2 && (h3 || (e3.x = d2 + l2, e3.anchorX = a4 + l2), h3 && (e3.x = (ba - H3) / 2, e3.anchorX = a4 + l2));
            }
            b2.tt.attr(e3);
          });
          b = c2.container;
          z2 = c2.renderer;
          c2.outside && b && z2 && (h2 = V.getBBox(), z2.setSize(h2.width + h2.x, h2.height + h2.y, false), b.style.left = H3 + "px", b.style.top = e2 + "px");
        };
        a2.prototype.drawTracker = function() {
          if (this.followPointer || !this.options.stickOnContact)
            this.tracker && this.tracker.destroy();
          else {
            var b = this.chart, a3 = this.label, d = this.shared ? b.hoverPoints : b.hoverPoint;
            if (a3 && d) {
              var c2 = { x: 0, y: 0, width: 0, height: 0 };
              d = this.getAnchor(d);
              var e2 = a3.getBBox();
              d[0] += b.plotLeft - a3.translateX;
              d[1] += b.plotTop - a3.translateY;
              c2.x = Math.min(0, d[0]);
              c2.y = Math.min(0, d[1]);
              c2.width = 0 > d[0] ? Math.max(Math.abs(d[0]), e2.width - d[0]) : Math.max(Math.abs(d[0]), e2.width);
              c2.height = 0 > d[1] ? Math.max(Math.abs(d[1]), e2.height - Math.abs(d[1])) : Math.max(Math.abs(d[1]), e2.height);
              this.tracker ? this.tracker.attr(c2) : (this.tracker = a3.renderer.rect(c2).addClass("highcharts-tracker").add(a3), b.styledMode || this.tracker.attr({ fill: "rgba(0,0,0,0)" }));
            }
          }
        };
        a2.prototype.styledModeFormat = function(b) {
          return b.replace('style="font-size: 10px"', 'class="highcharts-header"').replace(/style="color:{(point|series)\.color}"/g, 'class="highcharts-color-{$1.colorIndex}"');
        };
        a2.prototype.tooltipFooterHeaderFormatter = function(b, a3) {
          var d = b.series, c2 = d.tooltipOptions, e2 = d.xAxis, h2 = e2 && e2.dateTime;
          e2 = { isFooter: a3, labelConfig: b };
          var l = c2.xDateFormat, m2 = c2[a3 ? "footerFormat" : "headerFormat"];
          g(this, "headerFormatter", e2, function(a4) {
            h2 && !l && q2(b.key) && (l = h2.getXDateFormat(b.key, c2.dateTimeLabelFormats));
            h2 && l && (b.point && b.point.tooltipDateKeys || ["key"]).forEach(function(b2) {
              m2 = m2.replace("{point." + b2 + "}", "{point." + b2 + ":" + l + "}");
            });
            d.chart.styledMode && (m2 = this.styledModeFormat(m2));
            a4.text = C2(m2, { point: b, series: d }, this.chart);
          });
          return e2.text;
        };
        a2.prototype.update = function(b) {
          this.destroy();
          y(true, this.chart.options.tooltip.userOptions, b);
          this.init(this.chart, y(true, this.options, b));
        };
        a2.prototype.updatePosition = function(b) {
          var a3 = this.chart, d = this.options, c2 = a3.pointer, e2 = this.getLabel();
          c2 = c2.getChartPosition();
          var h2 = (d.positioner || this.getPosition).call(this, e2.width, e2.height, b), g2 = b.plotX + a3.plotLeft;
          b = b.plotY + a3.plotTop;
          if (this.outside) {
            d = d.borderWidth + 2 * this.distance;
            this.renderer.setSize(e2.width + d, e2.height + d, false);
            if (c2.scaleX !== 1 || c2.scaleY !== 1)
              k(this.container, { transform: "scale(" + c2.scaleX + ", " + c2.scaleY + ")" }), g2 *= c2.scaleX, b *= c2.scaleY;
            g2 += c2.left - h2.x;
            b += c2.top - h2.y;
          }
          this.move(Math.round(h2.x), Math.round(h2.y || 0), g2, b);
        };
        return a2;
      }();
      return a;
    });
    K2(f, "Core/Series/Point.js", [f["Core/Renderer/HTML/AST.js"], f["Core/Animation/AnimationUtilities.js"], f["Core/DefaultOptions.js"], f["Core/FormatUtilities.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2, w) {
      var C2 = f2.animObject, I2 = B2.defaultOptions, A = H2.format, u = w.addEvent, n = w.defined, k = w.erase, e = w.extend, c = w.fireEvent, p2 = w.getNestedProperty, g = w.isArray, t = w.isFunction, q2 = w.isNumber, F = w.isObject, y = w.merge, x = w.objectEach, z = w.pick, m = w.syncTimeout, h2 = w.removeEvent, b = w.uniqueKey;
      f2 = function() {
        function l() {
          this.colorIndex = this.category = void 0;
          this.formatPrefix = "point";
          this.id = void 0;
          this.isNull = false;
          this.percentage = this.options = this.name = void 0;
          this.selected = false;
          this.total = this.series = void 0;
          this.visible = true;
          this.x = void 0;
        }
        l.prototype.animateBeforeDestroy = function() {
          var b2 = this, a2 = { x: b2.startXPos, opacity: 0 }, c2 = b2.getGraphicalProps();
          c2.singular.forEach(function(d) {
            b2[d] = b2[d].animate(d === "dataLabel" ? { x: b2[d].startXPos, y: b2[d].startYPos, opacity: 0 } : a2);
          });
          c2.plural.forEach(function(d) {
            b2[d].forEach(function(d2) {
              d2.element && d2.animate(e({ x: b2.startXPos }, d2.startYPos ? { x: d2.startXPos, y: d2.startYPos } : {}));
            });
          });
        };
        l.prototype.applyOptions = function(b2, a2) {
          var d = this.series, c2 = d.options.pointValKey || d.pointValKey;
          b2 = l.prototype.optionsToObject.call(this, b2);
          e(this, b2);
          this.options = this.options ? e(this.options, b2) : b2;
          b2.group && delete this.group;
          b2.dataLabels && delete this.dataLabels;
          c2 && (this.y = l.prototype.getNestedProperty.call(this, c2));
          this.formatPrefix = (this.isNull = z(this.isValid && !this.isValid(), this.x === null || !q2(this.y))) ? "null" : "point";
          this.selected && (this.state = "select");
          "name" in this && typeof a2 === "undefined" && d.xAxis && d.xAxis.hasNames && (this.x = d.xAxis.nameToX(this));
          typeof this.x === "undefined" && d ? this.x = typeof a2 === "undefined" ? d.autoIncrement() : a2 : q2(b2.x) && d.options.relativeXValue && (this.x = d.autoIncrement(b2.x));
          return this;
        };
        l.prototype.destroy = function() {
          function b2() {
            if (a2.graphic || a2.dataLabel || a2.dataLabels)
              h2(a2), a2.destroyElements();
            for (f3 in a2)
              a2[f3] = null;
          }
          var a2 = this, c2 = a2.series, e2 = c2.chart;
          c2 = c2.options.dataSorting;
          var l2 = e2.hoverPoints, g2 = C2(a2.series.chart.renderer.globalAnimation), f3;
          a2.legendItem && e2.legend.destroyItem(a2);
          l2 && (a2.setState(), k(l2, a2), l2.length || (e2.hoverPoints = null));
          if (a2 === e2.hoverPoint)
            a2.onMouseOut();
          c2 && c2.enabled ? (this.animateBeforeDestroy(), m(b2, g2.duration)) : b2();
          e2.pointCount--;
        };
        l.prototype.destroyElements = function(b2) {
          var d = this;
          b2 = d.getGraphicalProps(b2);
          b2.singular.forEach(function(b3) {
            d[b3] = d[b3].destroy();
          });
          b2.plural.forEach(function(b3) {
            d[b3].forEach(function(b4) {
              b4.element && b4.destroy();
            });
            delete d[b3];
          });
        };
        l.prototype.firePointEvent = function(b2, a2, e2) {
          var d = this, h3 = this.series.options;
          (h3.point.events[b2] || d.options && d.options.events && d.options.events[b2]) && d.importEvents();
          b2 === "click" && h3.allowPointSelect && (e2 = function(b3) {
            d.select && d.select(null, b3.ctrlKey || b3.metaKey || b3.shiftKey);
          });
          c(d, b2, a2, e2);
        };
        l.prototype.getClassName = function() {
          return "highcharts-point" + (this.selected ? " highcharts-point-select" : "") + (this.negative ? " highcharts-negative" : "") + (this.isNull ? " highcharts-null-point" : "") + (typeof this.colorIndex !== "undefined" ? " highcharts-color-" + this.colorIndex : "") + (this.options.className ? " " + this.options.className : "") + (this.zone && this.zone.className ? " " + this.zone.className.replace("highcharts-negative", "") : "");
        };
        l.prototype.getGraphicalProps = function(b2) {
          var d = this, a2 = [], c2 = { singular: [], plural: [] }, e2;
          b2 = b2 || { graphic: 1, dataLabel: 1 };
          b2.graphic && a2.push("graphic", "upperGraphic", "shadowGroup");
          b2.dataLabel && a2.push("dataLabel", "dataLabelUpper", "connector");
          for (e2 = a2.length; e2--; ) {
            var h3 = a2[e2];
            d[h3] && c2.singular.push(h3);
          }
          ["dataLabel", "connector"].forEach(function(a3) {
            var e3 = a3 + "s";
            b2[a3] && d[e3] && c2.plural.push(e3);
          });
          return c2;
        };
        l.prototype.getLabelConfig = function() {
          return { x: this.category, y: this.y, color: this.color, colorIndex: this.colorIndex, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal };
        };
        l.prototype.getNestedProperty = function(b2) {
          if (b2)
            return b2.indexOf("custom.") === 0 ? p2(b2, this.options) : this[b2];
        };
        l.prototype.getZone = function() {
          var b2 = this.series, a2 = b2.zones;
          b2 = b2.zoneAxis || "y";
          var c2, e2 = 0;
          for (c2 = a2[e2]; this[b2] >= c2.value; )
            c2 = a2[++e2];
          this.nonZonedColor || (this.nonZonedColor = this.color);
          this.color = c2 && c2.color && !this.options.color ? c2.color : this.nonZonedColor;
          return c2;
        };
        l.prototype.hasNewShapeType = function() {
          return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;
        };
        l.prototype.init = function(d, a2, e2) {
          this.series = d;
          this.applyOptions(a2, e2);
          this.id = n(this.id) ? this.id : b();
          this.resolveColor();
          d.chart.pointCount++;
          c(this, "afterInit");
          return this;
        };
        l.prototype.optionsToObject = function(b2) {
          var d = this.series, a2 = d.options.keys, c2 = a2 || d.pointArrayMap || ["y"], e2 = c2.length, h3 = {}, m2 = 0, f3 = 0;
          if (q2(b2) || b2 === null)
            h3[c2[0]] = b2;
          else if (g(b2))
            for (!a2 && b2.length > e2 && (d = typeof b2[0], d === "string" ? h3.name = b2[0] : d === "number" && (h3.x = b2[0]), m2++); f3 < e2; )
              a2 && typeof b2[m2] === "undefined" || (0 < c2[f3].indexOf(".") ? l.prototype.setNestedProperty(h3, b2[m2], c2[f3]) : h3[c2[f3]] = b2[m2]), m2++, f3++;
          else
            typeof b2 === "object" && (h3 = b2, b2.dataLabels && (d._hasPointLabels = true), b2.marker && (d._hasPointMarkers = true));
          return h3;
        };
        l.prototype.resolveColor = function() {
          var b2 = this.series, a2 = b2.chart.styledMode;
          var c2 = b2.chart.options.chart.colorCount;
          delete this.nonZonedColor;
          if (b2.options.colorByPoint) {
            if (!a2) {
              c2 = b2.options.colors || b2.chart.options.colors;
              var e2 = c2[b2.colorCounter];
              c2 = c2.length;
            }
            a2 = b2.colorCounter;
            b2.colorCounter++;
            b2.colorCounter === c2 && (b2.colorCounter = 0);
          } else
            a2 || (e2 = b2.color), a2 = b2.colorIndex;
          this.colorIndex = z(this.options.colorIndex, a2);
          this.color = z(this.options.color, e2);
        };
        l.prototype.setNestedProperty = function(b2, a2, c2) {
          c2.split(".").reduce(function(b3, d, c3, e2) {
            b3[d] = e2.length - 1 === c3 ? a2 : F(b3[d], true) ? b3[d] : {};
            return b3[d];
          }, b2);
          return b2;
        };
        l.prototype.tooltipFormatter = function(b2) {
          var d = this.series, a2 = d.tooltipOptions, c2 = z(a2.valueDecimals, ""), e2 = a2.valuePrefix || "", h3 = a2.valueSuffix || "";
          d.chart.styledMode && (b2 = d.chart.tooltip.styledModeFormat(b2));
          (d.pointArrayMap || ["y"]).forEach(function(d2) {
            d2 = "{point." + d2;
            if (e2 || h3)
              b2 = b2.replace(RegExp(d2 + "}", "g"), e2 + d2 + "}" + h3);
            b2 = b2.replace(RegExp(d2 + "}", "g"), d2 + ":,." + c2 + "f}");
          });
          return A(b2, { point: this, series: this.series }, d.chart);
        };
        l.prototype.update = function(b2, a2, c2, e2) {
          function d() {
            h3.applyOptions(b2);
            var d2 = g2 && h3.hasDummyGraphic;
            d2 = h3.y === null ? !d2 : d2;
            g2 && d2 && (h3.graphic = g2.destroy(), delete h3.hasDummyGraphic);
            F(b2, true) && (g2 && g2.element && b2 && b2.marker && typeof b2.marker.symbol !== "undefined" && (h3.graphic = g2.destroy()), b2 && b2.dataLabels && h3.dataLabel && (h3.dataLabel = h3.dataLabel.destroy()), h3.connector && (h3.connector = h3.connector.destroy()));
            k2 = h3.index;
            l2.updateParallelArrays(h3, k2);
            f3.data[k2] = F(f3.data[k2], true) || F(b2, true) ? h3.options : z(b2, f3.data[k2]);
            l2.isDirty = l2.isDirtyData = true;
            !l2.fixedBox && l2.hasCartesianSeries && (m2.isDirtyBox = true);
            f3.legendType === "point" && (m2.isDirtyLegend = true);
            a2 && m2.redraw(c2);
          }
          var h3 = this, l2 = h3.series, g2 = h3.graphic, m2 = l2.chart, f3 = l2.options, k2;
          a2 = z(a2, true);
          e2 === false ? d() : h3.firePointEvent("update", { options: b2 }, d);
        };
        l.prototype.remove = function(b2, a2) {
          this.series.removePoint(this.series.data.indexOf(this), b2, a2);
        };
        l.prototype.select = function(b2, a2) {
          var d = this, c2 = d.series, e2 = c2.chart;
          this.selectedStaging = b2 = z(b2, !d.selected);
          d.firePointEvent(b2 ? "select" : "unselect", { accumulate: a2 }, function() {
            d.selected = d.options.selected = b2;
            c2.options.data[c2.data.indexOf(d)] = d.options;
            d.setState(b2 && "select");
            a2 || e2.getSelectedPoints().forEach(function(b3) {
              var a3 = b3.series;
              b3.selected && b3 !== d && (b3.selected = b3.options.selected = false, a3.options.data[a3.data.indexOf(b3)] = b3.options, b3.setState(e2.hoverPoints && a3.options.inactiveOtherPoints ? "inactive" : ""), b3.firePointEvent("unselect"));
            });
          });
          delete this.selectedStaging;
        };
        l.prototype.onMouseOver = function(b2) {
          var d = this.series.chart, a2 = d.pointer;
          b2 = b2 ? a2.normalize(b2) : a2.getChartCoordinatesFromPoint(this, d.inverted);
          a2.runPointActions(b2, this);
        };
        l.prototype.onMouseOut = function() {
          var b2 = this.series.chart;
          this.firePointEvent("mouseOut");
          this.series.options.inactiveOtherPoints || (b2.hoverPoints || []).forEach(function(b3) {
            b3.setState();
          });
          b2.hoverPoints = b2.hoverPoint = null;
        };
        l.prototype.importEvents = function() {
          if (!this.hasImportedEvents) {
            var b2 = this, a2 = y(b2.series.options.point, b2.options).events;
            b2.events = a2;
            x(a2, function(d, a3) {
              t(d) && u(b2, a3, d);
            });
            this.hasImportedEvents = true;
          }
        };
        l.prototype.setState = function(b2, h3) {
          var d = this.series, l2 = this.state, g2 = d.options.states[b2 || "normal"] || {}, m2 = I2.plotOptions[d.type].marker && d.options.marker, f3 = m2 && m2.enabled === false, k2 = m2 && m2.states && m2.states[b2 || "normal"] || {}, p3 = k2.enabled === false, n2 = this.marker || {}, D = d.chart, y2 = m2 && d.markerAttribs, t2 = d.halo, x2, F2 = d.stateMarkerGraphic;
          b2 = b2 || "";
          if (!(b2 === this.state && !h3 || this.selected && b2 !== "select" || g2.enabled === false || b2 && (p3 || f3 && k2.enabled === false) || b2 && n2.states && n2.states[b2] && n2.states[b2].enabled === false)) {
            this.state = b2;
            y2 && (x2 = d.markerAttribs(this, b2));
            if (this.graphic && !this.hasDummyGraphic) {
              l2 && this.graphic.removeClass("highcharts-point-" + l2);
              b2 && this.graphic.addClass("highcharts-point-" + b2);
              if (!D.styledMode) {
                var u2 = d.pointAttribs(this, b2);
                var G2 = z(D.options.chart.animation, g2.animation);
                d.options.inactiveOtherPoints && q2(u2.opacity) && ((this.dataLabels || []).forEach(function(b3) {
                  b3 && b3.animate({ opacity: u2.opacity }, G2);
                }), this.connector && this.connector.animate({ opacity: u2.opacity }, G2));
                this.graphic.animate(u2, G2);
              }
              x2 && this.graphic.animate(x2, z(D.options.chart.animation, k2.animation, m2.animation));
              F2 && F2.hide();
            } else {
              if (b2 && k2) {
                l2 = n2.symbol || d.symbol;
                F2 && F2.currentSymbol !== l2 && (F2 = F2.destroy());
                if (x2)
                  if (F2)
                    F2[h3 ? "animate" : "attr"]({ x: x2.x, y: x2.y });
                  else
                    l2 && (d.stateMarkerGraphic = F2 = D.renderer.symbol(l2, x2.x, x2.y, x2.width, x2.height).add(d.markerGroup), F2.currentSymbol = l2);
                !D.styledMode && F2 && this.state !== "inactive" && F2.attr(d.pointAttribs(this, b2));
              }
              F2 && (F2[b2 && this.isInside ? "show" : "hide"](), F2.element.point = this, F2.addClass(this.getClassName(), true));
            }
            g2 = g2.halo;
            x2 = (F2 = this.graphic || F2) && F2.visibility || "inherit";
            g2 && g2.size && F2 && x2 !== "hidden" && !this.isCluster ? (t2 || (d.halo = t2 = D.renderer.path().add(F2.parentGroup)), t2.show()[h3 ? "animate" : "attr"]({ d: this.haloPath(g2.size) }), t2.attr({ "class": "highcharts-halo highcharts-color-" + z(this.colorIndex, d.colorIndex) + (this.className ? " " + this.className : ""), visibility: x2, zIndex: -1 }), t2.point = this, D.styledMode || t2.attr(e({ fill: this.color || d.color, "fill-opacity": g2.opacity }, a.filterUserAttributes(g2.attributes || {})))) : t2 && t2.point && t2.point.haloPath && t2.animate({ d: t2.point.haloPath(0) }, null, t2.hide);
            c(this, "afterSetState", { state: b2 });
          }
        };
        l.prototype.haloPath = function(b2) {
          return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - b2, this.plotY - b2, 2 * b2, 2 * b2);
        };
        return l;
      }();
      return f2;
    });
    K2(f, "Core/Pointer.js", [f["Core/Color/Color.js"], f["Core/Globals.js"], f["Core/Tooltip.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2) {
      var w = a.parse, C2 = f2.charts, I2 = f2.noop, A = H2.addEvent, u = H2.attr, n = H2.css, k = H2.defined, e = H2.extend, c = H2.find, p2 = H2.fireEvent, g = H2.isNumber, t = H2.isObject, q2 = H2.objectEach, F = H2.offset, y = H2.pick, x = H2.splat;
      a = function() {
        function a2(a3, c2) {
          this.lastValidTouch = {};
          this.pinchDown = [];
          this.runChartClick = false;
          this.eventsToUnbind = [];
          this.chart = a3;
          this.hasDragged = false;
          this.options = c2;
          this.init(a3, c2);
        }
        a2.prototype.applyInactiveState = function(a3) {
          var c2 = [], b;
          (a3 || []).forEach(function(a4) {
            b = a4.series;
            c2.push(b);
            b.linkedParent && c2.push(b.linkedParent);
            b.linkedSeries && (c2 = c2.concat(b.linkedSeries));
            b.navigatorSeries && c2.push(b.navigatorSeries);
          });
          this.chart.series.forEach(function(b2) {
            c2.indexOf(b2) === -1 ? b2.setState("inactive", true) : b2.options.inactiveOtherPoints && b2.setAllPointsToState("inactive");
          });
        };
        a2.prototype.destroy = function() {
          var c2 = this;
          this.eventsToUnbind.forEach(function(a3) {
            return a3();
          });
          this.eventsToUnbind = [];
          f2.chartCount || (a2.unbindDocumentMouseUp && (a2.unbindDocumentMouseUp = a2.unbindDocumentMouseUp()), a2.unbindDocumentTouchEnd && (a2.unbindDocumentTouchEnd = a2.unbindDocumentTouchEnd()));
          clearInterval(c2.tooltipTimeout);
          q2(c2, function(a3, b) {
            c2[b] = void 0;
          });
        };
        a2.prototype.drag = function(a3) {
          var c2 = this.chart, b = c2.options.chart, e2 = this.zoomHor, d = this.zoomVert, g2 = c2.plotLeft, m = c2.plotTop, f3 = c2.plotWidth, k2 = c2.plotHeight, p3 = this.mouseDownX || 0, n2 = this.mouseDownY || 0, q3 = t(b.panning) ? b.panning && b.panning.enabled : b.panning, y2 = b.panKey && a3[b.panKey + "Key"], x2 = a3.chartX, z = a3.chartY, F2 = this.selectionMarker;
          if (!F2 || !F2.touch) {
            if (x2 < g2 ? x2 = g2 : x2 > g2 + f3 && (x2 = g2 + f3), z < m ? z = m : z > m + k2 && (z = m + k2), this.hasDragged = Math.sqrt(Math.pow(p3 - x2, 2) + Math.pow(n2 - z, 2)), 10 < this.hasDragged) {
              var u2 = c2.isInsidePlot(p3 - g2, n2 - m, { visiblePlotOnly: true });
              !c2.hasCartesianSeries && !c2.mapView || !this.zoomX && !this.zoomY || !u2 || y2 || F2 || (this.selectionMarker = F2 = c2.renderer.rect(g2, m, e2 ? 1 : f3, d ? 1 : k2, 0).attr({ "class": "highcharts-selection-marker", zIndex: 7 }).add(), c2.styledMode || F2.attr({ fill: b.selectionMarkerFill || w("#335cad").setOpacity(0.25).get() }));
              F2 && e2 && (e2 = x2 - p3, F2.attr({ width: Math.abs(e2), x: (0 < e2 ? 0 : e2) + p3 }));
              F2 && d && (e2 = z - n2, F2.attr({ height: Math.abs(e2), y: (0 < e2 ? 0 : e2) + n2 }));
              u2 && !F2 && q3 && c2.pan(a3, b.panning);
            }
          }
        };
        a2.prototype.dragStart = function(a3) {
          var c2 = this.chart;
          c2.mouseIsDown = a3.type;
          c2.cancelClick = false;
          c2.mouseDownX = this.mouseDownX = a3.chartX;
          c2.mouseDownY = this.mouseDownY = a3.chartY;
        };
        a2.prototype.drop = function(a3) {
          var c2 = this, b = this.chart, l = this.hasPinched;
          if (this.selectionMarker) {
            var d = this.selectionMarker, m = d.attr ? d.attr("x") : d.x, f3 = d.attr ? d.attr("y") : d.y, r = d.attr ? d.attr("width") : d.width, q3 = d.attr ? d.attr("height") : d.height, t2 = { originalEvent: a3, xAxis: [], yAxis: [], x: m, y: f3, width: r, height: q3 }, y2 = !!b.mapView;
            if (this.hasDragged || l)
              b.axes.forEach(function(b2) {
                if (b2.zoomEnabled && k(b2.min) && (l || c2[{ xAxis: "zoomX", yAxis: "zoomY" }[b2.coll]]) && g(m) && g(f3)) {
                  var d2 = b2.horiz, e2 = a3.type === "touchend" ? b2.minPixelPadding : 0, h2 = b2.toValue((d2 ? m : f3) + e2);
                  d2 = b2.toValue((d2 ? m + r : f3 + q3) - e2);
                  t2[b2.coll].push({ axis: b2, min: Math.min(h2, d2), max: Math.max(h2, d2) });
                  y2 = true;
                }
              }), y2 && p2(b, "selection", t2, function(d2) {
                b.zoom(e(d2, l ? { animation: false } : null));
              });
            g(b.index) && (this.selectionMarker = this.selectionMarker.destroy());
            l && this.scaleGroups();
          }
          b && g(b.index) && (n(b.container, { cursor: b._cursor }), b.cancelClick = 10 < this.hasDragged, b.mouseIsDown = this.hasDragged = this.hasPinched = false, this.pinchDown = []);
        };
        a2.prototype.findNearestKDPoint = function(a3, c2, b) {
          var e2 = this.chart, d = e2.hoverPoint;
          e2 = e2.tooltip;
          if (d && e2 && e2.isStickyOnContact())
            return d;
          var h2;
          a3.forEach(function(d2) {
            var a4 = !(d2.noSharedTooltip && c2) && 0 > d2.options.findNearestPointBy.indexOf("y");
            d2 = d2.searchPoint(b, a4);
            if ((a4 = t(d2, true) && d2.series) && !(a4 = !t(h2, true))) {
              a4 = h2.distX - d2.distX;
              var e3 = h2.dist - d2.dist, l = (d2.series.group && d2.series.group.zIndex) - (h2.series.group && h2.series.group.zIndex);
              a4 = 0 < (a4 !== 0 && c2 ? a4 : e3 !== 0 ? e3 : l !== 0 ? l : h2.series.index > d2.series.index ? -1 : 1);
            }
            a4 && (h2 = d2);
          });
          return h2;
        };
        a2.prototype.getChartCoordinatesFromPoint = function(a3, c2) {
          var b = a3.series, e2 = b.xAxis;
          b = b.yAxis;
          var d = a3.shapeArgs;
          if (e2 && b) {
            var h2 = y(a3.clientX, a3.plotX), m = a3.plotY || 0;
            a3.isNode && d && g(d.x) && g(d.y) && (h2 = d.x, m = d.y);
            return c2 ? { chartX: b.len + b.pos - m, chartY: e2.len + e2.pos - h2 } : { chartX: h2 + e2.pos, chartY: m + b.pos };
          }
          if (d && d.x && d.y)
            return { chartX: d.x, chartY: d.y };
        };
        a2.prototype.getChartPosition = function() {
          if (this.chartPosition)
            return this.chartPosition;
          var a3 = this.chart.container, c2 = F(a3);
          this.chartPosition = { left: c2.left, top: c2.top, scaleX: 1, scaleY: 1 };
          var b = a3.offsetWidth;
          a3 = a3.offsetHeight;
          2 < b && 2 < a3 && (this.chartPosition.scaleX = c2.width / b, this.chartPosition.scaleY = c2.height / a3);
          return this.chartPosition;
        };
        a2.prototype.getCoordinates = function(a3) {
          var c2 = { xAxis: [], yAxis: [] };
          this.chart.axes.forEach(function(b) {
            c2[b.isXAxis ? "xAxis" : "yAxis"].push({ axis: b, value: b.toValue(a3[b.horiz ? "chartX" : "chartY"]) });
          });
          return c2;
        };
        a2.prototype.getHoverData = function(a3, e2, b, l, d, g2) {
          var h2 = [];
          l = !(!l || !a3);
          var m = { chartX: g2 ? g2.chartX : void 0, chartY: g2 ? g2.chartY : void 0, shared: d };
          p2(this, "beforeGetHoverData", m);
          var f3 = e2 && !e2.stickyTracking ? [e2] : b.filter(function(b2) {
            return m.filter ? m.filter(b2) : b2.visible && !(!d && b2.directTouch) && y(b2.options.enableMouseTracking, true) && b2.stickyTracking;
          });
          var k2 = l || !g2 ? a3 : this.findNearestKDPoint(f3, d, g2);
          e2 = k2 && k2.series;
          k2 && (d && !e2.noSharedTooltip ? (f3 = b.filter(function(b2) {
            return m.filter ? m.filter(b2) : b2.visible && !(!d && b2.directTouch) && y(b2.options.enableMouseTracking, true) && !b2.noSharedTooltip;
          }), f3.forEach(function(b2) {
            var d2 = c(b2.points, function(b3) {
              return b3.x === k2.x && !b3.isNull;
            });
            t(d2) && (b2.chart.isBoosting && (d2 = b2.getPoint(d2)), h2.push(d2));
          })) : h2.push(k2));
          m = { hoverPoint: k2 };
          p2(this, "afterGetHoverData", m);
          return { hoverPoint: m.hoverPoint, hoverSeries: e2, hoverPoints: h2 };
        };
        a2.prototype.getPointFromEvent = function(a3) {
          a3 = a3.target;
          for (var c2; a3 && !c2; )
            c2 = a3.point, a3 = a3.parentNode;
          return c2;
        };
        a2.prototype.onTrackerMouseOut = function(a3) {
          a3 = a3.relatedTarget || a3.toElement;
          var c2 = this.chart.hoverSeries;
          this.isDirectTouch = false;
          if (!(!c2 || !a3 || c2.stickyTracking || this.inClass(a3, "highcharts-tooltip") || this.inClass(a3, "highcharts-series-" + c2.index) && this.inClass(a3, "highcharts-tracker")))
            c2.onMouseOut();
        };
        a2.prototype.inClass = function(a3, c2) {
          for (var b; a3; ) {
            if (b = u(a3, "class")) {
              if (b.indexOf(c2) !== -1)
                return true;
              if (b.indexOf("highcharts-container") !== -1)
                return false;
            }
            a3 = a3.parentElement;
          }
        };
        a2.prototype.init = function(a3, c2) {
          this.options = c2;
          this.chart = a3;
          this.runChartClick = !(!c2.chart.events || !c2.chart.events.click);
          this.pinchDown = [];
          this.lastValidTouch = {};
          B2 && (a3.tooltip = new B2(a3, c2.tooltip), this.followTouchMove = y(c2.tooltip.followTouchMove, true));
          this.setDOMEvents();
        };
        a2.prototype.normalize = function(a3, c2) {
          var b = a3.touches, h2 = b ? b.length ? b.item(0) : y(b.changedTouches, a3.changedTouches)[0] : a3;
          c2 || (c2 = this.getChartPosition());
          b = h2.pageX - c2.left;
          h2 = h2.pageY - c2.top;
          b /= c2.scaleX;
          h2 /= c2.scaleY;
          return e(a3, { chartX: Math.round(b), chartY: Math.round(h2) });
        };
        a2.prototype.onContainerClick = function(a3) {
          var c2 = this.chart, b = c2.hoverPoint;
          a3 = this.normalize(a3);
          var l = c2.plotLeft, d = c2.plotTop;
          c2.cancelClick || (b && this.inClass(a3.target, "highcharts-tracker") ? (p2(b.series, "click", e(a3, { point: b })), c2.hoverPoint && b.firePointEvent("click", a3)) : (e(a3, this.getCoordinates(a3)), c2.isInsidePlot(a3.chartX - l, a3.chartY - d, { visiblePlotOnly: true }) && p2(c2, "click", a3)));
        };
        a2.prototype.onContainerMouseDown = function(a3) {
          var c2 = ((a3.buttons || a3.button) & 1) === 1;
          a3 = this.normalize(a3);
          if (f2.isFirefox && a3.button !== 0)
            this.onContainerMouseMove(a3);
          if (typeof a3.button === "undefined" || c2)
            this.zoomOption(a3), c2 && a3.preventDefault && a3.preventDefault(), this.dragStart(a3);
        };
        a2.prototype.onContainerMouseLeave = function(c2) {
          var e2 = C2[y(a2.hoverChartIndex, -1)], b = this.chart.tooltip;
          b && b.shouldStickOnContact() && this.inClass(c2.relatedTarget, "highcharts-tooltip-container") || (c2 = this.normalize(c2), e2 && (c2.relatedTarget || c2.toElement) && (e2.pointer.reset(), e2.pointer.chartPosition = void 0), b && !b.isHidden && this.reset());
        };
        a2.prototype.onContainerMouseEnter = function(a3) {
          delete this.chartPosition;
        };
        a2.prototype.onContainerMouseMove = function(a3) {
          var c2 = this.chart;
          a3 = this.normalize(a3);
          this.setHoverChartIndex();
          a3.preventDefault || (a3.returnValue = false);
          (c2.mouseIsDown === "mousedown" || this.touchSelect(a3)) && this.drag(a3);
          c2.openMenu || !this.inClass(a3.target, "highcharts-tracker") && !c2.isInsidePlot(a3.chartX - c2.plotLeft, a3.chartY - c2.plotTop, { visiblePlotOnly: true }) || (this.inClass(a3.target, "highcharts-no-tooltip") ? this.reset(false, 0) : this.runPointActions(a3));
        };
        a2.prototype.onDocumentTouchEnd = function(c2) {
          var e2 = C2[y(a2.hoverChartIndex, -1)];
          e2 && e2.pointer.drop(c2);
        };
        a2.prototype.onContainerTouchMove = function(a3) {
          if (this.touchSelect(a3))
            this.onContainerMouseMove(a3);
          else
            this.touch(a3);
        };
        a2.prototype.onContainerTouchStart = function(a3) {
          if (this.touchSelect(a3))
            this.onContainerMouseDown(a3);
          else
            this.zoomOption(a3), this.touch(a3, true);
        };
        a2.prototype.onDocumentMouseMove = function(a3) {
          var c2 = this.chart, b = this.chartPosition;
          a3 = this.normalize(a3, b);
          var e2 = c2.tooltip;
          !b || e2 && e2.isStickyOnContact() || c2.isInsidePlot(a3.chartX - c2.plotLeft, a3.chartY - c2.plotTop, { visiblePlotOnly: true }) || this.inClass(a3.target, "highcharts-tracker") || this.reset();
        };
        a2.prototype.onDocumentMouseUp = function(c2) {
          var e2 = C2[y(a2.hoverChartIndex, -1)];
          e2 && e2.pointer.drop(c2);
        };
        a2.prototype.pinch = function(a3) {
          var c2 = this, b = c2.chart, l = c2.pinchDown, d = a3.touches || [], g2 = d.length, f3 = c2.lastValidTouch, k2 = c2.hasZoom, m = {}, n2 = g2 === 1 && (c2.inClass(a3.target, "highcharts-tracker") && b.runTrackerClick || c2.runChartClick), q3 = {}, t2 = c2.selectionMarker;
          1 < g2 ? c2.initiated = true : g2 === 1 && this.followTouchMove && (c2.initiated = false);
          k2 && c2.initiated && !n2 && a3.cancelable !== false && a3.preventDefault();
          [].map.call(d, function(b2) {
            return c2.normalize(b2);
          });
          a3.type === "touchstart" ? ([].forEach.call(d, function(b2, a4) {
            l[a4] = { chartX: b2.chartX, chartY: b2.chartY };
          }), f3.x = [l[0].chartX, l[1] && l[1].chartX], f3.y = [l[0].chartY, l[1] && l[1].chartY], b.axes.forEach(function(a4) {
            if (a4.zoomEnabled) {
              var d2 = b.bounds[a4.horiz ? "h" : "v"], c3 = a4.minPixelPadding, e2 = a4.toPixels(Math.min(y(a4.options.min, a4.dataMin), a4.dataMin)), h2 = a4.toPixels(Math.max(y(a4.options.max, a4.dataMax), a4.dataMax)), l2 = Math.max(e2, h2);
              d2.min = Math.min(a4.pos, Math.min(e2, h2) - c3);
              d2.max = Math.max(a4.pos + a4.len, l2 + c3);
            }
          }), c2.res = true) : c2.followTouchMove && g2 === 1 ? this.runPointActions(c2.normalize(a3)) : l.length && (p2(b, "touchpan", { originalEvent: a3 }, function() {
            t2 || (c2.selectionMarker = t2 = e({ destroy: I2, touch: true }, b.plotBox));
            c2.pinchTranslate(l, d, m, t2, q3, f3);
            c2.hasPinched = k2;
            c2.scaleGroups(m, q3);
          }), c2.res && (c2.res = false, this.reset(false, 0)));
        };
        a2.prototype.pinchTranslate = function(a3, c2, b, e2, d, g2) {
          this.zoomHor && this.pinchTranslateDirection(true, a3, c2, b, e2, d, g2);
          this.zoomVert && this.pinchTranslateDirection(false, a3, c2, b, e2, d, g2);
        };
        a2.prototype.pinchTranslateDirection = function(a3, c2, b, e2, d, g2, f3, k2) {
          var h2 = this.chart, l = a3 ? "x" : "y", m = a3 ? "X" : "Y", r = "chart" + m, p3 = a3 ? "width" : "height", n2 = h2["plot" + (a3 ? "Left" : "Top")], q3 = h2.inverted, v = h2.bounds[a3 ? "h" : "v"], D = c2.length === 1, t2 = c2[0][r], y2 = !D && c2[1][r];
          c2 = function() {
            typeof F2 === "number" && 20 < Math.abs(t2 - y2) && (z = k2 || Math.abs(M - F2) / Math.abs(t2 - y2));
            G2 = (n2 - M) / z + t2;
            x2 = h2["plot" + (a3 ? "Width" : "Height")] / z;
          };
          var x2, G2, z = k2 || 1, M = b[0][r], F2 = !D && b[1][r];
          c2();
          b = G2;
          if (b < v.min) {
            b = v.min;
            var u2 = true;
          } else
            b + x2 > v.max && (b = v.max - x2, u2 = true);
          u2 ? (M -= 0.8 * (M - f3[l][0]), typeof F2 === "number" && (F2 -= 0.8 * (F2 - f3[l][1])), c2()) : f3[l] = [M, F2];
          q3 || (g2[l] = G2 - n2, g2[p3] = x2);
          g2 = q3 ? 1 / z : z;
          d[p3] = x2;
          d[l] = b;
          e2[q3 ? a3 ? "scaleY" : "scaleX" : "scale" + m] = z;
          e2["translate" + m] = g2 * n2 + (M - g2 * t2);
        };
        a2.prototype.reset = function(a3, c2) {
          var b = this.chart, e2 = b.hoverSeries, d = b.hoverPoint, h2 = b.hoverPoints, g2 = b.tooltip, f3 = g2 && g2.shared ? h2 : d;
          a3 && f3 && x(f3).forEach(function(b2) {
            b2.series.isCartesian && typeof b2.plotX === "undefined" && (a3 = false);
          });
          if (a3)
            g2 && f3 && x(f3).length && (g2.refresh(f3), g2.shared && h2 ? h2.forEach(function(b2) {
              b2.setState(b2.state, true);
              b2.series.isCartesian && (b2.series.xAxis.crosshair && b2.series.xAxis.drawCrosshair(null, b2), b2.series.yAxis.crosshair && b2.series.yAxis.drawCrosshair(null, b2));
            }) : d && (d.setState(d.state, true), b.axes.forEach(function(b2) {
              b2.crosshair && d.series[b2.coll] === b2 && b2.drawCrosshair(null, d);
            })));
          else {
            if (d)
              d.onMouseOut();
            h2 && h2.forEach(function(b2) {
              b2.setState();
            });
            if (e2)
              e2.onMouseOut();
            g2 && g2.hide(c2);
            this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());
            b.axes.forEach(function(b2) {
              b2.hideCrosshair();
            });
            this.hoverX = b.hoverPoints = b.hoverPoint = null;
          }
        };
        a2.prototype.runPointActions = function(e2, h2) {
          var b = this.chart, g2 = b.tooltip && b.tooltip.options.enabled ? b.tooltip : void 0, d = g2 ? g2.shared : false, f3 = h2 || b.hoverPoint, k2 = f3 && f3.series || b.hoverSeries;
          h2 = this.getHoverData(f3, k2, b.series, (!e2 || e2.type !== "touchmove") && (!!h2 || k2 && k2.directTouch && this.isDirectTouch), d, e2);
          f3 = h2.hoverPoint;
          k2 = h2.hoverSeries;
          var m = h2.hoverPoints;
          h2 = k2 && k2.tooltipOptions.followPointer && !k2.tooltipOptions.split;
          var p3 = d && k2 && !k2.noSharedTooltip;
          if (f3 && (f3 !== b.hoverPoint || g2 && g2.isHidden)) {
            (b.hoverPoints || []).forEach(function(b2) {
              m.indexOf(b2) === -1 && b2.setState();
            });
            if (b.hoverSeries !== k2)
              k2.onMouseOver();
            this.applyInactiveState(m);
            (m || []).forEach(function(b2) {
              b2.setState("hover");
            });
            b.hoverPoint && b.hoverPoint.firePointEvent("mouseOut");
            if (!f3.series)
              return;
            b.hoverPoints = m;
            b.hoverPoint = f3;
            f3.firePointEvent("mouseOver", void 0, function() {
              g2 && f3 && g2.refresh(p3 ? m : f3, e2);
            });
          } else
            h2 && g2 && !g2.isHidden && (d = g2.getAnchor([{}], e2), b.isInsidePlot(d[0], d[1], { visiblePlotOnly: true }) && g2.updatePosition({ plotX: d[0], plotY: d[1] }));
          this.unDocMouseMove || (this.unDocMouseMove = A(b.container.ownerDocument, "mousemove", function(b2) {
            var d2 = C2[a2.hoverChartIndex];
            if (d2)
              d2.pointer.onDocumentMouseMove(b2);
          }), this.eventsToUnbind.push(this.unDocMouseMove));
          b.axes.forEach(function(a3) {
            var d2 = y((a3.crosshair || {}).snap, true), h3;
            d2 && ((h3 = b.hoverPoint) && h3.series[a3.coll] === a3 || (h3 = c(m, function(b2) {
              return b2.series && b2.series[a3.coll] === a3;
            })));
            h3 || !d2 ? a3.drawCrosshair(e2, h3) : a3.hideCrosshair();
          });
        };
        a2.prototype.scaleGroups = function(a3, c2) {
          var b = this.chart;
          b.series.forEach(function(e2) {
            var d = a3 || e2.getPlotBox();
            e2.group && (e2.xAxis && e2.xAxis.zoomEnabled || b.mapView) && (e2.group.attr(d), e2.markerGroup && (e2.markerGroup.attr(d), e2.markerGroup.clip(c2 ? b.clipRect : null)), e2.dataLabelsGroup && e2.dataLabelsGroup.attr(d));
          });
          b.clipRect.attr(c2 || b.clipBox);
        };
        a2.prototype.setDOMEvents = function() {
          var c2 = this, e2 = this.chart.container, b = e2.ownerDocument;
          e2.onmousedown = this.onContainerMouseDown.bind(this);
          e2.onmousemove = this.onContainerMouseMove.bind(this);
          e2.onclick = this.onContainerClick.bind(this);
          this.eventsToUnbind.push(A(e2, "mouseenter", this.onContainerMouseEnter.bind(this)));
          this.eventsToUnbind.push(A(e2, "mouseleave", this.onContainerMouseLeave.bind(this)));
          a2.unbindDocumentMouseUp || (a2.unbindDocumentMouseUp = A(b, "mouseup", this.onDocumentMouseUp.bind(this)));
          for (var g2 = this.chart.renderTo.parentElement; g2 && g2.tagName !== "BODY"; )
            this.eventsToUnbind.push(A(g2, "scroll", function() {
              delete c2.chartPosition;
            })), g2 = g2.parentElement;
          f2.hasTouch && (this.eventsToUnbind.push(A(e2, "touchstart", this.onContainerTouchStart.bind(this), { passive: false })), this.eventsToUnbind.push(A(e2, "touchmove", this.onContainerTouchMove.bind(this), { passive: false })), a2.unbindDocumentTouchEnd || (a2.unbindDocumentTouchEnd = A(b, "touchend", this.onDocumentTouchEnd.bind(this), { passive: false })));
        };
        a2.prototype.setHoverChartIndex = function() {
          var c2 = this.chart, e2 = f2.charts[y(a2.hoverChartIndex, -1)];
          if (e2 && e2 !== c2)
            e2.pointer.onContainerMouseLeave({ relatedTarget: c2.container });
          e2 && e2.mouseIsDown || (a2.hoverChartIndex = c2.index);
        };
        a2.prototype.touch = function(a3, c2) {
          var b = this.chart;
          this.setHoverChartIndex();
          if (a3.touches.length === 1)
            if (a3 = this.normalize(a3), b.isInsidePlot(a3.chartX - b.plotLeft, a3.chartY - b.plotTop, { visiblePlotOnly: true }) && !b.openMenu) {
              c2 && this.runPointActions(a3);
              if (a3.type === "touchmove") {
                c2 = this.pinchDown;
                var d = c2[0] ? 4 <= Math.sqrt(Math.pow(c2[0].chartX - a3.chartX, 2) + Math.pow(c2[0].chartY - a3.chartY, 2)) : false;
              }
              y(d, true) && this.pinch(a3);
            } else
              c2 && this.reset();
          else
            a3.touches.length === 2 && this.pinch(a3);
        };
        a2.prototype.touchSelect = function(a3) {
          return !(!this.chart.options.chart.zoomBySingleTouch || !a3.touches || a3.touches.length !== 1);
        };
        a2.prototype.zoomOption = function(a3) {
          var c2 = this.chart, b = c2.options.chart;
          c2 = c2.inverted;
          var e2 = b.zoomType || "";
          /touch/.test(a3.type) && (e2 = y(b.pinchType, e2));
          this.zoomX = a3 = /x/.test(e2);
          this.zoomY = b = /y/.test(e2);
          this.zoomHor = a3 && !c2 || b && c2;
          this.zoomVert = b && !c2 || a3 && c2;
          this.hasZoom = a3 || b;
        };
        return a2;
      }();
      return a;
    });
    K2(f, "Core/MSPointer.js", [f["Core/Globals.js"], f["Core/Pointer.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      function C2() {
        var a2 = [];
        a2.item = function(a3) {
          return this[a3];
        };
        c(g, function(c2) {
          a2.push({ pageX: c2.pageX, pageY: c2.pageY, target: c2.target });
        });
        return a2;
      }
      function w(a2, c2, e2, g2) {
        var k2 = I2[f2.hoverChartIndex || NaN];
        a2.pointerType !== "touch" && a2.pointerType !== a2.MSPOINTER_TYPE_TOUCH || !k2 || (k2 = k2.pointer, g2(a2), k2[c2]({ type: e2, target: a2.currentTarget, preventDefault: u, touches: C2() }));
      }
      var E2 = this && this.__extends || function() {
        var a2 = function(c2, e2) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, c3) {
            a3.__proto__ = c3;
          } || function(a3, c3) {
            for (var e3 in c3)
              c3.hasOwnProperty(e3) && (a3[e3] = c3[e3]);
          };
          return a2(c2, e2);
        };
        return function(c2, e2) {
          function g2() {
            this.constructor = c2;
          }
          a2(c2, e2);
          c2.prototype = e2 === null ? Object.create(e2) : (g2.prototype = e2.prototype, new g2());
        };
      }(), I2 = a.charts, A = a.doc, u = a.noop, n = a.win, k = B2.addEvent, e = B2.css, c = B2.objectEach, p2 = B2.removeEvent, g = {}, t = !!n.PointerEvent;
      return function(c2) {
        function f3() {
          return c2 !== null && c2.apply(this, arguments) || this;
        }
        E2(f3, c2);
        f3.isRequired = function() {
          return !(a.hasTouch || !n.PointerEvent && !n.MSPointerEvent);
        };
        f3.prototype.batchMSEvents = function(a2) {
          a2(this.chart.container, t ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown);
          a2(this.chart.container, t ? "pointermove" : "MSPointerMove", this.onContainerPointerMove);
          a2(A, t ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp);
        };
        f3.prototype.destroy = function() {
          this.batchMSEvents(p2);
          c2.prototype.destroy.call(this);
        };
        f3.prototype.init = function(a2, g2) {
          c2.prototype.init.call(this, a2, g2);
          this.hasZoom && e(a2.container, { "-ms-touch-action": "none", "touch-action": "none" });
        };
        f3.prototype.onContainerPointerDown = function(a2) {
          w(a2, "onContainerTouchStart", "touchstart", function(a3) {
            g[a3.pointerId] = { pageX: a3.pageX, pageY: a3.pageY, target: a3.currentTarget };
          });
        };
        f3.prototype.onContainerPointerMove = function(a2) {
          w(a2, "onContainerTouchMove", "touchmove", function(a3) {
            g[a3.pointerId] = { pageX: a3.pageX, pageY: a3.pageY };
            g[a3.pointerId].target || (g[a3.pointerId].target = a3.currentTarget);
          });
        };
        f3.prototype.onDocumentPointerUp = function(a2) {
          w(a2, "onDocumentTouchEnd", "touchend", function(a3) {
            delete g[a3.pointerId];
          });
        };
        f3.prototype.setDOMEvents = function() {
          c2.prototype.setDOMEvents.call(this);
          (this.hasZoom || this.followTouchMove) && this.batchMSEvents(k);
        };
        return f3;
      }(f2);
    });
    K2(f, "Core/Legend/Legend.js", [
      f["Core/Animation/AnimationUtilities.js"],
      f["Core/FormatUtilities.js"],
      f["Core/Globals.js"],
      f["Core/Series/Point.js"],
      f["Core/Renderer/RendererUtilities.js"],
      f["Core/Utilities.js"]
    ], function(a, f2, B2, H2, w, E2) {
      var C2 = a.animObject, A = a.setAnimation, u = f2.format;
      a = B2.isFirefox;
      var n = B2.marginNames;
      B2 = B2.win;
      var k = w.distribute, e = E2.addEvent, c = E2.createElement, p2 = E2.css, g = E2.defined, t = E2.discardElement, q2 = E2.find, F = E2.fireEvent, y = E2.isNumber, x = E2.merge, z = E2.pick, m = E2.relativeLength, h2 = E2.stableSort, b = E2.syncTimeout;
      w = E2.wrap;
      E2 = function() {
        function a2(b2, a3) {
          this.allItems = [];
          this.contentGroup = this.box = void 0;
          this.display = false;
          this.group = void 0;
          this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;
          this.options = void 0;
          this.padding = 0;
          this.pages = [];
          this.proximate = false;
          this.scrollGroup = void 0;
          this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;
          this.chart = b2;
          this.init(b2, a3);
        }
        a2.prototype.init = function(b2, a3) {
          this.chart = b2;
          this.setOptions(a3);
          a3.enabled && (this.render(), e(this.chart, "endResize", function() {
            this.legend.positionCheckboxes();
          }), this.proximate ? this.unchartrender = e(this.chart, "render", function() {
            this.legend.proximatePositions();
            this.legend.positionItems();
          }) : this.unchartrender && this.unchartrender());
        };
        a2.prototype.setOptions = function(b2) {
          var a3 = z(b2.padding, 8);
          this.options = b2;
          this.chart.styledMode || (this.itemStyle = b2.itemStyle, this.itemHiddenStyle = x(this.itemStyle, b2.itemHiddenStyle));
          this.itemMarginTop = b2.itemMarginTop || 0;
          this.itemMarginBottom = b2.itemMarginBottom || 0;
          this.padding = a3;
          this.initialItemY = a3 - 5;
          this.symbolWidth = z(b2.symbolWidth, 16);
          this.pages = [];
          this.proximate = b2.layout === "proximate" && !this.chart.inverted;
          this.baseline = void 0;
        };
        a2.prototype.update = function(b2, a3) {
          var d = this.chart;
          this.setOptions(x(true, this.options, b2));
          this.destroy();
          d.isDirtyLegend = d.isDirtyBox = true;
          z(a3, true) && d.redraw();
          F(this, "afterUpdate");
        };
        a2.prototype.colorizeItem = function(b2, a3) {
          b2.legendGroup[a3 ? "removeClass" : "addClass"]("highcharts-legend-item-hidden");
          if (!this.chart.styledMode) {
            var d = this.options, c2 = b2.legendItem, e2 = b2.legendLine, h3 = b2.legendSymbol, g2 = this.itemHiddenStyle.color;
            d = a3 ? d.itemStyle.color : g2;
            var l = a3 ? b2.color || g2 : g2, f3 = b2.options && b2.options.marker, k2 = { fill: l };
            c2 && c2.css({ fill: d, color: d });
            e2 && e2.attr({ stroke: l });
            h3 && (f3 && h3.isMarker && (k2 = b2.pointAttribs(), a3 || (k2.stroke = k2.fill = g2)), h3.attr(k2));
          }
          F(this, "afterColorizeItem", { item: b2, visible: a3 });
        };
        a2.prototype.positionItems = function() {
          this.allItems.forEach(this.positionItem, this);
          this.chart.isResizing || this.positionCheckboxes();
        };
        a2.prototype.positionItem = function(b2) {
          var a3 = this, d = this.options, c2 = d.symbolPadding, e2 = !d.rtl, h3 = b2._legendItemPos;
          d = h3[0];
          h3 = h3[1];
          var l = b2.checkbox, f3 = b2.legendGroup;
          f3 && f3.element && (c2 = { translateX: e2 ? d : this.legendWidth - d - 2 * c2 - 4, translateY: h3 }, e2 = function() {
            F(a3, "afterPositionItem", { item: b2 });
          }, g(f3.translateY) ? f3.animate(c2, void 0, e2) : (f3.attr(c2), e2()));
          l && (l.x = d, l.y = h3);
        };
        a2.prototype.destroyItem = function(b2) {
          var a3 = b2.checkbox;
          ["legendItem", "legendLine", "legendSymbol", "legendGroup"].forEach(function(a4) {
            b2[a4] && (b2[a4] = b2[a4].destroy());
          });
          a3 && t(b2.checkbox);
        };
        a2.prototype.destroy = function() {
          function b2(b3) {
            this[b3] && (this[b3] = this[b3].destroy());
          }
          this.getAllItems().forEach(function(a3) {
            ["legendItem", "legendGroup"].forEach(b2, a3);
          });
          "clipRect up down pager nav box title group".split(" ").forEach(b2, this);
          this.display = null;
        };
        a2.prototype.positionCheckboxes = function() {
          var b2 = this.group && this.group.alignAttr, a3 = this.clipHeight || this.legendHeight, c2 = this.titleHeight;
          if (b2) {
            var e2 = b2.translateY;
            this.allItems.forEach(function(d) {
              var h3 = d.checkbox;
              if (h3) {
                var g2 = e2 + c2 + h3.y + (this.scrollOffset || 0) + 3;
                p2(h3, { left: b2.translateX + d.checkboxOffset + h3.x - 20 + "px", top: g2 + "px", display: this.proximate || g2 > e2 - 6 && g2 < e2 + a3 - 6 ? "" : "none" });
              }
            }, this);
          }
        };
        a2.prototype.renderTitle = function() {
          var b2 = this.options, a3 = this.padding, c2 = b2.title, e2 = 0;
          c2.text && (this.title || (this.title = this.chart.renderer.label(c2.text, a3 - 3, a3 - 4, void 0, void 0, void 0, b2.useHTML, void 0, "legend-title").attr({ zIndex: 1 }), this.chart.styledMode || this.title.css(c2.style), this.title.add(this.group)), c2.width || this.title.css({ width: this.maxLegendWidth + "px" }), b2 = this.title.getBBox(), e2 = b2.height, this.offsetWidth = b2.width, this.contentGroup.attr({ translateY: e2 }));
          this.titleHeight = e2;
        };
        a2.prototype.setText = function(b2) {
          var a3 = this.options;
          b2.legendItem.attr({ text: a3.labelFormat ? u(a3.labelFormat, b2, this.chart) : a3.labelFormatter.call(b2) });
        };
        a2.prototype.renderItem = function(b2) {
          var a3 = this.chart, d = a3.renderer, c2 = this.options, e2 = this.symbolWidth, h3 = c2.symbolPadding || 0, g2 = this.itemStyle, l = this.itemHiddenStyle, f3 = c2.layout === "horizontal" ? z(c2.itemDistance, 20) : 0, k2 = !c2.rtl, m2 = !b2.series, p3 = !m2 && b2.series.drawLegendSymbol ? b2.series : b2, n2 = p3.options, q3 = this.createCheckboxForItem && n2 && n2.showCheckbox, t2 = c2.useHTML, y2 = b2.options.className, G2 = b2.legendItem;
          n2 = e2 + h3 + f3 + (q3 ? 20 : 0);
          G2 || (b2.legendGroup = d.g("legend-item").addClass("highcharts-" + p3.type + "-series highcharts-color-" + b2.colorIndex + (y2 ? " " + y2 : "") + (m2 ? " highcharts-series-" + b2.index : "")).attr({ zIndex: 1 }).add(this.scrollGroup), b2.legendItem = G2 = d.text("", k2 ? e2 + h3 : -h3, this.baseline || 0, t2), a3.styledMode || G2.css(x(b2.visible ? g2 : l)), G2.attr({ align: k2 ? "left" : "right", zIndex: 2 }).add(b2.legendGroup), this.baseline || (this.fontMetrics = d.fontMetrics(a3.styledMode ? 12 : g2.fontSize, G2), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, G2.attr("y", this.baseline), this.symbolHeight = c2.symbolHeight || this.fontMetrics.f, c2.squareSymbol && (this.symbolWidth = z(c2.symbolWidth, Math.max(this.symbolHeight, 16)), n2 = this.symbolWidth + h3 + f3 + (q3 ? 20 : 0), k2 && G2.attr("x", this.symbolWidth + h3))), p3.drawLegendSymbol(this, b2), this.setItemEvents && this.setItemEvents(b2, G2, t2));
          q3 && !b2.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(b2);
          this.colorizeItem(b2, b2.visible);
          !a3.styledMode && g2.width || G2.css({ width: (c2.itemWidth || this.widthOption || a3.spacingBox.width) - n2 + "px" });
          this.setText(b2);
          a3 = G2.getBBox();
          d = this.fontMetrics && this.fontMetrics.h || 0;
          b2.itemWidth = b2.checkboxOffset = c2.itemWidth || b2.legendItemWidth || a3.width + n2;
          this.maxItemWidth = Math.max(this.maxItemWidth, b2.itemWidth);
          this.totalItemWidth += b2.itemWidth;
          this.itemHeight = b2.itemHeight = Math.round(b2.legendItemHeight || (a3.height > 1.5 * d ? a3.height : d));
        };
        a2.prototype.layoutItem = function(b2) {
          var a3 = this.options, c2 = this.padding, d = a3.layout === "horizontal", e2 = b2.itemHeight, h3 = this.itemMarginBottom, g2 = this.itemMarginTop, l = d ? z(a3.itemDistance, 20) : 0, f3 = this.maxLegendWidth;
          a3 = a3.alignColumns && this.totalItemWidth > f3 ? this.maxItemWidth : b2.itemWidth;
          d && this.itemX - c2 + a3 > f3 && (this.itemX = c2, this.lastLineHeight && (this.itemY += g2 + this.lastLineHeight + h3), this.lastLineHeight = 0);
          this.lastItemY = g2 + this.itemY + h3;
          this.lastLineHeight = Math.max(e2, this.lastLineHeight);
          b2._legendItemPos = [this.itemX, this.itemY];
          d ? this.itemX += a3 : (this.itemY += g2 + e2 + h3, this.lastLineHeight = e2);
          this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - c2 - (b2.checkbox ? 0 : l) : a3) + c2, this.offsetWidth);
        };
        a2.prototype.getAllItems = function() {
          var b2 = [];
          this.chart.series.forEach(function(a3) {
            var c2 = a3 && a3.options;
            a3 && z(c2.showInLegend, g(c2.linkedTo) ? false : void 0, true) && (b2 = b2.concat(a3.legendItems || (c2.legendType === "point" ? a3.data : a3)));
          });
          F(this, "afterGetAllItems", { allItems: b2 });
          return b2;
        };
        a2.prototype.getAlignment = function() {
          var b2 = this.options;
          return this.proximate ? b2.align.charAt(0) + "tv" : b2.floating ? "" : b2.align.charAt(0) + b2.verticalAlign.charAt(0) + b2.layout.charAt(0);
        };
        a2.prototype.adjustMargins = function(b2, a3) {
          var c2 = this.chart, d = this.options, e2 = this.getAlignment();
          e2 && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function(h3, f3) {
            h3.test(e2) && !g(b2[f3]) && (c2[n[f3]] = Math.max(c2[n[f3]], c2.legend[(f3 + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][f3] * d[f3 % 2 ? "x" : "y"] + z(d.margin, 12) + a3[f3] + (c2.titleOffset[f3] || 0)));
          });
        };
        a2.prototype.proximatePositions = function() {
          var b2 = this.chart, a3 = [], c2 = this.options.align === "left";
          this.allItems.forEach(function(d) {
            var e2;
            var h3 = c2;
            if (d.yAxis) {
              d.xAxis.options.reversed && (h3 = !h3);
              d.points && (e2 = q2(h3 ? d.points : d.points.slice(0).reverse(), function(b3) {
                return y(b3.plotY);
              }));
              h3 = this.itemMarginTop + d.legendItem.getBBox().height + this.itemMarginBottom;
              var g2 = d.yAxis.top - b2.plotTop;
              d.visible ? (e2 = e2 ? e2.plotY : d.yAxis.height, e2 += g2 - 0.3 * h3) : e2 = g2 + d.yAxis.height;
              a3.push({ target: e2, size: h3, item: d });
            }
          }, this);
          k(a3, b2.plotHeight).forEach(function(a4) {
            a4.item._legendItemPos && (a4.item._legendItemPos[1] = b2.plotTop - b2.spacing[0] + a4.pos);
          });
        };
        a2.prototype.render = function() {
          var b2 = this.chart, a3 = b2.renderer, c2 = this.options, e2 = this.padding, g2 = this.getAllItems(), f3 = this.group, l = this.box;
          this.itemX = e2;
          this.itemY = this.initialItemY;
          this.lastItemY = this.offsetWidth = 0;
          this.widthOption = m(c2.width, b2.spacingBox.width - e2);
          var k2 = b2.spacingBox.width - 2 * e2 - c2.x;
          -1 < ["rm", "lm"].indexOf(this.getAlignment().substring(0, 2)) && (k2 /= 2);
          this.maxLegendWidth = this.widthOption || k2;
          f3 || (this.group = f3 = a3.g("legend").addClass(c2.className || "").attr({ zIndex: 7 }).add(), this.contentGroup = a3.g().attr({ zIndex: 1 }).add(f3), this.scrollGroup = a3.g().add(this.contentGroup));
          this.renderTitle();
          h2(g2, function(b3, a4) {
            return (b3.options && b3.options.legendIndex || 0) - (a4.options && a4.options.legendIndex || 0);
          });
          c2.reversed && g2.reverse();
          this.allItems = g2;
          this.display = k2 = !!g2.length;
          this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;
          g2.forEach(this.renderItem, this);
          g2.forEach(this.layoutItem, this);
          g2 = (this.widthOption || this.offsetWidth) + e2;
          var p3 = this.lastItemY + this.lastLineHeight + this.titleHeight;
          p3 = this.handleOverflow(p3);
          p3 += e2;
          l || (this.box = l = a3.rect().addClass("highcharts-legend-box").attr({ r: c2.borderRadius }).add(f3));
          b2.styledMode || l.attr({ stroke: c2.borderColor, "stroke-width": c2.borderWidth || 0, fill: c2.backgroundColor || "none" }).shadow(c2.shadow);
          if (0 < g2 && 0 < p3)
            l[l.placed ? "animate" : "attr"](l.crisp.call({}, { x: 0, y: 0, width: g2, height: p3 }, l.strokeWidth()));
          l[k2 ? "show" : "hide"]();
          b2.styledMode && f3.getStyle("display") === "none" && (g2 = p3 = 0);
          this.legendWidth = g2;
          this.legendHeight = p3;
          k2 && this.align();
          this.proximate || this.positionItems();
          F(this, "afterRender");
        };
        a2.prototype.align = function(b2) {
          b2 === void 0 && (b2 = this.chart.spacingBox);
          var a3 = this.chart, c2 = this.options, d = b2.y;
          /(lth|ct|rth)/.test(this.getAlignment()) && 0 < a3.titleOffset[0] ? d += a3.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < a3.titleOffset[2] && (d -= a3.titleOffset[2]);
          d !== b2.y && (b2 = x(b2, { y: d }));
          a3.hasRendered || (this.group.placed = false);
          this.group.align(x(c2, { width: this.legendWidth, height: this.legendHeight, verticalAlign: this.proximate ? "top" : c2.verticalAlign }), true, b2);
        };
        a2.prototype.handleOverflow = function(b2) {
          var a3 = this, c2 = this.chart, d = c2.renderer, e2 = this.options, h3 = e2.y, g2 = e2.verticalAlign === "top", f3 = this.padding, l = e2.maxHeight, k2 = e2.navigation, m2 = z(k2.animation, true), p3 = k2.arrowSize || 12, n2 = this.pages, q3 = this.allItems, t2 = function(b3) {
            typeof b3 === "number" ? F2.attr({ height: b3 }) : F2 && (a3.clipRect = F2.destroy(), a3.contentGroup.clip());
            a3.contentGroup.div && (a3.contentGroup.div.style.clip = b3 ? "rect(" + f3 + "px,9999px," + (f3 + b3) + "px,0)" : "auto");
          }, y2 = function(b3) {
            a3[b3] = d.circle(0, 0, 1.3 * p3).translate(p3 / 2, p3 / 2).add(M);
            c2.styledMode || a3[b3].attr("fill", "rgba(0,0,0,0.0001)");
            return a3[b3];
          }, G2, x2;
          h3 = c2.spacingBox.height + (g2 ? -h3 : h3) - f3;
          var M = this.nav, F2 = this.clipRect;
          e2.layout !== "horizontal" || e2.verticalAlign === "middle" || e2.floating || (h3 /= 2);
          l && (h3 = Math.min(h3, l));
          n2.length = 0;
          b2 && 0 < h3 && b2 > h3 && k2.enabled !== false ? (this.clipHeight = G2 = Math.max(h3 - 20 - this.titleHeight - f3, 0), this.currentPage = z(this.currentPage, 1), this.fullHeight = b2, q3.forEach(function(b3, a4) {
            var c3 = b3._legendItemPos[1], d2 = Math.round(b3.legendItem.getBBox().height), e3 = n2.length;
            if (!e3 || c3 - n2[e3 - 1] > G2 && (x2 || c3) !== n2[e3 - 1])
              n2.push(x2 || c3), e3++;
            b3.pageIx = e3 - 1;
            x2 && (q3[a4 - 1].pageIx = e3 - 1);
            a4 === q3.length - 1 && c3 + d2 - n2[e3 - 1] > G2 && d2 <= G2 && (n2.push(c3), b3.pageIx = e3);
            c3 !== x2 && (x2 = c3);
          }), F2 || (F2 = a3.clipRect = d.clipRect(0, f3, 9999, 0), a3.contentGroup.clip(F2)), t2(G2), M || (this.nav = M = d.g().attr({ zIndex: 1 }).add(this.group), this.up = d.symbol("triangle", 0, 0, p3, p3).add(M), y2("upTracker").on("click", function() {
            a3.scroll(-1, m2);
          }), this.pager = d.text("", 15, 10).addClass("highcharts-legend-navigation"), !c2.styledMode && k2.style && this.pager.css(k2.style), this.pager.add(M), this.down = d.symbol("triangle-down", 0, 0, p3, p3).add(M), y2("downTracker").on("click", function() {
            a3.scroll(1, m2);
          })), a3.scroll(0), b2 = h3) : M && (t2(), this.nav = M.destroy(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0);
          return b2;
        };
        a2.prototype.scroll = function(a3, c2) {
          var d = this, e2 = this.chart, h3 = this.pages, g2 = h3.length, f3 = this.clipHeight, l = this.options.navigation, k2 = this.pager, m2 = this.padding, p3 = this.currentPage + a3;
          p3 > g2 && (p3 = g2);
          0 < p3 && (typeof c2 !== "undefined" && A(c2, e2), this.nav.attr({ translateX: m2, translateY: f3 + this.padding + 7 + this.titleHeight, visibility: "inherit" }), [this.up, this.upTracker].forEach(function(b2) {
            b2.attr({ "class": p3 === 1 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
          }), k2.attr({ text: p3 + "/" + g2 }), [this.down, this.downTracker].forEach(function(b2) {
            b2.attr({ x: 18 + this.pager.getBBox().width, "class": p3 === g2 ? "highcharts-legend-nav-inactive" : "highcharts-legend-nav-active" });
          }, this), e2.styledMode || (this.up.attr({ fill: p3 === 1 ? l.inactiveColor : l.activeColor }), this.upTracker.css({ cursor: p3 === 1 ? "default" : "pointer" }), this.down.attr({ fill: p3 === g2 ? l.inactiveColor : l.activeColor }), this.downTracker.css({ cursor: p3 === g2 ? "default" : "pointer" })), this.scrollOffset = -h3[p3 - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: this.scrollOffset }), this.currentPage = p3, this.positionCheckboxes(), a3 = C2(z(c2, e2.renderer.globalAnimation, true)), b(function() {
            F(d, "afterScroll", { currentPage: p3 });
          }, a3.duration));
        };
        a2.prototype.setItemEvents = function(b2, a3, c2) {
          var d = this, e2 = d.chart.renderer.boxWrapper, h3 = b2 instanceof H2, g2 = "highcharts-legend-" + (h3 ? "point" : "series") + "-active", f3 = d.chart.styledMode, l = function(a4) {
            d.allItems.forEach(function(c3) {
              b2 !== c3 && [c3].concat(c3.linkedSeries || []).forEach(function(b3) {
                b3.setState(a4, !h3);
              });
            });
          };
          (c2 ? [a3, b2.legendSymbol] : [b2.legendGroup]).forEach(function(c3) {
            if (c3)
              c3.on("mouseover", function() {
                b2.visible && l("inactive");
                b2.setState("hover");
                b2.visible && e2.addClass(g2);
                f3 || a3.css(d.options.itemHoverStyle);
              }).on("mouseout", function() {
                d.chart.styledMode || a3.css(x(b2.visible ? d.itemStyle : d.itemHiddenStyle));
                l("");
                e2.removeClass(g2);
                b2.setState();
              }).on("click", function(a4) {
                var c4 = function() {
                  b2.setVisible && b2.setVisible();
                  l(b2.visible ? "inactive" : "");
                };
                e2.removeClass(g2);
                a4 = { browserEvent: a4 };
                b2.firePointEvent ? b2.firePointEvent("legendItemClick", a4, c4) : F(b2, "legendItemClick", a4, c4);
              });
          });
        };
        a2.prototype.createCheckboxForItem = function(b2) {
          b2.checkbox = c("input", { type: "checkbox", className: "highcharts-legend-checkbox", checked: b2.selected, defaultChecked: b2.selected }, this.options.itemCheckboxStyle, this.chart.container);
          e(b2.checkbox, "click", function(a3) {
            F(b2.series || b2, "checkboxClick", { checked: a3.target.checked, item: b2 }, function() {
              b2.select();
            });
          });
        };
        return a2;
      }();
      (/Trident\/7\.0/.test(B2.navigator && B2.navigator.userAgent) || a) && w(E2.prototype, "positionItem", function(b2, a2) {
        var c2 = this, d = function() {
          a2._legendItemPos && b2.call(c2, a2);
        };
        d();
        c2.bubbleLegend || setTimeout(d);
      });
      return E2;
    });
    K2(f, "Core/Series/SeriesRegistry.js", [f["Core/Globals.js"], f["Core/DefaultOptions.js"], f["Core/Series/Point.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2) {
      var w = f2.defaultOptions, C2 = H2.error, I2 = H2.extendClass, A = H2.merge, u;
      (function(f3) {
        function k(a2, c) {
          var e = w.plotOptions || {}, g = c.defaultOptions;
          c.prototype.pointClass || (c.prototype.pointClass = B2);
          c.prototype.type = a2;
          g && (e[a2] = g);
          f3.seriesTypes[a2] = c;
        }
        f3.seriesTypes = a.seriesTypes;
        f3.getSeries = function(a2, c) {
          c === void 0 && (c = {});
          var e = a2.options.chart;
          e = c.type || e.type || e.defaultSeriesType || "";
          var g = f3.seriesTypes[e];
          f3 || C2(17, true, a2, { missingModuleFor: e });
          e = new g();
          typeof e.init === "function" && e.init(a2, c);
          return e;
        };
        f3.registerSeriesType = k;
        f3.seriesType = function(a2, c, p2, g, n) {
          var e = w.plotOptions || {};
          c = c || "";
          e[a2] = A(e[c], p2);
          k(a2, I2(f3.seriesTypes[c] || function() {
          }, g));
          f3.seriesTypes[a2].prototype.type = a2;
          n && (f3.seriesTypes[a2].prototype.pointClass = I2(B2, n));
          return f3.seriesTypes[a2];
        };
      })(u || (u = {}));
      return u;
    });
    K2(f, "Core/Chart/Chart.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/Axis.js"], f["Core/FormatUtilities.js"], f["Core/Foundation.js"], f["Core/Globals.js"], f["Core/Legend/Legend.js"], f["Core/MSPointer.js"], f["Core/DefaultOptions.js"], f["Core/Pointer.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/SVGRenderer.js"], f["Core/Time.js"], f["Core/Utilities.js"], f["Core/Renderer/HTML/AST.js"]], function(a, f2, B2, H2, w, E2, I2, A, u, n, k, e, c, p2, g) {
      var t = a.animate, q2 = a.animObject, F = a.setAnimation, y = B2.numberFormat, x = H2.registerEventOptions, z = w.charts, m = w.doc, h2 = w.marginNames, b = w.svg, l = w.win, d = A.defaultOptions, D = A.defaultTime, v = k.seriesTypes, r = p2.addEvent, C2 = p2.attr, P2 = p2.cleanRecursively, S = p2.createElement, N2 = p2.css, Y = p2.defined, X2 = p2.discardElement, J2 = p2.erase, L = p2.error, K3 = p2.extend, da = p2.find, Q2 = p2.fireEvent, ea = p2.getStyle, G2 = p2.isArray, T = p2.isNumber, M = p2.isObject, V = p2.isString, W2 = p2.merge, Z2 = p2.objectEach, R2 = p2.pick, ha = p2.pInt, aa = p2.relativeLength, ja = p2.removeEvent, ia = p2.splat, ba = p2.syncTimeout, ka = p2.uniqueKey;
      a = function() {
        function a2(b2, a3, c2) {
          this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;
          this.sharedClips = {};
          this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;
          this.getArgs(b2, a3, c2);
        }
        a2.chart = function(b2, c2, d2) {
          return new a2(b2, c2, d2);
        };
        a2.prototype.getArgs = function(b2, a3, c2) {
          V(b2) || b2.nodeName ? (this.renderTo = b2, this.init(a3, c2)) : this.init(b2, a3);
        };
        a2.prototype.init = function(b2, a3) {
          var e2 = b2.plotOptions || {};
          Q2(this, "init", { args: arguments }, function() {
            var h3 = W2(d, b2), g2 = h3.chart;
            Z2(h3.plotOptions, function(b3, a4) {
              M(b3) && (b3.tooltip = e2[a4] && W2(e2[a4].tooltip) || void 0);
            });
            h3.tooltip.userOptions = b2.chart && b2.chart.forExport && b2.tooltip.userOptions || b2.tooltip;
            this.userOptions = b2;
            this.margin = [];
            this.spacing = [];
            this.bounds = { h: {}, v: {} };
            this.labelCollectors = [];
            this.callback = a3;
            this.isResizing = 0;
            this.options = h3;
            this.axes = [];
            this.series = [];
            this.time = b2.time && Object.keys(b2.time).length ? new c(b2.time) : w.time;
            this.numberFormatter = g2.numberFormatter || y;
            this.styledMode = g2.styledMode;
            this.hasCartesianSeries = g2.showAxes;
            this.index = z.length;
            z.push(this);
            w.chartCount++;
            x(this, g2);
            this.xAxis = [];
            this.yAxis = [];
            this.pointCount = this.colorCounter = this.symbolCounter = 0;
            Q2(this, "afterInit");
            this.firstRender();
          });
        };
        a2.prototype.initSeries = function(b2) {
          var a3 = this.options.chart;
          a3 = b2.type || a3.type || a3.defaultSeriesType;
          var c2 = v[a3];
          c2 || L(17, true, this, { missingModuleFor: a3 });
          a3 = new c2();
          typeof a3.init === "function" && a3.init(this, b2);
          return a3;
        };
        a2.prototype.setSeriesData = function() {
          this.getSeriesOrderByLinks().forEach(function(b2) {
            b2.points || b2.data || !b2.enabledDataSorting || b2.setData(b2.options.data, false);
          });
        };
        a2.prototype.getSeriesOrderByLinks = function() {
          return this.series.concat().sort(function(b2, a3) {
            return b2.linkedSeries.length || a3.linkedSeries.length ? a3.linkedSeries.length - b2.linkedSeries.length : 0;
          });
        };
        a2.prototype.orderSeries = function(b2) {
          var a3 = this.series;
          b2 = b2 || 0;
          for (var c2 = a3.length; b2 < c2; ++b2)
            a3[b2] && (a3[b2].index = b2, a3[b2].name = a3[b2].getName());
        };
        a2.prototype.isInsidePlot = function(b2, a3, c2) {
          c2 === void 0 && (c2 = {});
          var d2 = this.inverted, e2 = this.plotBox, h3 = this.plotLeft, g2 = this.plotTop, f3 = this.scrollablePlotBox, l2 = 0;
          var k2 = 0;
          c2.visiblePlotOnly && this.scrollingContainer && (k2 = this.scrollingContainer, l2 = k2.scrollLeft, k2 = k2.scrollTop);
          var m2 = c2.series;
          e2 = c2.visiblePlotOnly && f3 || e2;
          f3 = c2.inverted ? a3 : b2;
          a3 = c2.inverted ? b2 : a3;
          b2 = { x: f3, y: a3, isInsidePlot: true };
          if (!c2.ignoreX) {
            var p3 = m2 && (d2 ? m2.yAxis : m2.xAxis) || { pos: h3, len: Infinity };
            f3 = c2.paneCoordinates ? p3.pos + f3 : h3 + f3;
            f3 >= Math.max(l2 + h3, p3.pos) && f3 <= Math.min(l2 + h3 + e2.width, p3.pos + p3.len) || (b2.isInsidePlot = false);
          }
          !c2.ignoreY && b2.isInsidePlot && (d2 = m2 && (d2 ? m2.xAxis : m2.yAxis) || { pos: g2, len: Infinity }, c2 = c2.paneCoordinates ? d2.pos + a3 : g2 + a3, c2 >= Math.max(k2 + g2, d2.pos) && c2 <= Math.min(k2 + g2 + e2.height, d2.pos + d2.len) || (b2.isInsidePlot = false));
          Q2(this, "afterIsInsidePlot", b2);
          return b2.isInsidePlot;
        };
        a2.prototype.redraw = function(b2) {
          Q2(this, "beforeRedraw");
          var a3 = this.hasCartesianSeries ? this.axes : this.colorAxis || [], c2 = this.series, d2 = this.pointer, e2 = this.legend, h3 = this.userOptions.legend, g2 = this.renderer, f3 = g2.isHidden(), l2 = [], k2 = this.isDirtyBox, m2 = this.isDirtyLegend;
          this.setResponsive && this.setResponsive(false);
          F(this.hasRendered ? b2 : false, this);
          f3 && this.temporaryDisplay();
          this.layOutTitles();
          for (b2 = c2.length; b2--; ) {
            var p3 = c2[b2];
            if (p3.options.stacking || p3.options.centerInCategory) {
              var G3 = true;
              if (p3.isDirty) {
                var n2 = true;
                break;
              }
            }
          }
          if (n2)
            for (b2 = c2.length; b2--; )
              p3 = c2[b2], p3.options.stacking && (p3.isDirty = true);
          c2.forEach(function(b3) {
            b3.isDirty && (b3.options.legendType === "point" ? (typeof b3.updateTotals === "function" && b3.updateTotals(), m2 = true) : h3 && (h3.labelFormatter || h3.labelFormat) && (m2 = true));
            b3.isDirtyData && Q2(b3, "updatedData");
          });
          m2 && e2 && e2.options.enabled && (e2.render(), this.isDirtyLegend = false);
          G3 && this.getStacks();
          a3.forEach(function(b3) {
            b3.updateNames();
            b3.setScale();
          });
          this.getMargins();
          a3.forEach(function(b3) {
            b3.isDirty && (k2 = true);
          });
          a3.forEach(function(b3) {
            var a4 = b3.min + "," + b3.max;
            b3.extKey !== a4 && (b3.extKey = a4, l2.push(function() {
              Q2(b3, "afterSetExtremes", K3(b3.eventArgs, b3.getExtremes()));
              delete b3.eventArgs;
            }));
            (k2 || G3) && b3.redraw();
          });
          k2 && this.drawChartBox();
          Q2(this, "predraw");
          c2.forEach(function(b3) {
            (k2 || b3.isDirty) && b3.visible && b3.redraw();
            b3.isDirtyData = false;
          });
          d2 && d2.reset(true);
          g2.draw();
          Q2(this, "redraw");
          Q2(this, "render");
          f3 && this.temporaryDisplay(true);
          l2.forEach(function(b3) {
            b3.call();
          });
        };
        a2.prototype.get = function(b2) {
          function a3(a4) {
            return a4.id === b2 || a4.options && a4.options.id === b2;
          }
          for (var c2 = this.series, d2 = da(this.axes, a3) || da(this.series, a3), e2 = 0; !d2 && e2 < c2.length; e2++)
            d2 = da(c2[e2].points || [], a3);
          return d2;
        };
        a2.prototype.getAxes = function() {
          var b2 = this, a3 = this.options, c2 = a3.xAxis = ia(a3.xAxis || {});
          a3 = a3.yAxis = ia(a3.yAxis || {});
          Q2(this, "getAxes");
          c2.forEach(function(b3, a4) {
            b3.index = a4;
            b3.isX = true;
          });
          a3.forEach(function(b3, a4) {
            b3.index = a4;
          });
          c2.concat(a3).forEach(function(a4) {
            new f2(b2, a4);
          });
          Q2(this, "afterGetAxes");
        };
        a2.prototype.getSelectedPoints = function() {
          return this.series.reduce(function(b2, a3) {
            a3.getPointsCollection().forEach(function(a4) {
              R2(a4.selectedStaging, a4.selected) && b2.push(a4);
            });
            return b2;
          }, []);
        };
        a2.prototype.getSelectedSeries = function() {
          return this.series.filter(function(b2) {
            return b2.selected;
          });
        };
        a2.prototype.setTitle = function(b2, a3, c2) {
          this.applyDescription("title", b2);
          this.applyDescription("subtitle", a3);
          this.applyDescription("caption", void 0);
          this.layOutTitles(c2);
        };
        a2.prototype.applyDescription = function(b2, a3) {
          var c2 = this, d2 = b2 === "title" ? { color: "#333333", fontSize: this.options.isStock ? "16px" : "18px" } : { color: "#666666" };
          d2 = this.options[b2] = W2(!this.styledMode && { style: d2 }, this.options[b2], a3);
          var e2 = this[b2];
          e2 && a3 && (this[b2] = e2 = e2.destroy());
          d2 && !e2 && (e2 = this.renderer.text(d2.text, 0, 0, d2.useHTML).attr({ align: d2.align, "class": "highcharts-" + b2, zIndex: d2.zIndex || 4 }).add(), e2.update = function(a4) {
            c2[{ title: "setTitle", subtitle: "setSubtitle", caption: "setCaption" }[b2]](a4);
          }, this.styledMode || e2.css(d2.style), this[b2] = e2);
        };
        a2.prototype.layOutTitles = function(b2) {
          var a3 = [0, 0, 0], c2 = this.renderer, d2 = this.spacingBox;
          ["title", "subtitle", "caption"].forEach(function(b3) {
            var e3 = this[b3], h3 = this.options[b3], g2 = h3.verticalAlign || "top";
            b3 = b3 === "title" ? g2 === "top" ? -3 : 0 : g2 === "top" ? a3[0] + 2 : 0;
            var f3;
            if (e3) {
              this.styledMode || (f3 = h3.style && h3.style.fontSize);
              f3 = c2.fontMetrics(f3, e3).b;
              e3.css({ width: (h3.width || d2.width + (h3.widthAdjust || 0)) + "px" });
              var l2 = Math.round(e3.getBBox(h3.useHTML).height);
              e3.align(K3({ y: g2 === "bottom" ? f3 : b3 + f3, height: l2 }, h3), false, "spacingBox");
              h3.floating || (g2 === "top" ? a3[0] = Math.ceil(a3[0] + l2) : g2 === "bottom" && (a3[2] = Math.ceil(a3[2] + l2)));
            }
          }, this);
          a3[0] && (this.options.title.verticalAlign || "top") === "top" && (a3[0] += this.options.title.margin);
          a3[2] && this.options.caption.verticalAlign === "bottom" && (a3[2] += this.options.caption.margin);
          var e2 = !this.titleOffset || this.titleOffset.join(",") !== a3.join(",");
          this.titleOffset = a3;
          Q2(this, "afterLayOutTitles");
          !this.isDirtyBox && e2 && (this.isDirtyBox = this.isDirtyLegend = e2, this.hasRendered && R2(b2, true) && this.isDirtyBox && this.redraw());
        };
        a2.prototype.getChartSize = function() {
          var b2 = this.options.chart, a3 = b2.width;
          b2 = b2.height;
          var c2 = this.renderTo;
          Y(a3) || (this.containerWidth = ea(c2, "width"));
          Y(b2) || (this.containerHeight = ea(c2, "height"));
          this.chartWidth = Math.max(0, a3 || this.containerWidth || 600);
          this.chartHeight = Math.max(0, aa(b2, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));
        };
        a2.prototype.temporaryDisplay = function(b2) {
          var a3 = this.renderTo;
          if (b2)
            for (; a3 && a3.style; )
              a3.hcOrigStyle && (N2(a3, a3.hcOrigStyle), delete a3.hcOrigStyle), a3.hcOrigDetached && (m.body.removeChild(a3), a3.hcOrigDetached = false), a3 = a3.parentNode;
          else
            for (; a3 && a3.style; ) {
              m.body.contains(a3) || a3.parentNode || (a3.hcOrigDetached = true, m.body.appendChild(a3));
              if (ea(a3, "display", false) === "none" || a3.hcOricDetached)
                a3.hcOrigStyle = { display: a3.style.display, height: a3.style.height, overflow: a3.style.overflow }, b2 = { display: "block", overflow: "hidden" }, a3 !== this.renderTo && (b2.height = 0), N2(a3, b2), a3.offsetWidth || a3.style.setProperty("display", "block", "important");
              a3 = a3.parentNode;
              if (a3 === m.body)
                break;
            }
        };
        a2.prototype.setClassName = function(b2) {
          this.container.className = "highcharts-container " + (b2 || "");
        };
        a2.prototype.getContainer = function() {
          var a3 = this.options, c2 = a3.chart, d2 = ka(), h3, f3 = this.renderTo;
          f3 || (this.renderTo = f3 = c2.renderTo);
          V(f3) && (this.renderTo = f3 = m.getElementById(f3));
          f3 || L(13, true, this);
          var l2 = ha(C2(f3, "data-highcharts-chart"));
          T(l2) && z[l2] && z[l2].hasRendered && z[l2].destroy();
          C2(f3, "data-highcharts-chart", this.index);
          f3.innerHTML = g.emptyHTML;
          c2.skipClone || f3.offsetWidth || this.temporaryDisplay();
          this.getChartSize();
          l2 = this.chartWidth;
          var k2 = this.chartHeight;
          N2(f3, { overflow: "hidden" });
          this.styledMode || (h3 = K3({
            position: "relative",
            overflow: "hidden",
            width: l2 + "px",
            height: k2 + "px",
            textAlign: "left",
            lineHeight: "normal",
            zIndex: 0,
            "-webkit-tap-highlight-color": "rgba(0,0,0,0)",
            userSelect: "none",
            "touch-action": "manipulation",
            outline: "none"
          }, c2.style || {}));
          this.container = d2 = S("div", { id: d2 }, h3, f3);
          this._cursor = d2.style.cursor;
          this.renderer = new (c2.renderer || !b ? n.getRendererType(c2.renderer) : e)(d2, l2, k2, void 0, c2.forExport, a3.exporting && a3.exporting.allowHTML, this.styledMode);
          F(void 0, this);
          this.setClassName(c2.className);
          if (this.styledMode)
            for (var p3 in a3.defs)
              this.renderer.definition(a3.defs[p3]);
          else
            this.renderer.setStyle(c2.style);
          this.renderer.chartIndex = this.index;
          Q2(this, "afterGetContainer");
        };
        a2.prototype.getMargins = function(b2) {
          var a3 = this.spacing, c2 = this.margin, d2 = this.titleOffset;
          this.resetMargins();
          d2[0] && !Y(c2[0]) && (this.plotTop = Math.max(this.plotTop, d2[0] + a3[0]));
          d2[2] && !Y(c2[2]) && (this.marginBottom = Math.max(this.marginBottom, d2[2] + a3[2]));
          this.legend && this.legend.display && this.legend.adjustMargins(c2, a3);
          Q2(this, "getMargins");
          b2 || this.getAxisMargins();
        };
        a2.prototype.getAxisMargins = function() {
          var b2 = this, a3 = b2.axisOffset = [0, 0, 0, 0], c2 = b2.colorAxis, d2 = b2.margin, e2 = function(b3) {
            b3.forEach(function(b4) {
              b4.visible && b4.getOffset();
            });
          };
          b2.hasCartesianSeries ? e2(b2.axes) : c2 && c2.length && e2(c2);
          h2.forEach(function(c3, e3) {
            Y(d2[e3]) || (b2[c3] += a3[e3]);
          });
          b2.setChartSize();
        };
        a2.prototype.reflow = function(b2) {
          var a3 = this, c2 = a3.options.chart, d2 = a3.renderTo, e2 = Y(c2.width) && Y(c2.height), h3 = c2.width || ea(d2, "width");
          c2 = c2.height || ea(d2, "height");
          d2 = b2 ? b2.target : l;
          delete a3.pointer.chartPosition;
          if (!e2 && !a3.isPrinting && h3 && c2 && (d2 === l || d2 === m)) {
            if (h3 !== a3.containerWidth || c2 !== a3.containerHeight)
              p2.clearTimeout(a3.reflowTimeout), a3.reflowTimeout = ba(function() {
                a3.container && a3.setSize(void 0, void 0, false);
              }, b2 ? 100 : 0);
            a3.containerWidth = h3;
            a3.containerHeight = c2;
          }
        };
        a2.prototype.setReflow = function(b2) {
          var a3 = this;
          b2 === false || this.unbindReflow ? b2 === false && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = r(l, "resize", function(b3) {
            a3.options && a3.reflow(b3);
          }), r(this, "destroy", this.unbindReflow));
        };
        a2.prototype.setSize = function(b2, a3, c2) {
          var d2 = this, e2 = d2.renderer;
          d2.isResizing += 1;
          F(c2, d2);
          c2 = e2.globalAnimation;
          d2.oldChartHeight = d2.chartHeight;
          d2.oldChartWidth = d2.chartWidth;
          typeof b2 !== "undefined" && (d2.options.chart.width = b2);
          typeof a3 !== "undefined" && (d2.options.chart.height = a3);
          d2.getChartSize();
          d2.styledMode || (c2 ? t : N2)(d2.container, { width: d2.chartWidth + "px", height: d2.chartHeight + "px" }, c2);
          d2.setChartSize(true);
          e2.setSize(d2.chartWidth, d2.chartHeight, c2);
          d2.axes.forEach(function(b3) {
            b3.isDirty = true;
            b3.setScale();
          });
          d2.isDirtyLegend = true;
          d2.isDirtyBox = true;
          d2.layOutTitles();
          d2.getMargins();
          d2.redraw(c2);
          d2.oldChartHeight = null;
          Q2(d2, "resize");
          ba(function() {
            d2 && Q2(d2, "endResize", null, function() {
              --d2.isResizing;
            });
          }, q2(c2).duration);
        };
        a2.prototype.setChartSize = function(b2) {
          var a3 = this.inverted, c2 = this.renderer, d2 = this.chartWidth, e2 = this.chartHeight, h3 = this.options.chart, g2 = this.spacing, f3 = this.clipOffset, l2, k2, m2, p3;
          this.plotLeft = l2 = Math.round(this.plotLeft);
          this.plotTop = k2 = Math.round(this.plotTop);
          this.plotWidth = m2 = Math.max(0, Math.round(d2 - l2 - this.marginRight));
          this.plotHeight = p3 = Math.max(0, Math.round(e2 - k2 - this.marginBottom));
          this.plotSizeX = a3 ? p3 : m2;
          this.plotSizeY = a3 ? m2 : p3;
          this.plotBorderWidth = h3.plotBorderWidth || 0;
          this.spacingBox = c2.spacingBox = { x: g2[3], y: g2[0], width: d2 - g2[3] - g2[1], height: e2 - g2[0] - g2[2] };
          this.plotBox = c2.plotBox = { x: l2, y: k2, width: m2, height: p3 };
          a3 = 2 * Math.floor(this.plotBorderWidth / 2);
          d2 = Math.ceil(Math.max(a3, f3[3]) / 2);
          e2 = Math.ceil(Math.max(a3, f3[0]) / 2);
          this.clipBox = { x: d2, y: e2, width: Math.floor(this.plotSizeX - Math.max(a3, f3[1]) / 2 - d2), height: Math.max(0, Math.floor(this.plotSizeY - Math.max(a3, f3[2]) / 2 - e2)) };
          b2 || (this.axes.forEach(function(b3) {
            b3.setAxisSize();
            b3.setAxisTranslation();
          }), c2.alignElements());
          Q2(this, "afterSetChartSize", { skipAxes: b2 });
        };
        a2.prototype.resetMargins = function() {
          Q2(this, "resetMargins");
          var b2 = this, a3 = b2.options.chart;
          ["margin", "spacing"].forEach(function(c2) {
            var d2 = a3[c2], e2 = M(d2) ? d2 : [d2, d2, d2, d2];
            ["Top", "Right", "Bottom", "Left"].forEach(function(d3, h3) {
              b2[c2][h3] = R2(a3[c2 + d3], e2[h3]);
            });
          });
          h2.forEach(function(a4, c2) {
            b2[a4] = R2(b2.margin[c2], b2.spacing[c2]);
          });
          b2.axisOffset = [0, 0, 0, 0];
          b2.clipOffset = [0, 0, 0, 0];
        };
        a2.prototype.drawChartBox = function() {
          var b2 = this.options.chart, a3 = this.renderer, c2 = this.chartWidth, d2 = this.chartHeight, e2 = this.styledMode, h3 = this.plotBGImage, g2 = b2.backgroundColor, f3 = b2.plotBackgroundColor, l2 = b2.plotBackgroundImage, k2 = this.plotLeft, m2 = this.plotTop, p3 = this.plotWidth, G3 = this.plotHeight, n2 = this.plotBox, q3 = this.clipRect, r2 = this.clipBox, t2 = this.chartBackground, M2 = this.plotBackground, y2 = this.plotBorder, z2, x2 = "animate";
          t2 || (this.chartBackground = t2 = a3.rect().addClass("highcharts-background").add(), x2 = "attr");
          if (e2)
            var v2 = z2 = t2.strokeWidth();
          else {
            v2 = b2.borderWidth || 0;
            z2 = v2 + (b2.shadow ? 8 : 0);
            g2 = { fill: g2 || "none" };
            if (v2 || t2["stroke-width"])
              g2.stroke = b2.borderColor, g2["stroke-width"] = v2;
            t2.attr(g2).shadow(b2.shadow);
          }
          t2[x2]({ x: z2 / 2, y: z2 / 2, width: c2 - z2 - v2 % 2, height: d2 - z2 - v2 % 2, r: b2.borderRadius });
          x2 = "animate";
          M2 || (x2 = "attr", this.plotBackground = M2 = a3.rect().addClass("highcharts-plot-background").add());
          M2[x2](n2);
          e2 || (M2.attr({ fill: f3 || "none" }).shadow(b2.plotShadow), l2 && (h3 ? (l2 !== h3.attr("href") && h3.attr("href", l2), h3.animate(n2)) : this.plotBGImage = a3.image(l2, k2, m2, p3, G3).add()));
          q3 ? q3.animate({ width: r2.width, height: r2.height }) : this.clipRect = a3.clipRect(r2);
          x2 = "animate";
          y2 || (x2 = "attr", this.plotBorder = y2 = a3.rect().addClass("highcharts-plot-border").attr({ zIndex: 1 }).add());
          e2 || y2.attr({ stroke: b2.plotBorderColor, "stroke-width": b2.plotBorderWidth || 0, fill: "none" });
          y2[x2](y2.crisp({ x: k2, y: m2, width: p3, height: G3 }, -y2.strokeWidth()));
          this.isDirtyBox = false;
          Q2(this, "afterDrawChartBox");
        };
        a2.prototype.propFromSeries = function() {
          var b2 = this, a3 = b2.options.chart, c2 = b2.options.series, d2, e2, h3;
          ["inverted", "angular", "polar"].forEach(function(g2) {
            e2 = v[a3.type || a3.defaultSeriesType];
            h3 = a3[g2] || e2 && e2.prototype[g2];
            for (d2 = c2 && c2.length; !h3 && d2--; )
              (e2 = v[c2[d2].type]) && e2.prototype[g2] && (h3 = true);
            b2[g2] = h3;
          });
        };
        a2.prototype.linkSeries = function() {
          var b2 = this, a3 = b2.series;
          a3.forEach(function(b3) {
            b3.linkedSeries.length = 0;
          });
          a3.forEach(function(a4) {
            var c2 = a4.options.linkedTo;
            V(c2) && (c2 = c2 === ":previous" ? b2.series[a4.index - 1] : b2.get(c2)) && c2.linkedParent !== a4 && (c2.linkedSeries.push(a4), a4.linkedParent = c2, c2.enabledDataSorting && a4.setDataSortingOptions(), a4.visible = R2(a4.options.visible, c2.options.visible, a4.visible));
          });
          Q2(this, "afterLinkSeries");
        };
        a2.prototype.renderSeries = function() {
          this.series.forEach(function(b2) {
            b2.translate();
            b2.render();
          });
        };
        a2.prototype.renderLabels = function() {
          var b2 = this, a3 = b2.options.labels;
          a3.items && a3.items.forEach(function(c2) {
            var d2 = K3(a3.style, c2.style), e2 = ha(d2.left) + b2.plotLeft, h3 = ha(d2.top) + b2.plotTop + 12;
            delete d2.left;
            delete d2.top;
            b2.renderer.text(c2.html, e2, h3).attr({ zIndex: 2 }).css(d2).add();
          });
        };
        a2.prototype.render = function() {
          var b2 = this.axes, a3 = this.colorAxis, c2 = this.renderer, d2 = this.options, e2 = function(b3) {
            b3.forEach(function(b4) {
              b4.visible && b4.render();
            });
          }, h3 = 0;
          this.setTitle();
          this.legend = new E2(this, d2.legend);
          this.getStacks && this.getStacks();
          this.getMargins(true);
          this.setChartSize();
          d2 = this.plotWidth;
          b2.some(function(b3) {
            if (b3.horiz && b3.visible && b3.options.labels.enabled && b3.series.length)
              return h3 = 21, true;
          });
          var g2 = this.plotHeight = Math.max(this.plotHeight - h3, 0);
          b2.forEach(function(b3) {
            b3.setScale();
          });
          this.getAxisMargins();
          var f3 = 1.1 < d2 / this.plotWidth, l2 = 1.05 < g2 / this.plotHeight;
          if (f3 || l2)
            b2.forEach(function(b3) {
              (b3.horiz && f3 || !b3.horiz && l2) && b3.setTickInterval(true);
            }), this.getMargins();
          this.drawChartBox();
          this.hasCartesianSeries ? e2(b2) : a3 && a3.length && e2(a3);
          this.seriesGroup || (this.seriesGroup = c2.g("series-group").attr({ zIndex: 3 }).add());
          this.renderSeries();
          this.renderLabels();
          this.addCredits();
          this.setResponsive && this.setResponsive();
          this.hasRendered = true;
        };
        a2.prototype.addCredits = function(b2) {
          var a3 = this, c2 = W2(true, this.options.credits, b2);
          c2.enabled && !this.credits && (this.credits = this.renderer.text(c2.text + (this.mapCredits || ""), 0, 0).addClass("highcharts-credits").on("click", function() {
            c2.href && (l.location.href = c2.href);
          }).attr({ align: c2.position.align, zIndex: 8 }), a3.styledMode || this.credits.css(c2.style), this.credits.add().align(c2.position), this.credits.update = function(b3) {
            a3.credits = a3.credits.destroy();
            a3.addCredits(b3);
          });
        };
        a2.prototype.destroy = function() {
          var b2 = this, a3 = b2.axes, c2 = b2.series, d2 = b2.container, e2 = d2 && d2.parentNode, h3;
          Q2(b2, "destroy");
          b2.renderer.forExport ? J2(z, b2) : z[b2.index] = void 0;
          w.chartCount--;
          b2.renderTo.removeAttribute("data-highcharts-chart");
          ja(b2);
          for (h3 = a3.length; h3--; )
            a3[h3] = a3[h3].destroy();
          this.scroller && this.scroller.destroy && this.scroller.destroy();
          for (h3 = c2.length; h3--; )
            c2[h3] = c2[h3].destroy();
          "title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer".split(" ").forEach(function(a4) {
            var c3 = b2[a4];
            c3 && c3.destroy && (b2[a4] = c3.destroy());
          });
          d2 && (d2.innerHTML = g.emptyHTML, ja(d2), e2 && X2(d2));
          Z2(b2, function(a4, c3) {
            delete b2[c3];
          });
        };
        a2.prototype.firstRender = function() {
          var b2 = this, a3 = b2.options;
          if (!b2.isReadyToRender || b2.isReadyToRender()) {
            b2.getContainer();
            b2.resetMargins();
            b2.setChartSize();
            b2.propFromSeries();
            b2.getAxes();
            (G2(a3.series) ? a3.series : []).forEach(function(a4) {
              b2.initSeries(a4);
            });
            b2.linkSeries();
            b2.setSeriesData();
            Q2(b2, "beforeRender");
            u && (I2.isRequired() ? b2.pointer = new I2(b2, a3) : b2.pointer = new u(b2, a3));
            b2.render();
            b2.pointer.getChartPosition();
            if (!b2.renderer.imgCount && !b2.hasLoaded)
              b2.onload();
            b2.temporaryDisplay(true);
          }
        };
        a2.prototype.onload = function() {
          this.callbacks.concat([this.callback]).forEach(function(b2) {
            b2 && typeof this.index !== "undefined" && b2.apply(this, [this]);
          }, this);
          Q2(this, "load");
          Q2(this, "render");
          Y(this.index) && this.setReflow(this.options.chart.reflow);
          this.warnIfA11yModuleNotLoaded();
          this.hasLoaded = true;
        };
        a2.prototype.warnIfA11yModuleNotLoaded = function() {
          var b2 = this;
          setTimeout(function() {
            var a3 = b2 && b2.options;
            !a3 || b2.accessibility || a3.accessibility && a3.accessibility.enabled === false || L('Highcharts warning: Consider including the "accessibility.js" module to make your chart more usable for people with disabilities. Set the "accessibility.enabled" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', false, b2);
          }, 100);
        };
        a2.prototype.addSeries = function(b2, a3, c2) {
          var d2 = this, e2;
          b2 && (a3 = R2(a3, true), Q2(d2, "addSeries", { options: b2 }, function() {
            e2 = d2.initSeries(b2);
            d2.isDirtyLegend = true;
            d2.linkSeries();
            e2.enabledDataSorting && e2.setData(b2.data, false);
            Q2(d2, "afterAddSeries", { series: e2 });
            a3 && d2.redraw(c2);
          }));
          return e2;
        };
        a2.prototype.addAxis = function(b2, a3, c2, d2) {
          return this.createAxis(a3 ? "xAxis" : "yAxis", { axis: b2, redraw: c2, animation: d2 });
        };
        a2.prototype.addColorAxis = function(b2, a3, c2) {
          return this.createAxis("colorAxis", { axis: b2, redraw: a3, animation: c2 });
        };
        a2.prototype.createAxis = function(b2, a3) {
          b2 = new f2(this, W2(a3.axis, { index: this[b2].length, isX: b2 === "xAxis" }));
          R2(a3.redraw, true) && this.redraw(a3.animation);
          return b2;
        };
        a2.prototype.showLoading = function(b2) {
          var a3 = this, c2 = a3.options, d2 = c2.loading, e2 = function() {
            h3 && N2(h3, { left: a3.plotLeft + "px", top: a3.plotTop + "px", width: a3.plotWidth + "px", height: a3.plotHeight + "px" });
          }, h3 = a3.loadingDiv, f3 = a3.loadingSpan;
          h3 || (a3.loadingDiv = h3 = S("div", { className: "highcharts-loading highcharts-loading-hidden" }, null, a3.container));
          f3 || (a3.loadingSpan = f3 = S("span", { className: "highcharts-loading-inner" }, null, h3), r(a3, "redraw", e2));
          h3.className = "highcharts-loading";
          g.setElementHTML(f3, R2(b2, c2.lang.loading, ""));
          a3.styledMode || (N2(h3, K3(d2.style, { zIndex: 10 })), N2(f3, d2.labelStyle), a3.loadingShown || (N2(h3, {
            opacity: 0,
            display: ""
          }), t(h3, { opacity: d2.style.opacity || 0.5 }, { duration: d2.showDuration || 0 })));
          a3.loadingShown = true;
          e2();
        };
        a2.prototype.hideLoading = function() {
          var b2 = this.options, a3 = this.loadingDiv;
          a3 && (a3.className = "highcharts-loading highcharts-loading-hidden", this.styledMode || t(a3, { opacity: 0 }, { duration: b2.loading.hideDuration || 100, complete: function() {
            N2(a3, { display: "none" });
          } }));
          this.loadingShown = false;
        };
        a2.prototype.update = function(b2, a3, d2, e2) {
          var h3 = this, g2 = { credits: "addCredits", title: "setTitle", subtitle: "setSubtitle", caption: "setCaption" }, f3 = b2.isResponsiveOptions, l2 = [], k2, m2;
          Q2(h3, "update", { options: b2 });
          f3 || h3.setResponsive(false, true);
          b2 = P2(b2, h3.options);
          h3.userOptions = W2(h3.userOptions, b2);
          var p3 = b2.chart;
          if (p3) {
            W2(true, h3.options.chart, p3);
            "className" in p3 && h3.setClassName(p3.className);
            "reflow" in p3 && h3.setReflow(p3.reflow);
            if ("inverted" in p3 || "polar" in p3 || "type" in p3) {
              h3.propFromSeries();
              var G3 = true;
            }
            "alignTicks" in p3 && (G3 = true);
            "events" in p3 && x(this, p3);
            Z2(p3, function(b3, a4) {
              h3.propsRequireUpdateSeries.indexOf("chart." + a4) !== -1 && (k2 = true);
              h3.propsRequireDirtyBox.indexOf(a4) !== -1 && (h3.isDirtyBox = true);
              h3.propsRequireReflow.indexOf(a4) !== -1 && (f3 ? h3.isDirtyBox = true : m2 = true);
            });
            !h3.styledMode && p3.style && h3.renderer.setStyle(h3.options.chart.style || {});
          }
          !h3.styledMode && b2.colors && (this.options.colors = b2.colors);
          b2.time && (this.time === D && (this.time = new c(b2.time)), W2(true, h3.options.time, b2.time));
          Z2(b2, function(a4, c2) {
            if (h3[c2] && typeof h3[c2].update === "function")
              h3[c2].update(a4, false);
            else if (typeof h3[g2[c2]] === "function")
              h3[g2[c2]](a4);
            else
              c2 !== "colors" && h3.collectionsWithUpdate.indexOf(c2) === -1 && W2(true, h3.options[c2], b2[c2]);
            c2 !== "chart" && h3.propsRequireUpdateSeries.indexOf(c2) !== -1 && (k2 = true);
          });
          this.collectionsWithUpdate.forEach(function(a4) {
            if (b2[a4]) {
              var c2 = [];
              h3[a4].forEach(function(b3, a5) {
                b3.options.isInternal || c2.push(R2(b3.options.index, a5));
              });
              ia(b2[a4]).forEach(function(b3, e3) {
                var g3 = Y(b3.id), f4;
                g3 && (f4 = h3.get(b3.id));
                !f4 && h3[a4] && (f4 = h3[a4][c2 ? c2[e3] : e3]) && g3 && Y(f4.options.id) && (f4 = void 0);
                f4 && f4.coll === a4 && (f4.update(b3, false), d2 && (f4.touched = true));
                !f4 && d2 && h3.collectionsWithInit[a4] && (h3.collectionsWithInit[a4][0].apply(h3, [b3].concat(h3.collectionsWithInit[a4][1] || []).concat([false])).touched = true);
              });
              d2 && h3[a4].forEach(function(b3) {
                b3.touched || b3.options.isInternal ? delete b3.touched : l2.push(b3);
              });
            }
          });
          l2.forEach(function(b3) {
            b3.chart && b3.remove && b3.remove(false);
          });
          G3 && h3.axes.forEach(function(b3) {
            b3.update({}, false);
          });
          k2 && h3.getSeriesOrderByLinks().forEach(function(b3) {
            b3.chart && b3.update({}, false);
          }, this);
          G3 = p3 && p3.width;
          p3 = p3 && (V(p3.height) ? aa(p3.height, G3 || h3.chartWidth) : p3.height);
          m2 || T(G3) && G3 !== h3.chartWidth || T(p3) && p3 !== h3.chartHeight ? h3.setSize(G3, p3, e2) : R2(a3, true) && h3.redraw(e2);
          Q2(h3, "afterUpdate", { options: b2, redraw: a3, animation: e2 });
        };
        a2.prototype.setSubtitle = function(b2, a3) {
          this.applyDescription("subtitle", b2);
          this.layOutTitles(a3);
        };
        a2.prototype.setCaption = function(b2, a3) {
          this.applyDescription("caption", b2);
          this.layOutTitles(a3);
        };
        a2.prototype.showResetZoom = function() {
          function b2() {
            a3.zoomOut();
          }
          var a3 = this, c2 = d.lang, e2 = a3.options.chart.resetZoomButton, h3 = e2.theme, g2 = e2.relativeTo === "chart" || e2.relativeTo === "spacingBox" ? null : "scrollablePlotBox";
          Q2(this, "beforeShowResetZoom", null, function() {
            a3.resetZoomButton = a3.renderer.button(c2.resetZoom, null, null, b2, h3).attr({ align: e2.position.align, title: c2.resetZoomTitle }).addClass("highcharts-reset-zoom").add().align(e2.position, false, g2);
          });
          Q2(this, "afterShowResetZoom");
        };
        a2.prototype.zoomOut = function() {
          Q2(this, "selection", { resetSelection: true }, this.zoom);
        };
        a2.prototype.zoom = function(b2) {
          var a3 = this, c2 = a3.pointer, d2 = a3.inverted ? c2.mouseDownX : c2.mouseDownY, e2 = false, h3;
          !b2 || b2.resetSelection ? (a3.axes.forEach(function(b3) {
            h3 = b3.zoom();
          }), c2.initiated = false) : b2.xAxis.concat(b2.yAxis).forEach(function(b3) {
            var g3 = b3.axis, f3 = a3.inverted ? g3.left : g3.top, l2 = a3.inverted ? f3 + g3.width : f3 + g3.height, k2 = g3.isXAxis, m2 = false;
            if (!k2 && d2 >= f3 && d2 <= l2 || k2 || !Y(d2))
              m2 = true;
            c2[k2 ? "zoomX" : "zoomY"] && m2 && (h3 = g3.zoom(b3.min, b3.max), g3.displayBtn && (e2 = true));
          });
          var g2 = a3.resetZoomButton;
          e2 && !g2 ? a3.showResetZoom() : !e2 && M(g2) && (a3.resetZoomButton = g2.destroy());
          h3 && a3.redraw(R2(a3.options.chart.animation, b2 && b2.animation, 100 > a3.pointCount));
        };
        a2.prototype.pan = function(b2, a3) {
          var c2 = this, d2 = c2.hoverPoints;
          a3 = typeof a3 === "object" ? a3 : { enabled: a3, type: "x" };
          var e2 = c2.options.chart, h3 = c2.options.mapNavigation && c2.options.mapNavigation.enabled;
          e2 && e2.panning && (e2.panning = a3);
          var g2 = a3.type, f3;
          Q2(this, "pan", { originalEvent: b2 }, function() {
            d2 && d2.forEach(function(b3) {
              b3.setState();
            });
            var a4 = c2.xAxis;
            g2 === "xy" ? a4 = a4.concat(c2.yAxis) : g2 === "y" && (a4 = c2.yAxis);
            var e3 = {};
            a4.forEach(function(a5) {
              if (a5.options.panningEnabled && !a5.options.isInternal) {
                var d3 = a5.horiz, l2 = b2[d3 ? "chartX" : "chartY"];
                d3 = d3 ? "mouseDownX" : "mouseDownY";
                var k2 = c2[d3], m2 = a5.minPointOffset || 0, p3 = a5.reversed && !c2.inverted || !a5.reversed && c2.inverted ? -1 : 1, G3 = a5.getExtremes(), n2 = a5.toValue(k2 - l2, true) + m2 * p3, q3 = a5.toValue(k2 + a5.len - l2, true) - (m2 * p3 || a5.isXAxis && a5.pointRangePadding || 0), r2 = q3 < n2;
                p3 = a5.hasVerticalPanning();
                k2 = r2 ? q3 : n2;
                n2 = r2 ? n2 : q3;
                var t2 = a5.panningState;
                !p3 || a5.isXAxis || t2 && !t2.isDirty || a5.series.forEach(function(b3) {
                  var a6 = b3.getProcessedData(true);
                  a6 = b3.getExtremes(a6.yData, true);
                  t2 || (t2 = { startMin: Number.MAX_VALUE, startMax: -Number.MAX_VALUE });
                  T(a6.dataMin) && T(a6.dataMax) && (t2.startMin = Math.min(R2(b3.options.threshold, Infinity), a6.dataMin, t2.startMin), t2.startMax = Math.max(R2(b3.options.threshold, -Infinity), a6.dataMax, t2.startMax));
                });
                p3 = Math.min(R2(t2 && t2.startMin, G3.dataMin), m2 ? G3.min : a5.toValue(a5.toPixels(G3.min) - a5.minPixelPadding));
                q3 = Math.max(R2(t2 && t2.startMax, G3.dataMax), m2 ? G3.max : a5.toValue(a5.toPixels(G3.max) + a5.minPixelPadding));
                a5.panningState = t2;
                a5.isOrdinal || (m2 = p3 - k2, 0 < m2 && (n2 += m2, k2 = p3), m2 = n2 - q3, 0 < m2 && (n2 = q3, k2 -= m2), a5.series.length && k2 !== G3.min && n2 !== G3.max && k2 >= p3 && n2 <= q3 && (a5.setExtremes(k2, n2, false, false, { trigger: "pan" }), c2.resetZoomButton || h3 || k2 === p3 || n2 === q3 || !g2.match("y") || (c2.showResetZoom(), a5.displayBtn = false), f3 = true), e3[d3] = l2);
              }
            });
            Z2(e3, function(b3, a5) {
              c2[a5] = b3;
            });
            f3 && c2.redraw(false);
            N2(c2.container, { cursor: "move" });
          });
        };
        return a2;
      }();
      K3(a.prototype, {
        callbacks: [],
        collectionsWithInit: { xAxis: [a.prototype.addAxis, [true]], yAxis: [a.prototype.addAxis, [false]], series: [a.prototype.addSeries] },
        collectionsWithUpdate: ["xAxis", "yAxis", "series"],
        propsRequireDirtyBox: "backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow".split(" "),
        propsRequireReflow: "margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft".split(" "),
        propsRequireUpdateSeries: "chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip".split(" ")
      });
      return a;
    });
    K2(f, "Core/Legend/LegendSymbol.js", [f["Core/Utilities.js"]], function(a) {
      var f2 = a.merge, B2 = a.pick, H2;
      (function(a2) {
        a2.drawLineMarker = function(a3) {
          var w = this.options, A = a3.symbolWidth, u = a3.symbolHeight, n = u / 2, k = this.chart.renderer, e = this.legendGroup;
          a3 = a3.baseline - Math.round(0.3 * a3.fontMetrics.b);
          var c = {}, p2 = w.marker;
          this.chart.styledMode || (c = { "stroke-width": w.lineWidth || 0 }, w.dashStyle && (c.dashstyle = w.dashStyle));
          this.legendLine = k.path([["M", 0, a3], ["L", A, a3]]).addClass("highcharts-graph").attr(c).add(e);
          p2 && p2.enabled !== false && A && (w = Math.min(B2(p2.radius, n), n), this.symbol.indexOf("url") === 0 && (p2 = f2(p2, { width: u, height: u }), w = 0), this.legendSymbol = A = k.symbol(this.symbol, A / 2 - w, a3 - w, 2 * w, 2 * w, p2).addClass("highcharts-point").add(e), A.isMarker = true);
        };
        a2.drawRectangle = function(a3, f3) {
          var w = a3.symbolHeight, u = a3.options.squareSymbol;
          f3.legendSymbol = this.chart.renderer.rect(u ? (a3.symbolWidth - w) / 2 : 0, a3.baseline - w + 1, u ? w : a3.symbolWidth, w, B2(a3.options.symbolRadius, w / 2)).addClass("highcharts-point").attr({ zIndex: 3 }).add(f3.legendGroup);
        };
      })(H2 || (H2 = {}));
      return H2;
    });
    K2(f, "Core/Series/SeriesDefaults.js", [], function() {
      return { lineWidth: 2, allowPointSelect: false, crisp: true, showCheckbox: false, animation: { duration: 1e3 }, events: {}, marker: { enabledThreshold: 2, lineColor: "#ffffff", lineWidth: 0, radius: 4, states: { normal: { animation: true }, hover: { animation: { duration: 50 }, enabled: true, radiusPlus: 2, lineWidthPlus: 1 }, select: { fillColor: "#cccccc", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: { animation: {}, align: "center", defer: true, formatter: function() {
        var a = this.series.chart.numberFormatter;
        return typeof this.y !== "number" ? "" : a(this.y, -1);
      }, padding: 5, style: { fontSize: "11px", fontWeight: "bold", color: "contrast", textOutline: "1px contrast" }, verticalAlign: "bottom", x: 0, y: 0 }, cropThreshold: 300, opacity: 1, pointRange: 0, softThreshold: true, states: { normal: { animation: true }, hover: { animation: { duration: 50 }, lineWidthPlus: 1, marker: {}, halo: { size: 10, opacity: 0.25 } }, select: { animation: { duration: 0 } }, inactive: { animation: { duration: 50 }, opacity: 0.2 } }, stickyTracking: true, turboThreshold: 1e3, findNearestPointBy: "x" };
    });
    K2(f, "Core/Series/Series.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/DefaultOptions.js"], f["Core/Foundation.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/Point.js"], f["Core/Series/SeriesDefaults.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/SVGElement.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2, w, E2, I2, A, u, n) {
      var k = a.animObject, e = a.setAnimation, c = f2.defaultOptions, p2 = B2.registerEventOptions, g = H2.hasTouch, t = H2.svg, q2 = H2.win, F = A.seriesTypes, y = n.addEvent, x = n.arrayMax, z = n.arrayMin, m = n.clamp, h2 = n.cleanRecursively, b = n.correctFloat, l = n.defined, d = n.erase, D = n.error, v = n.extend, r = n.find, C2 = n.fireEvent, P2 = n.getNestedProperty, S = n.isArray, N2 = n.isNumber, Y = n.isString, X2 = n.merge, J2 = n.objectEach, L = n.pick, K3 = n.removeEvent, da = n.splat, Q2 = n.syncTimeout;
      a = function() {
        function a2() {
          this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;
        }
        a2.prototype.init = function(b2, a3) {
          C2(this, "init", { options: a3 });
          var c2 = this, d2 = b2.series;
          this.eventsToUnbind = [];
          c2.chart = b2;
          c2.options = c2.setOptions(a3);
          a3 = c2.options;
          c2.linkedSeries = [];
          c2.bindAxes();
          v(c2, { name: a3.name, state: "", visible: a3.visible !== false, selected: a3.selected === true });
          p2(this, a3);
          var e2 = a3.events;
          if (e2 && e2.click || a3.point && a3.point.events && a3.point.events.click || a3.allowPointSelect)
            b2.runTrackerClick = true;
          c2.getColor();
          c2.getSymbol();
          c2.parallelArrays.forEach(function(b3) {
            c2[b3 + "Data"] || (c2[b3 + "Data"] = []);
          });
          c2.isCartesian && (b2.hasCartesianSeries = true);
          var h3;
          d2.length && (h3 = d2[d2.length - 1]);
          c2._i = L(h3 && h3._i, -1) + 1;
          c2.opacity = c2.options.opacity;
          b2.orderSeries(this.insert(d2));
          a3.dataSorting && a3.dataSorting.enabled ? c2.setDataSortingOptions() : c2.points || c2.data || c2.setData(a3.data, false);
          C2(this, "afterInit");
        };
        a2.prototype.is = function(b2) {
          return F[b2] && this instanceof F[b2];
        };
        a2.prototype.insert = function(b2) {
          var a3 = this.options.index, c2;
          if (N2(a3)) {
            for (c2 = b2.length; c2--; )
              if (a3 >= L(b2[c2].options.index, b2[c2]._i)) {
                b2.splice(c2 + 1, 0, this);
                break;
              }
            c2 === -1 && b2.unshift(this);
            c2 += 1;
          } else
            b2.push(this);
          return L(c2, b2.length - 1);
        };
        a2.prototype.bindAxes = function() {
          var b2 = this, a3 = b2.options, c2 = b2.chart, d2;
          C2(this, "bindAxes", null, function() {
            (b2.axisTypes || []).forEach(function(e2) {
              var h3 = 0;
              c2[e2].forEach(function(c3) {
                d2 = c3.options;
                if (a3[e2] === h3 && !d2.isInternal || typeof a3[e2] !== "undefined" && a3[e2] === d2.id || typeof a3[e2] === "undefined" && d2.index === 0)
                  b2.insert(c3.series), b2[e2] = c3, c3.isDirty = true;
                d2.isInternal || h3++;
              });
              b2[e2] || b2.optionalAxis === e2 || D(18, true, c2);
            });
          });
          C2(this, "afterBindAxes");
        };
        a2.prototype.updateParallelArrays = function(b2, a3) {
          var c2 = b2.series, d2 = arguments, e2 = N2(a3) ? function(d3) {
            var e3 = d3 === "y" && c2.toYData ? c2.toYData(b2) : b2[d3];
            c2[d3 + "Data"][a3] = e3;
          } : function(b3) {
            Array.prototype[a3].apply(c2[b3 + "Data"], Array.prototype.slice.call(d2, 2));
          };
          c2.parallelArrays.forEach(e2);
        };
        a2.prototype.hasData = function() {
          return this.visible && typeof this.dataMax !== "undefined" && typeof this.dataMin !== "undefined" || this.visible && this.yData && 0 < this.yData.length;
        };
        a2.prototype.autoIncrement = function(b2) {
          var a3 = this.options, c2 = a3.pointIntervalUnit, d2 = a3.relativeXValue, e2 = this.chart.time, h3 = this.xIncrement, g2;
          h3 = L(h3, a3.pointStart, 0);
          this.pointInterval = g2 = L(this.pointInterval, a3.pointInterval, 1);
          d2 && N2(b2) && (g2 *= b2);
          c2 && (a3 = new e2.Date(h3), c2 === "day" ? e2.set("Date", a3, e2.get("Date", a3) + g2) : c2 === "month" ? e2.set("Month", a3, e2.get("Month", a3) + g2) : c2 === "year" && e2.set("FullYear", a3, e2.get("FullYear", a3) + g2), g2 = a3.getTime() - h3);
          if (d2 && N2(b2))
            return h3 + g2;
          this.xIncrement = h3 + g2;
          return h3;
        };
        a2.prototype.setDataSortingOptions = function() {
          var b2 = this.options;
          v(this, { requireSorting: false, sorted: false, enabledDataSorting: true, allowDG: false });
          l(b2.pointRange) || (b2.pointRange = 1);
        };
        a2.prototype.setOptions = function(b2) {
          var a3 = this.chart, d2 = a3.options, e2 = d2.plotOptions, h3 = a3.userOptions || {};
          b2 = X2(b2);
          a3 = a3.styledMode;
          var g2 = { plotOptions: e2, userOptions: b2 };
          C2(this, "setOptions", g2);
          var f3 = g2.plotOptions[this.type], k2 = h3.plotOptions || {};
          this.userOptions = g2.userOptions;
          h3 = X2(f3, e2.series, h3.plotOptions && h3.plotOptions[this.type], b2);
          this.tooltipOptions = X2(c.tooltip, c.plotOptions.series && c.plotOptions.series.tooltip, c.plotOptions[this.type].tooltip, d2.tooltip.userOptions, e2.series && e2.series.tooltip, e2[this.type].tooltip, b2.tooltip);
          this.stickyTracking = L(b2.stickyTracking, k2[this.type] && k2[this.type].stickyTracking, k2.series && k2.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? true : h3.stickyTracking);
          f3.marker === null && delete h3.marker;
          this.zoneAxis = h3.zoneAxis;
          e2 = this.zones = (h3.zones || []).slice();
          !h3.negativeColor && !h3.negativeFillColor || h3.zones || (d2 = { value: h3[this.zoneAxis + "Threshold"] || h3.threshold || 0, className: "highcharts-negative" }, a3 || (d2.color = h3.negativeColor, d2.fillColor = h3.negativeFillColor), e2.push(d2));
          e2.length && l(e2[e2.length - 1].value) && e2.push(a3 ? {} : { color: this.color, fillColor: this.fillColor });
          C2(this, "afterSetOptions", { options: h3 });
          return h3;
        };
        a2.prototype.getName = function() {
          return L(this.options.name, "Series " + (this.index + 1));
        };
        a2.prototype.getCyclic = function(b2, a3, c2) {
          var d2 = this.chart, e2 = this.userOptions, h3 = b2 + "Index", g2 = b2 + "Counter", f3 = c2 ? c2.length : L(d2.options.chart[b2 + "Count"], d2[b2 + "Count"]);
          if (!a3) {
            var k2 = L(e2[h3], e2["_" + h3]);
            l(k2) || (d2.series.length || (d2[g2] = 0), e2["_" + h3] = k2 = d2[g2] % f3, d2[g2] += 1);
            c2 && (a3 = c2[k2]);
          }
          typeof k2 !== "undefined" && (this[h3] = k2);
          this[b2] = a3;
        };
        a2.prototype.getColor = function() {
          this.chart.styledMode ? this.getCyclic("color") : this.options.colorByPoint ? this.color = "#cccccc" : this.getCyclic("color", this.options.color || c.plotOptions[this.type].color, this.chart.options.colors);
        };
        a2.prototype.getPointsCollection = function() {
          return (this.hasGroupedData ? this.points : this.data) || [];
        };
        a2.prototype.getSymbol = function() {
          this.getCyclic("symbol", this.options.marker.symbol, this.chart.options.symbols);
        };
        a2.prototype.findPointIndex = function(b2, a3) {
          var c2 = b2.id, d2 = b2.x, e2 = this.points, h3 = this.options.dataSorting, g2, f3;
          if (c2)
            h3 = this.chart.get(c2), h3 instanceof E2 && (g2 = h3);
          else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) {
            if (g2 = function(a4) {
              return !a4.touched && a4.index === b2.index;
            }, h3 && h3.matchByName ? g2 = function(a4) {
              return !a4.touched && a4.name === b2.name;
            } : this.options.relativeXValue && (g2 = function(a4) {
              return !a4.touched && a4.options.x === b2.x;
            }), g2 = r(e2, g2), !g2)
              return;
          }
          if (g2) {
            var l2 = g2 && g2.index;
            typeof l2 !== "undefined" && (f3 = true);
          }
          typeof l2 === "undefined" && N2(d2) && (l2 = this.xData.indexOf(d2, a3));
          l2 !== -1 && typeof l2 !== "undefined" && this.cropped && (l2 = l2 >= this.cropStart ? l2 - this.cropStart : l2);
          !f3 && N2(l2) && e2[l2] && e2[l2].touched && (l2 = void 0);
          return l2;
        };
        a2.prototype.updateData = function(b2, a3) {
          var c2 = this.options, d2 = c2.dataSorting, e2 = this.points, h3 = [], g2 = this.requireSorting, f3 = b2.length === e2.length, k2, m2, p3, n2 = true;
          this.xIncrement = null;
          b2.forEach(function(b3, a4) {
            var m3 = l(b3) && this.pointClass.prototype.optionsToObject.call({ series: this }, b3) || {}, n3 = m3.x;
            if (m3.id || N2(n3)) {
              if (m3 = this.findPointIndex(m3, p3), m3 === -1 || typeof m3 === "undefined" ? h3.push(b3) : e2[m3] && b3 !== c2.data[m3] ? (e2[m3].update(b3, false, null, false), e2[m3].touched = true, g2 && (p3 = m3 + 1)) : e2[m3] && (e2[m3].touched = true), !f3 || a4 !== m3 || d2 && d2.enabled || this.hasDerivedData)
                k2 = true;
            } else
              h3.push(b3);
          }, this);
          if (k2)
            for (b2 = e2.length; b2--; )
              (m2 = e2[b2]) && !m2.touched && m2.remove && m2.remove(false, a3);
          else
            !f3 || d2 && d2.enabled ? n2 = false : (b2.forEach(function(b3, a4) {
              b3 !== e2[a4].y && e2[a4].update && e2[a4].update(b3, false, null, false);
            }), h3.length = 0);
          e2.forEach(function(b3) {
            b3 && (b3.touched = false);
          });
          if (!n2)
            return false;
          h3.forEach(function(b3) {
            this.addPoint(b3, false, null, null, false);
          }, this);
          this.xIncrement === null && this.xData && this.xData.length && (this.xIncrement = x(this.xData), this.autoIncrement());
          return true;
        };
        a2.prototype.setData = function(b2, a3, c2, d2) {
          var e2 = this, h3 = e2.points, g2 = h3 && h3.length || 0, f3 = e2.options, l2 = e2.chart, k2 = f3.dataSorting, m2 = e2.xAxis, p3 = f3.turboThreshold, n2 = this.xData, q3 = this.yData, r2 = e2.pointArrayMap;
          r2 = r2 && r2.length;
          var G2 = f3.keys, t2, y2 = 0, z2 = 1, x2 = null;
          if (!l2.options.chart.allowMutatingData) {
            f3.data && delete e2.options.data;
            e2.userOptions.data && delete e2.userOptions.data;
            var v2 = X2(true, b2);
          }
          b2 = v2 || b2 || [];
          v2 = b2.length;
          a3 = L(a3, true);
          k2 && k2.enabled && (b2 = this.sortData(b2));
          l2.options.chart.allowMutatingData && d2 !== false && v2 && g2 && !e2.cropped && !e2.hasGroupedData && e2.visible && !e2.isSeriesBoosting && (t2 = this.updateData(b2, c2));
          if (!t2) {
            e2.xIncrement = null;
            e2.colorCounter = 0;
            this.parallelArrays.forEach(function(b3) {
              e2[b3 + "Data"].length = 0;
            });
            if (p3 && v2 > p3)
              if (x2 = e2.getFirstValidPoint(b2), N2(x2))
                for (c2 = 0; c2 < v2; c2++)
                  n2[c2] = this.autoIncrement(), q3[c2] = b2[c2];
              else if (S(x2))
                if (r2)
                  if (x2.length === r2)
                    for (c2 = 0; c2 < v2; c2++)
                      n2[c2] = this.autoIncrement(), q3[c2] = b2[c2];
                  else
                    for (c2 = 0; c2 < v2; c2++)
                      d2 = b2[c2], n2[c2] = d2[0], q3[c2] = d2.slice(1, r2 + 1);
                else if (G2 && (y2 = G2.indexOf("x"), z2 = G2.indexOf("y"), y2 = 0 <= y2 ? y2 : 0, z2 = 0 <= z2 ? z2 : 1), x2.length === 1 && (z2 = 0), y2 === z2)
                  for (c2 = 0; c2 < v2; c2++)
                    n2[c2] = this.autoIncrement(), q3[c2] = b2[c2][z2];
                else
                  for (c2 = 0; c2 < v2; c2++)
                    d2 = b2[c2], n2[c2] = d2[y2], q3[c2] = d2[z2];
              else
                D(12, false, l2);
            else
              for (c2 = 0; c2 < v2; c2++)
                typeof b2[c2] !== "undefined" && (d2 = { series: e2 }, e2.pointClass.prototype.applyOptions.apply(d2, [b2[c2]]), e2.updateParallelArrays(d2, c2));
            q3 && Y(q3[0]) && D(14, true, l2);
            e2.data = [];
            e2.options.data = e2.userOptions.data = b2;
            for (c2 = g2; c2--; )
              h3[c2] && h3[c2].destroy && h3[c2].destroy();
            m2 && (m2.minRange = m2.userMinRange);
            e2.isDirty = l2.isDirtyBox = true;
            e2.isDirtyData = !!h3;
            c2 = false;
          }
          f3.legendType === "point" && (this.processData(), this.generatePoints());
          a3 && l2.redraw(c2);
        };
        a2.prototype.sortData = function(b2) {
          var a3 = this, c2 = a3.options.dataSorting.sortKey || "y", d2 = function(b3, a4) {
            return l(a4) && b3.pointClass.prototype.optionsToObject.call({ series: b3 }, a4) || {};
          };
          b2.forEach(function(c3, e2) {
            b2[e2] = d2(a3, c3);
            b2[e2].index = e2;
          }, this);
          b2.concat().sort(function(b3, a4) {
            b3 = P2(c2, b3);
            a4 = P2(c2, a4);
            return a4 < b3 ? -1 : a4 > b3 ? 1 : 0;
          }).forEach(function(b3, a4) {
            b3.x = a4;
          }, this);
          a3.linkedSeries && a3.linkedSeries.forEach(function(a4) {
            var c3 = a4.options, e2 = c3.data;
            c3.dataSorting && c3.dataSorting.enabled || !e2 || (e2.forEach(function(c4, h3) {
              e2[h3] = d2(a4, c4);
              b2[h3] && (e2[h3].x = b2[h3].x, e2[h3].index = h3);
            }), a4.setData(e2, false));
          });
          return b2;
        };
        a2.prototype.getProcessedData = function(b2) {
          var a3 = this.xAxis, c2 = this.options, d2 = c2.cropThreshold, e2 = b2 || this.getExtremesFromAll || c2.getExtremesFromAll, h3 = this.isCartesian;
          b2 = a3 && a3.val2lin;
          c2 = !(!a3 || !a3.logarithmic);
          var g2 = 0, f3 = this.xData, l2 = this.yData, k2 = this.requireSorting;
          var m2 = false;
          var p3 = f3.length;
          if (a3) {
            m2 = a3.getExtremes();
            var n2 = m2.min;
            var q3 = m2.max;
            m2 = !(!a3.categories || a3.names.length);
          }
          if (h3 && this.sorted && !e2 && (!d2 || p3 > d2 || this.forceCrop)) {
            if (f3[p3 - 1] < n2 || f3[0] > q3)
              f3 = [], l2 = [];
            else if (this.yData && (f3[0] < n2 || f3[p3 - 1] > q3)) {
              var r2 = this.cropData(this.xData, this.yData, n2, q3);
              f3 = r2.xData;
              l2 = r2.yData;
              g2 = r2.start;
              r2 = true;
            }
          }
          for (d2 = f3.length || 1; --d2; )
            if (a3 = c2 ? b2(f3[d2]) - b2(f3[d2 - 1]) : f3[d2] - f3[d2 - 1], 0 < a3 && (typeof G2 === "undefined" || a3 < G2))
              var G2 = a3;
            else
              0 > a3 && k2 && !m2 && (D(15, false, this.chart), k2 = false);
          return { xData: f3, yData: l2, cropped: r2, cropStart: g2, closestPointRange: G2 };
        };
        a2.prototype.processData = function(b2) {
          var a3 = this.xAxis;
          if (this.isCartesian && !this.isDirty && !a3.isDirty && !this.yAxis.isDirty && !b2)
            return false;
          b2 = this.getProcessedData();
          this.cropped = b2.cropped;
          this.cropStart = b2.cropStart;
          this.processedXData = b2.xData;
          this.processedYData = b2.yData;
          this.closestPointRange = this.basePointRange = b2.closestPointRange;
          C2(this, "afterProcessData");
        };
        a2.prototype.cropData = function(b2, a3, c2, d2, e2) {
          var h3 = b2.length, g2, f3 = 0, l2 = h3;
          e2 = L(e2, this.cropShoulder);
          for (g2 = 0; g2 < h3; g2++)
            if (b2[g2] >= c2) {
              f3 = Math.max(0, g2 - e2);
              break;
            }
          for (c2 = g2; c2 < h3; c2++)
            if (b2[c2] > d2) {
              l2 = c2 + e2;
              break;
            }
          return { xData: b2.slice(f3, l2), yData: a3.slice(f3, l2), start: f3, end: l2 };
        };
        a2.prototype.generatePoints = function() {
          var b2 = this.options, a3 = this.processedData || b2.data, c2 = this.processedXData, d2 = this.processedYData, e2 = this.pointClass, h3 = c2.length, g2 = this.cropStart || 0, f3 = this.hasGroupedData, l2 = b2.keys, k2 = [];
          b2 = b2.dataGrouping && b2.dataGrouping.groupAll ? g2 : 0;
          var m2, p3, n2 = this.data;
          if (!n2 && !f3) {
            var q3 = [];
            q3.length = a3.length;
            n2 = this.data = q3;
          }
          l2 && f3 && (this.options.keys = false);
          for (p3 = 0; p3 < h3; p3++) {
            q3 = g2 + p3;
            if (f3) {
              var r2 = new e2().init(this, [c2[p3]].concat(da(d2[p3])));
              r2.dataGroup = this.groupMap[b2 + p3];
              r2.dataGroup.options && (r2.options = r2.dataGroup.options, v(r2, r2.dataGroup.options), delete r2.dataLabels);
            } else
              (r2 = n2[q3]) || typeof a3[q3] === "undefined" || (n2[q3] = r2 = new e2().init(this, a3[q3], c2[p3]));
            r2 && (r2.index = f3 ? b2 + p3 : q3, k2[p3] = r2);
          }
          this.options.keys = l2;
          if (n2 && (h3 !== (m2 = n2.length) || f3))
            for (p3 = 0; p3 < m2; p3++)
              p3 !== g2 || f3 || (p3 += h3), n2[p3] && (n2[p3].destroyElements(), n2[p3].plotX = void 0);
          this.data = n2;
          this.points = k2;
          C2(this, "afterGeneratePoints");
        };
        a2.prototype.getXExtremes = function(b2) {
          return { min: z(b2), max: x(b2) };
        };
        a2.prototype.getExtremes = function(b2, a3) {
          var c2 = this.xAxis, d2 = this.yAxis, e2 = this.processedXData || this.xData, h3 = [], g2 = this.requireSorting ? this.cropShoulder : 0;
          d2 = d2 ? d2.positiveValuesOnly : false;
          var f3, l2 = 0, k2 = 0, m2 = 0;
          b2 = b2 || this.stackedYData || this.processedYData || [];
          var p3 = b2.length;
          if (c2) {
            var n2 = c2.getExtremes();
            l2 = n2.min;
            k2 = n2.max;
          }
          for (f3 = 0; f3 < p3; f3++) {
            var q3 = e2[f3];
            n2 = b2[f3];
            var r2 = (N2(n2) || S(n2)) && (n2.length || 0 < n2 || !d2);
            q3 = a3 || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c2 || (e2[f3 + g2] || q3) >= l2 && (e2[f3 - g2] || q3) <= k2;
            if (r2 && q3)
              if (r2 = n2.length)
                for (; r2--; )
                  N2(n2[r2]) && (h3[m2++] = n2[r2]);
              else
                h3[m2++] = n2;
          }
          b2 = {
            activeYData: h3,
            dataMin: z(h3),
            dataMax: x(h3)
          };
          C2(this, "afterGetExtremes", { dataExtremes: b2 });
          return b2;
        };
        a2.prototype.applyExtremes = function() {
          var b2 = this.getExtremes();
          this.dataMin = b2.dataMin;
          this.dataMax = b2.dataMax;
          return b2;
        };
        a2.prototype.getFirstValidPoint = function(b2) {
          for (var a3 = b2.length, c2 = 0, d2 = null; d2 === null && c2 < a3; )
            d2 = b2[c2], c2++;
          return d2;
        };
        a2.prototype.translate = function() {
          this.processedXData || this.processData();
          this.generatePoints();
          var a3 = this.options, c2 = a3.stacking, d2 = this.xAxis, e2 = d2.categories, h3 = this.enabledDataSorting, g2 = this.yAxis, f3 = this.points, k2 = f3.length, p3 = this.pointPlacementToXValue(), n2 = !!p3, q3 = a3.threshold, r2 = a3.startFromThreshold ? q3 : 0, t2 = this.zoneAxis || "y", y2, z2, x2 = Number.MAX_VALUE;
          for (y2 = 0; y2 < k2; y2++) {
            var v2 = f3[y2], F2 = v2.x, u2 = void 0, D2 = void 0, w2 = v2.y, A2 = v2.low, B3 = c2 && g2.stacking && g2.stacking.stacks[(this.negStacks && w2 < (r2 ? 0 : q3) ? "-" : "") + this.stackKey];
            if (g2.positiveValuesOnly && !g2.validatePositiveValue(w2) || d2.positiveValuesOnly && !d2.validatePositiveValue(F2))
              v2.isNull = true;
            v2.plotX = z2 = b(m(d2.translate(F2, 0, 0, 0, 1, p3, this.type === "flags"), -1e5, 1e5));
            if (c2 && this.visible && B3 && B3[F2]) {
              var H3 = this.getStackIndicator(H3, F2, this.index);
              v2.isNull || (u2 = B3[F2], D2 = u2.points[H3.key]);
            }
            S(D2) && (A2 = D2[0], w2 = D2[1], A2 === r2 && H3.key === B3[F2].base && (A2 = L(N2(q3) && q3, g2.min)), g2.positiveValuesOnly && 0 >= A2 && (A2 = null), v2.total = v2.stackTotal = u2.total, v2.percentage = u2.total && v2.y / u2.total * 100, v2.stackY = w2, this.irregularWidths || u2.setOffset(this.pointXOffset || 0, this.barW || 0));
            v2.yBottom = l(A2) ? m(g2.translate(A2, 0, 1, 0, 1), -1e5, 1e5) : null;
            this.dataModify && (w2 = this.dataModify.modifyValue(w2, y2));
            v2.plotY = void 0;
            N2(w2) && (u2 = g2.translate(w2, false, true, false, true), typeof u2 !== "undefined" && (v2.plotY = m(u2, -1e5, 1e5)));
            v2.isInside = this.isPointInside(v2);
            v2.clientX = n2 ? b(d2.translate(F2, 0, 0, 0, 1, p3)) : z2;
            v2.negative = v2[t2] < (a3[t2 + "Threshold"] || q3 || 0);
            v2.category = L(e2 && e2[v2.x], v2.x);
            if (!v2.isNull && v2.visible !== false) {
              typeof I3 !== "undefined" && (x2 = Math.min(x2, Math.abs(z2 - I3)));
              var I3 = z2;
            }
            v2.zone = this.zones.length ? v2.getZone() : void 0;
            !v2.graphic && this.group && h3 && (v2.isNew = true);
          }
          this.closestPointRangePx = x2;
          C2(this, "afterTranslate");
        };
        a2.prototype.getValidPoints = function(b2, a3, c2) {
          var d2 = this.chart;
          return (b2 || this.points || []).filter(function(b3) {
            return a3 && !d2.isInsidePlot(b3.plotX, b3.plotY, { inverted: d2.inverted }) ? false : b3.visible !== false && (c2 || !b3.isNull);
          });
        };
        a2.prototype.getClipBox = function() {
          var b2 = this.chart, a3 = this.xAxis, c2 = this.yAxis, d2 = X2(b2.clipBox);
          a3 && a3.len !== b2.plotSizeX && (d2.width = a3.len);
          c2 && c2.len !== b2.plotSizeY && (d2.height = c2.len);
          return d2;
        };
        a2.prototype.getSharedClipKey = function() {
          return this.sharedClipKey = (this.options.xAxis || 0) + "," + (this.options.yAxis || 0);
        };
        a2.prototype.setClip = function() {
          var b2 = this.chart, a3 = this.group, c2 = this.markerGroup, d2 = b2.sharedClips;
          b2 = b2.renderer;
          var e2 = this.getClipBox(), h3 = this.getSharedClipKey(), g2 = d2[h3];
          g2 ? g2.animate(e2) : d2[h3] = g2 = b2.clipRect(e2);
          a3 && a3.clip(this.options.clip === false ? void 0 : g2);
          c2 && c2.clip();
        };
        a2.prototype.animate = function(b2) {
          var a3 = this.chart, c2 = this.group, d2 = this.markerGroup, e2 = a3.inverted, h3 = k(this.options.animation), g2 = [this.getSharedClipKey(), h3.duration, h3.easing, h3.defer].join(), f3 = a3.sharedClips[g2], l2 = a3.sharedClips[g2 + "m"];
          if (b2 && c2)
            h3 = this.getClipBox(), f3 ? f3.attr("height", h3.height) : (h3.width = 0, e2 && (h3.x = a3.plotHeight), f3 = a3.renderer.clipRect(h3), a3.sharedClips[g2] = f3, l2 = a3.renderer.clipRect({ x: e2 ? (a3.plotSizeX || 0) + 99 : -99, y: e2 ? -a3.plotLeft : -a3.plotTop, width: 99, height: e2 ? a3.chartWidth : a3.chartHeight }), a3.sharedClips[g2 + "m"] = l2), c2.clip(f3), d2 && d2.clip(l2);
          else if (f3 && !f3.hasClass("highcharts-animating")) {
            a3 = this.getClipBox();
            var m2 = h3.step;
            d2 && d2.element.childNodes.length && (h3.step = function(b3, a4) {
              m2 && m2.apply(a4, arguments);
              l2 && l2.element && l2.attr(a4.prop, a4.prop === "width" ? b3 + 99 : b3);
            });
            f3.addClass("highcharts-animating").animate(a3, h3);
          }
        };
        a2.prototype.afterAnimate = function() {
          var b2 = this;
          this.setClip();
          J2(this.chart.sharedClips, function(a3, c2, d2) {
            a3 && !b2.chart.container.querySelector('[clip-path="url(#' + a3.id + ')"]') && (a3.destroy(), delete d2[c2]);
          });
          this.finishedAnimating = true;
          C2(this, "afterAnimate");
        };
        a2.prototype.drawPoints = function() {
          var b2 = this.points, a3 = this.chart, c2 = this.options.marker, d2 = this[this.specialGroup] || this.markerGroup, e2 = this.xAxis, h3 = L(c2.enabled, !e2 || e2.isRadial ? true : null, this.closestPointRangePx >= c2.enabledThreshold * c2.radius), g2, f3;
          if (c2.enabled !== false || this._hasPointMarkers)
            for (g2 = 0; g2 < b2.length; g2++) {
              var l2 = b2[g2];
              var k2 = (f3 = l2.graphic) ? "animate" : "attr";
              var m2 = l2.marker || {};
              var p3 = !!l2.marker;
              if ((h3 && typeof m2.enabled === "undefined" || m2.enabled) && !l2.isNull && l2.visible !== false) {
                var n2 = L(m2.symbol, this.symbol, "rect");
                var q3 = this.markerAttribs(l2, l2.selected && "select");
                this.enabledDataSorting && (l2.startXPos = e2.reversed ? -(q3.width || 0) : e2.width);
                var r2 = l2.isInside !== false;
                f3 ? f3[r2 ? "show" : "hide"](r2).animate(q3) : r2 && (0 < (q3.width || 0) || l2.hasImage) && (l2.graphic = f3 = a3.renderer.symbol(n2, q3.x, q3.y, q3.width, q3.height, p3 ? m2 : c2).add(d2), this.enabledDataSorting && a3.hasRendered && (f3.attr({ x: l2.startXPos }), k2 = "animate"));
                f3 && k2 === "animate" && f3[r2 ? "show" : "hide"](r2).animate(q3);
                if (f3 && !a3.styledMode)
                  f3[k2](this.pointAttribs(l2, l2.selected && "select"));
                f3 && f3.addClass(l2.getClassName(), true);
              } else
                f3 && (l2.graphic = f3.destroy());
            }
        };
        a2.prototype.markerAttribs = function(b2, a3) {
          var c2 = this.options, d2 = c2.marker, e2 = b2.marker || {}, h3 = e2.symbol || d2.symbol, g2 = L(e2.radius, d2 && d2.radius);
          a3 && (d2 = d2.states[a3], a3 = e2.states && e2.states[a3], g2 = L(a3 && a3.radius, d2 && d2.radius, g2 && g2 + (d2 && d2.radiusPlus || 0)));
          b2.hasImage = h3 && h3.indexOf("url") === 0;
          b2.hasImage && (g2 = 0);
          b2 = N2(g2) ? { x: c2.crisp ? Math.floor(b2.plotX - g2) : b2.plotX - g2, y: b2.plotY - g2 } : {};
          g2 && (b2.width = b2.height = 2 * g2);
          return b2;
        };
        a2.prototype.pointAttribs = function(b2, a3) {
          var c2 = this.options.marker, d2 = b2 && b2.options, e2 = d2 && d2.marker || {}, h3 = d2 && d2.color, g2 = b2 && b2.color, f3 = b2 && b2.zone && b2.zone.color, l2 = this.color;
          b2 = L(e2.lineWidth, c2.lineWidth);
          d2 = 1;
          l2 = h3 || f3 || g2 || l2;
          h3 = e2.fillColor || c2.fillColor || l2;
          g2 = e2.lineColor || c2.lineColor || l2;
          a3 = a3 || "normal";
          c2 = c2.states[a3] || {};
          a3 = e2.states && e2.states[a3] || {};
          b2 = L(a3.lineWidth, c2.lineWidth, b2 + L(a3.lineWidthPlus, c2.lineWidthPlus, 0));
          h3 = a3.fillColor || c2.fillColor || h3;
          g2 = a3.lineColor || c2.lineColor || g2;
          d2 = L(a3.opacity, c2.opacity, d2);
          return { stroke: g2, "stroke-width": b2, fill: h3, opacity: d2 };
        };
        a2.prototype.destroy = function(b2) {
          var a3 = this, c2 = a3.chart, e2 = /AppleWebKit\/533/.test(q2.navigator.userAgent), h3 = a3.data || [], g2, f3, l2, k2;
          C2(a3, "destroy", { keepEventsForUpdate: b2 });
          this.removeEvents(b2);
          (a3.axisTypes || []).forEach(function(b3) {
            (k2 = a3[b3]) && k2.series && (d(k2.series, a3), k2.isDirty = k2.forceRedraw = true);
          });
          a3.legendItem && a3.chart.legend.destroyItem(a3);
          for (f3 = h3.length; f3--; )
            (l2 = h3[f3]) && l2.destroy && l2.destroy();
          a3.clips && a3.clips.forEach(function(b3) {
            return b3.destroy();
          });
          n.clearTimeout(a3.animationTimeout);
          J2(a3, function(b3, a4) {
            b3 instanceof u && !b3.survive && (g2 = e2 && a4 === "group" ? "hide" : "destroy", b3[g2]());
          });
          c2.hoverSeries === a3 && (c2.hoverSeries = void 0);
          d(c2.series, a3);
          c2.orderSeries();
          J2(a3, function(c3, d2) {
            b2 && d2 === "hcEvents" || delete a3[d2];
          });
        };
        a2.prototype.applyZones = function() {
          var b2 = this, a3 = this.chart, c2 = a3.renderer, d2 = this.zones, e2 = this.clips || [], h3 = this.graph, g2 = this.area, f3 = Math.max(a3.chartWidth, a3.chartHeight), l2 = this[(this.zoneAxis || "y") + "Axis"], k2 = a3.inverted, p3, n2, q3, r2, t2, y2, v2, z2, x2 = false;
          if (d2.length && (h3 || g2) && l2 && typeof l2.min !== "undefined") {
            var F2 = l2.reversed;
            var u2 = l2.horiz;
            h3 && !this.showLine && h3.hide();
            g2 && g2.hide();
            var D2 = l2.getExtremes();
            d2.forEach(function(d3, G2) {
              p3 = F2 ? u2 ? a3.plotWidth : 0 : u2 ? 0 : l2.toPixels(D2.min) || 0;
              p3 = m(L(n2, p3), 0, f3);
              n2 = m(Math.round(l2.toPixels(L(d3.value, D2.max), true) || 0), 0, f3);
              x2 && (p3 = n2 = l2.toPixels(D2.max));
              r2 = Math.abs(p3 - n2);
              t2 = Math.min(p3, n2);
              y2 = Math.max(p3, n2);
              l2.isXAxis ? (q3 = { x: k2 ? y2 : t2, y: 0, width: r2, height: f3 }, u2 || (q3.x = a3.plotHeight - q3.x)) : (q3 = {
                x: 0,
                y: k2 ? y2 : t2,
                width: f3,
                height: r2
              }, u2 && (q3.y = a3.plotWidth - q3.y));
              k2 && c2.isVML && (q3 = l2.isXAxis ? { x: 0, y: F2 ? t2 : y2, height: q3.width, width: a3.chartWidth } : { x: q3.y - a3.plotLeft - a3.spacingBox.x, y: 0, width: q3.height, height: a3.chartHeight });
              e2[G2] ? e2[G2].animate(q3) : e2[G2] = c2.clipRect(q3);
              v2 = b2["zone-area-" + G2];
              z2 = b2["zone-graph-" + G2];
              h3 && z2 && z2.clip(e2[G2]);
              g2 && v2 && v2.clip(e2[G2]);
              x2 = d3.value > D2.max;
              b2.resetZones && n2 === 0 && (n2 = void 0);
            });
            this.clips = e2;
          } else
            b2.visible && (h3 && h3.show(), g2 && g2.show());
        };
        a2.prototype.invertGroups = function(b2) {
          function a3() {
            ["group", "markerGroup"].forEach(function(a4) {
              c2[a4] && (d2.renderer.isVML && c2[a4].attr({ width: c2.yAxis.len, height: c2.xAxis.len }), c2[a4].width = c2.yAxis.len, c2[a4].height = c2.xAxis.len, c2[a4].invert(c2.isRadialSeries ? false : b2));
            });
          }
          var c2 = this, d2 = c2.chart;
          c2.xAxis && (c2.eventsToUnbind.push(y(d2, "resize", a3)), a3(), c2.invertGroups = a3);
        };
        a2.prototype.plotGroup = function(b2, a3, c2, d2, e2) {
          var h3 = this[b2], g2 = !h3;
          c2 = { visibility: c2, zIndex: d2 || 0.1 };
          typeof this.opacity === "undefined" || this.chart.styledMode || this.state === "inactive" || (c2.opacity = this.opacity);
          g2 && (this[b2] = h3 = this.chart.renderer.g().add(e2));
          h3.addClass("highcharts-" + a3 + " highcharts-series-" + this.index + " highcharts-" + this.type + "-series " + (l(this.colorIndex) ? "highcharts-color-" + this.colorIndex + " " : "") + (this.options.className || "") + (h3.hasClass("highcharts-tracker") ? " highcharts-tracker" : ""), true);
          h3.attr(c2)[g2 ? "attr" : "animate"](this.getPlotBox());
          return h3;
        };
        a2.prototype.getPlotBox = function() {
          var b2 = this.chart, a3 = this.xAxis, c2 = this.yAxis;
          b2.inverted && (a3 = c2, c2 = this.xAxis);
          return { translateX: a3 ? a3.left : b2.plotLeft, translateY: c2 ? c2.top : b2.plotTop, scaleX: 1, scaleY: 1 };
        };
        a2.prototype.removeEvents = function(b2) {
          b2 || K3(this);
          this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function(b3) {
            b3();
          }), this.eventsToUnbind.length = 0);
        };
        a2.prototype.render = function() {
          var b2 = this, a3 = b2.chart, c2 = b2.options, d2 = k(c2.animation), e2 = b2.visible ? "inherit" : "hidden", h3 = c2.zIndex, g2 = b2.hasRendered, f3 = a3.seriesGroup, l2 = a3.inverted;
          a3 = !b2.finishedAnimating && a3.renderer.isSVG ? d2.duration : 0;
          C2(this, "render");
          var m2 = b2.plotGroup("group", "series", e2, h3, f3);
          b2.markerGroup = b2.plotGroup("markerGroup", "markers", e2, h3, f3);
          c2.clip !== false && b2.setClip();
          b2.animate && a3 && b2.animate(true);
          m2.inverted = L(b2.invertible, b2.isCartesian) ? l2 : false;
          b2.drawGraph && (b2.drawGraph(), b2.applyZones());
          b2.visible && b2.drawPoints();
          b2.drawDataLabels && b2.drawDataLabels();
          b2.redrawPoints && b2.redrawPoints();
          b2.drawTracker && b2.options.enableMouseTracking !== false && b2.drawTracker();
          b2.invertGroups(l2);
          b2.animate && a3 && b2.animate();
          g2 || (a3 && d2.defer && (a3 += d2.defer), b2.animationTimeout = Q2(function() {
            b2.afterAnimate();
          }, a3 || 0));
          b2.isDirty = false;
          b2.hasRendered = true;
          C2(b2, "afterRender");
        };
        a2.prototype.redraw = function() {
          var b2 = this.chart, a3 = this.isDirty || this.isDirtyData, c2 = this.group, d2 = this.xAxis, e2 = this.yAxis;
          c2 && (b2.inverted && c2.attr({ width: b2.plotWidth, height: b2.plotHeight }), c2.animate({ translateX: L(d2 && d2.left, b2.plotLeft), translateY: L(e2 && e2.top, b2.plotTop) }));
          this.translate();
          this.render();
          a3 && delete this.kdTree;
        };
        a2.prototype.searchPoint = function(b2, a3) {
          var c2 = this.xAxis, d2 = this.yAxis, e2 = this.chart.inverted;
          return this.searchKDTree({ clientX: e2 ? c2.len - b2.chartY + c2.pos : b2.chartX - c2.pos, plotY: e2 ? d2.len - b2.chartX + d2.pos : b2.chartY - d2.pos }, a3, b2);
        };
        a2.prototype.buildKDTree = function(b2) {
          function a3(b3, d3, e2) {
            var h3 = b3 && b3.length;
            if (h3) {
              var g2 = c2.kdAxisArray[d3 % e2];
              b3.sort(function(b4, a4) {
                return b4[g2] - a4[g2];
              });
              h3 = Math.floor(h3 / 2);
              return { point: b3[h3], left: a3(b3.slice(0, h3), d3 + 1, e2), right: a3(b3.slice(h3 + 1), d3 + 1, e2) };
            }
          }
          this.buildingKdTree = true;
          var c2 = this, d2 = -1 < c2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
          delete c2.kdTree;
          Q2(function() {
            c2.kdTree = a3(c2.getValidPoints(null, !c2.directTouch), d2, d2);
            c2.buildingKdTree = false;
          }, c2.options.kdNow || b2 && b2.type === "touchstart" ? 0 : 1);
        };
        a2.prototype.searchKDTree = function(b2, a3, c2) {
          function d2(b3, a4, c3, k2) {
            var m2 = a4.point, p3 = e2.kdAxisArray[c3 % k2], n2 = m2, q3 = l(b3[h3]) && l(m2[h3]) ? Math.pow(b3[h3] - m2[h3], 2) : null;
            var r2 = l(b3[g2]) && l(m2[g2]) ? Math.pow(b3[g2] - m2[g2], 2) : null;
            r2 = (q3 || 0) + (r2 || 0);
            m2.dist = l(r2) ? Math.sqrt(r2) : Number.MAX_VALUE;
            m2.distX = l(q3) ? Math.sqrt(q3) : Number.MAX_VALUE;
            p3 = b3[p3] - m2[p3];
            r2 = 0 > p3 ? "left" : "right";
            q3 = 0 > p3 ? "right" : "left";
            a4[r2] && (r2 = d2(b3, a4[r2], c3 + 1, k2), n2 = r2[f3] < n2[f3] ? r2 : m2);
            a4[q3] && Math.sqrt(p3 * p3) < n2[f3] && (b3 = d2(b3, a4[q3], c3 + 1, k2), n2 = b3[f3] < n2[f3] ? b3 : n2);
            return n2;
          }
          var e2 = this, h3 = this.kdAxisArray[0], g2 = this.kdAxisArray[1], f3 = a3 ? "distX" : "dist";
          a3 = -1 < e2.options.findNearestPointBy.indexOf("y") ? 2 : 1;
          this.kdTree || this.buildingKdTree || this.buildKDTree(c2);
          if (this.kdTree)
            return d2(b2, this.kdTree, a3, a3);
        };
        a2.prototype.pointPlacementToXValue = function() {
          var b2 = this.options, a3 = b2.pointRange, c2 = this.xAxis;
          b2 = b2.pointPlacement;
          b2 === "between" && (b2 = c2.reversed ? -0.5 : 0.5);
          return N2(b2) ? b2 * (a3 || c2.pointRange) : 0;
        };
        a2.prototype.isPointInside = function(b2) {
          var a3 = this.chart, c2 = this.xAxis, d2 = this.yAxis;
          return typeof b2.plotY !== "undefined" && typeof b2.plotX !== "undefined" && 0 <= b2.plotY && b2.plotY <= (d2 ? d2.len : a3.plotHeight) && 0 <= b2.plotX && b2.plotX <= (c2 ? c2.len : a3.plotWidth);
        };
        a2.prototype.drawTracker = function() {
          var b2 = this, a3 = b2.options, c2 = a3.trackByArea, d2 = [].concat(c2 ? b2.areaPath : b2.graphPath), e2 = b2.chart, h3 = e2.pointer, f3 = e2.renderer, l2 = e2.options.tooltip.snap, k2 = b2.tracker, m2 = function(a4) {
            if (e2.hoverSeries !== b2)
              b2.onMouseOver();
          }, p3 = "rgba(192,192,192," + (t ? 1e-4 : 2e-3) + ")";
          k2 ? k2.attr({ d: d2 }) : b2.graph && (b2.tracker = f3.path(d2).attr({ visibility: b2.visible ? "inherit" : "hidden", zIndex: 2 }).addClass(c2 ? "highcharts-tracker-area" : "highcharts-tracker-line").add(b2.group), e2.styledMode || b2.tracker.attr({
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            stroke: p3,
            fill: c2 ? p3 : "none",
            "stroke-width": b2.graph.strokeWidth() + (c2 ? 0 : 2 * l2)
          }), [b2.tracker, b2.markerGroup, b2.dataLabelsGroup].forEach(function(b3) {
            if (b3 && (b3.addClass("highcharts-tracker").on("mouseover", m2).on("mouseout", function(b4) {
              h3.onTrackerMouseOut(b4);
            }), a3.cursor && !e2.styledMode && b3.css({ cursor: a3.cursor }), g))
              b3.on("touchstart", m2);
          }));
          C2(this, "afterDrawTracker");
        };
        a2.prototype.addPoint = function(b2, a3, c2, d2, e2) {
          var h3 = this.options, g2 = this.data, f3 = this.chart, l2 = this.xAxis;
          l2 = l2 && l2.hasNames && l2.names;
          var k2 = h3.data, m2 = this.xData, p3;
          a3 = L(a3, true);
          var n2 = { series: this };
          this.pointClass.prototype.applyOptions.apply(n2, [b2]);
          var q3 = n2.x;
          var r2 = m2.length;
          if (this.requireSorting && q3 < m2[r2 - 1])
            for (p3 = true; r2 && m2[r2 - 1] > q3; )
              r2--;
          this.updateParallelArrays(n2, "splice", r2, 0, 0);
          this.updateParallelArrays(n2, r2);
          l2 && n2.name && (l2[q3] = n2.name);
          k2.splice(r2, 0, b2);
          if (p3 || this.processedData)
            this.data.splice(r2, 0, null), this.processData();
          h3.legendType === "point" && this.generatePoints();
          c2 && (g2[0] && g2[0].remove ? g2[0].remove(false) : (g2.shift(), this.updateParallelArrays(n2, "shift"), k2.shift()));
          e2 !== false && C2(this, "addPoint", { point: n2 });
          this.isDirtyData = this.isDirty = true;
          a3 && f3.redraw(d2);
        };
        a2.prototype.removePoint = function(b2, a3, c2) {
          var d2 = this, h3 = d2.data, g2 = h3[b2], f3 = d2.points, l2 = d2.chart, k2 = function() {
            f3 && f3.length === h3.length && f3.splice(b2, 1);
            h3.splice(b2, 1);
            d2.options.data.splice(b2, 1);
            d2.updateParallelArrays(g2 || { series: d2 }, "splice", b2, 1);
            g2 && g2.destroy();
            d2.isDirty = true;
            d2.isDirtyData = true;
            a3 && l2.redraw();
          };
          e(c2, l2);
          a3 = L(a3, true);
          g2 ? g2.firePointEvent("remove", null, k2) : k2();
        };
        a2.prototype.remove = function(b2, a3, c2, d2) {
          function e2() {
            h3.destroy(d2);
            g2.isDirtyLegend = g2.isDirtyBox = true;
            g2.linkSeries();
            L(b2, true) && g2.redraw(a3);
          }
          var h3 = this, g2 = h3.chart;
          c2 !== false ? C2(h3, "remove", null, e2) : e2();
        };
        a2.prototype.update = function(b2, a3) {
          b2 = h2(b2, this.userOptions);
          C2(this, "update", { options: b2 });
          var c2 = this, d2 = c2.chart, e2 = c2.userOptions, g2 = c2.initialType || c2.type, f3 = d2.options.plotOptions, l2 = F[g2].prototype, k2 = c2.finishedAnimating && { animation: false }, m2 = {}, p3, n2 = ["eventOptions", "navigatorSeries", "baseSeries"], q3 = b2.type || e2.type || d2.options.chart.type, r2 = !(this.hasDerivedData || q3 && q3 !== this.type || typeof b2.pointStart !== "undefined" || typeof b2.pointInterval !== "undefined" || typeof b2.relativeXValue !== "undefined" || b2.joinBy || b2.mapData || c2.hasOptionChanged("dataGrouping") || c2.hasOptionChanged("pointStart") || c2.hasOptionChanged("pointInterval") || c2.hasOptionChanged("pointIntervalUnit") || c2.hasOptionChanged("keys"));
          q3 = q3 || g2;
          r2 && (n2.push("data", "isDirtyData", "points", "processedData", "processedXData", "processedYData", "xIncrement", "cropped", "_hasPointMarkers", "_hasPointLabels", "clips", "nodes", "layout", "level", "mapMap", "mapData", "minY", "maxY", "minX", "maxX"), b2.visible !== false && n2.push("area", "graph"), c2.parallelArrays.forEach(function(b3) {
            n2.push(b3 + "Data");
          }), b2.data && (b2.dataSorting && v(c2.options.dataSorting, b2.dataSorting), this.setData(b2.data, false)));
          b2 = X2(e2, k2, { index: typeof e2.index === "undefined" ? c2.index : e2.index, pointStart: L(f3 && f3.series && f3.series.pointStart, e2.pointStart, c2.xData[0]) }, !r2 && { data: c2.options.data }, b2);
          r2 && b2.data && (b2.data = c2.options.data);
          n2 = ["group", "markerGroup", "dataLabelsGroup", "transformGroup"].concat(n2);
          n2.forEach(function(b3) {
            n2[b3] = c2[b3];
            delete c2[b3];
          });
          f3 = false;
          if (F[q3]) {
            if (f3 = q3 !== c2.type, c2.remove(false, false, false, true), f3)
              if (Object.setPrototypeOf)
                Object.setPrototypeOf(c2, F[q3].prototype);
              else {
                k2 = Object.hasOwnProperty.call(c2, "hcEvents") && c2.hcEvents;
                for (p3 in l2)
                  c2[p3] = void 0;
                v(c2, F[q3].prototype);
                k2 ? c2.hcEvents = k2 : delete c2.hcEvents;
              }
          } else
            D(17, true, d2, { missingModuleFor: q3 });
          n2.forEach(function(b3) {
            c2[b3] = n2[b3];
          });
          c2.init(d2, b2);
          if (r2 && this.points) {
            var t2 = c2.options;
            t2.visible === false ? (m2.graphic = 1, m2.dataLabel = 1) : c2._hasPointLabels || (b2 = t2.marker, l2 = t2.dataLabels, !b2 || b2.enabled !== false && (e2.marker && e2.marker.symbol) === b2.symbol || (m2.graphic = 1), l2 && l2.enabled === false && (m2.dataLabel = 1));
            this.points.forEach(function(b3) {
              b3 && b3.series && (b3.resolveColor(), Object.keys(m2).length && b3.destroyElements(m2), t2.showInLegend === false && b3.legendItem && d2.legend.destroyItem(b3));
            }, this);
          }
          c2.initialType = g2;
          d2.linkSeries();
          f3 && c2.linkedSeries.length && (c2.isDirtyData = true);
          C2(this, "afterUpdate");
          L(a3, true) && d2.redraw(r2 ? void 0 : false);
        };
        a2.prototype.setName = function(b2) {
          this.name = this.options.name = this.userOptions.name = b2;
          this.chart.isDirtyLegend = true;
        };
        a2.prototype.hasOptionChanged = function(b2) {
          var a3 = this.options[b2], c2 = this.chart.options.plotOptions, d2 = this.userOptions[b2];
          return d2 ? a3 !== d2 : a3 !== L(c2 && c2[this.type] && c2[this.type][b2], c2 && c2.series && c2.series[b2], a3);
        };
        a2.prototype.onMouseOver = function() {
          var b2 = this.chart, a3 = b2.hoverSeries;
          b2.pointer.setHoverChartIndex();
          if (a3 && a3 !== this)
            a3.onMouseOut();
          this.options.events.mouseOver && C2(this, "mouseOver");
          this.setState("hover");
          b2.hoverSeries = this;
        };
        a2.prototype.onMouseOut = function() {
          var b2 = this.options, a3 = this.chart, c2 = a3.tooltip, d2 = a3.hoverPoint;
          a3.hoverSeries = null;
          if (d2)
            d2.onMouseOut();
          this && b2.events.mouseOut && C2(this, "mouseOut");
          !c2 || this.stickyTracking || c2.shared && !this.noSharedTooltip || c2.hide();
          a3.series.forEach(function(b3) {
            b3.setState("", true);
          });
        };
        a2.prototype.setState = function(b2, a3) {
          var c2 = this, d2 = c2.options, e2 = c2.graph, h3 = d2.inactiveOtherPoints, g2 = d2.states, f3 = L(g2[b2 || "normal"] && g2[b2 || "normal"].animation, c2.chart.options.chart.animation), l2 = d2.lineWidth, k2 = 0, m2 = d2.opacity;
          b2 = b2 || "";
          if (c2.state !== b2 && ([c2.group, c2.markerGroup, c2.dataLabelsGroup].forEach(function(a4) {
            a4 && (c2.state && a4.removeClass("highcharts-series-" + c2.state), b2 && a4.addClass("highcharts-series-" + b2));
          }), c2.state = b2, !c2.chart.styledMode)) {
            if (g2[b2] && g2[b2].enabled === false)
              return;
            b2 && (l2 = g2[b2].lineWidth || l2 + (g2[b2].lineWidthPlus || 0), m2 = L(g2[b2].opacity, m2));
            if (e2 && !e2.dashstyle)
              for (d2 = { "stroke-width": l2 }, e2.animate(d2, f3); c2["zone-graph-" + k2]; )
                c2["zone-graph-" + k2].animate(d2, f3), k2 += 1;
            h3 || [c2.group, c2.markerGroup, c2.dataLabelsGroup, c2.labelBySeries].forEach(function(b3) {
              b3 && b3.animate({ opacity: m2 }, f3);
            });
          }
          a3 && h3 && c2.points && c2.setAllPointsToState(b2 || void 0);
        };
        a2.prototype.setAllPointsToState = function(b2) {
          this.points.forEach(function(a3) {
            a3.setState && a3.setState(b2);
          });
        };
        a2.prototype.setVisible = function(b2, a3) {
          var c2 = this, d2 = c2.chart, e2 = c2.legendItem, h3 = d2.options.chart.ignoreHiddenSeries, g2 = c2.visible, f3 = (c2.visible = b2 = c2.options.visible = c2.userOptions.visible = typeof b2 === "undefined" ? !g2 : b2) ? "show" : "hide";
          ["group", "dataLabelsGroup", "markerGroup", "tracker", "tt"].forEach(function(b3) {
            if (c2[b3])
              c2[b3][f3]();
          });
          if (d2.hoverSeries === c2 || (d2.hoverPoint && d2.hoverPoint.series) === c2)
            c2.onMouseOut();
          e2 && d2.legend.colorizeItem(c2, b2);
          c2.isDirty = true;
          c2.options.stacking && d2.series.forEach(function(b3) {
            b3.options.stacking && b3.visible && (b3.isDirty = true);
          });
          c2.linkedSeries.forEach(function(a4) {
            a4.setVisible(b2, false);
          });
          h3 && (d2.isDirtyBox = true);
          C2(c2, f3);
          a3 !== false && d2.redraw();
        };
        a2.prototype.show = function() {
          this.setVisible(true);
        };
        a2.prototype.hide = function() {
          this.setVisible(false);
        };
        a2.prototype.select = function(b2) {
          this.selected = b2 = this.options.selected = typeof b2 === "undefined" ? !this.selected : b2;
          this.checkbox && (this.checkbox.checked = b2);
          C2(this, b2 ? "select" : "unselect");
        };
        a2.prototype.shouldShowTooltip = function(b2, a3, c2) {
          c2 === void 0 && (c2 = {});
          c2.series = this;
          c2.visiblePlotOnly = true;
          return this.chart.isInsidePlot(b2, a3, c2);
        };
        a2.defaultOptions = I2;
        return a2;
      }();
      v(a.prototype, { axisTypes: ["xAxis", "yAxis"], coll: "series", colorCounter: 0, cropShoulder: 1, directTouch: false, drawLegendSymbol: w.drawLineMarker, isCartesian: true, kdAxisArray: ["clientX", "plotY"], parallelArrays: ["x", "y"], pointClass: E2, requireSorting: true, sorted: true });
      A.series = a;
      return a;
    });
    K2(f, "Extensions/ScrollablePlotArea.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/Axis.js"], f["Core/Chart/Chart.js"], f["Core/Series/Series.js"], f["Core/Renderer/RendererRegistry.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2, w, E2) {
      var C2 = a.stop, A = E2.addEvent, u = E2.createElement, n = E2.merge, k = E2.pick;
      A(B2, "afterSetChartSize", function(a2) {
        var c = this.options.chart.scrollablePlotArea, e = c && c.minWidth;
        c = c && c.minHeight;
        if (!this.renderer.forExport) {
          if (e) {
            if (this.scrollablePixelsX = e = Math.max(0, e - this.chartWidth)) {
              this.scrollablePlotBox = this.renderer.scrollablePlotBox = n(this.plotBox);
              this.plotBox.width = this.plotWidth += e;
              this.inverted ? this.clipBox.height += e : this.clipBox.width += e;
              var g = { 1: { name: "right", value: e } };
            }
          } else
            c && (this.scrollablePixelsY = e = Math.max(0, c - this.chartHeight)) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = n(this.plotBox), this.plotBox.height = this.plotHeight += e, this.inverted ? this.clipBox.width += e : this.clipBox.height += e, g = { 2: { name: "bottom", value: e } });
          g && !a2.skipAxes && this.axes.forEach(function(a3) {
            g[a3.side] ? a3.getPlotLinePath = function() {
              var c2 = g[a3.side].name, e2 = this[c2];
              this[c2] = e2 - g[a3.side].value;
              var k2 = f2.prototype.getPlotLinePath.apply(this, arguments);
              this[c2] = e2;
              return k2;
            } : (a3.setAxisSize(), a3.setAxisTranslation());
          });
        }
      });
      A(B2, "render", function() {
        this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();
      });
      B2.prototype.setUpScrolling = function() {
        var a2 = this, c = { WebkitOverflowScrolling: "touch", overflowX: "hidden", overflowY: "hidden" };
        this.scrollablePixelsX && (c.overflowX = "auto");
        this.scrollablePixelsY && (c.overflowY = "auto");
        this.scrollingParent = u("div", { className: "highcharts-scrolling-parent" }, { position: "relative" }, this.renderTo);
        this.scrollingContainer = u("div", { className: "highcharts-scrolling" }, c, this.scrollingParent);
        A(this.scrollingContainer, "scroll", function() {
          a2.pointer && delete a2.pointer.chartPosition;
        });
        this.innerContainer = u("div", { className: "highcharts-inner-container" }, null, this.scrollingContainer);
        this.innerContainer.appendChild(this.container);
        this.setUpScrolling = null;
      };
      B2.prototype.moveFixedElements = function() {
        var a2 = this.container, c = this.fixedRenderer, f3 = ".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title".split(" "), g;
        this.scrollablePixelsX && !this.inverted ? g = ".highcharts-yaxis" : this.scrollablePixelsX && this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && !this.inverted ? g = ".highcharts-xaxis" : this.scrollablePixelsY && this.inverted && (g = ".highcharts-yaxis");
        g && f3.push(g + ":not(.highcharts-radial-axis)", g + "-labels:not(.highcharts-radial-axis-labels)");
        f3.forEach(function(e) {
          [].forEach.call(a2.querySelectorAll(e), function(a3) {
            (a3.namespaceURI === c.SVG_NS ? c.box : c.box.parentNode).appendChild(a3);
            a3.style.pointerEvents = "auto";
          });
        });
      };
      B2.prototype.applyFixed = function() {
        var a2 = !this.fixedDiv, c = this.options.chart, f3 = c.scrollablePlotArea, g = w.getRendererType();
        a2 ? (this.fixedDiv = u("div", { className: "highcharts-fixed" }, { position: "absolute", overflow: "hidden", pointerEvents: "none", zIndex: (c.style && c.style.zIndex || 0) + 2, top: 0 }, null, true), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = "visible", this.fixedRenderer = c = new g(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = c.path().attr({ fill: this.options.chart.backgroundColor || "#fff", "fill-opacity": k(f3.opacity, 0.85), zIndex: -1 }).addClass("highcharts-scrollable-mask").add(), A(this, "afterShowResetZoom", this.moveFixedElements), A(this, "afterApplyDrilldown", this.moveFixedElements), A(this, "afterLayOutTitles", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);
        if (this.scrollableDirty || a2)
          this.scrollableDirty = false, this.moveFixedElements();
        c = this.chartWidth + (this.scrollablePixelsX || 0);
        g = this.chartHeight + (this.scrollablePixelsY || 0);
        C2(this.container);
        this.container.style.width = c + "px";
        this.container.style.height = g + "px";
        this.renderer.boxWrapper.attr({ width: c, height: g, viewBox: [0, 0, c, g].join(" ") });
        this.chartBackground.attr({ width: c, height: g });
        this.scrollingContainer.style.height = this.chartHeight + "px";
        a2 && (f3.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * f3.scrollPositionX), f3.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * f3.scrollPositionY));
        g = this.axisOffset;
        a2 = this.plotTop - g[0] - 1;
        f3 = this.plotLeft - g[3] - 1;
        c = this.plotTop + this.plotHeight + g[2] + 1;
        g = this.plotLeft + this.plotWidth + g[1] + 1;
        var n2 = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0), q2 = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);
        a2 = this.scrollablePixelsX ? [["M", 0, a2], ["L", this.plotLeft - 1, a2], ["L", this.plotLeft - 1, c], ["L", 0, c], ["Z"], ["M", n2, a2], ["L", this.chartWidth, a2], ["L", this.chartWidth, c], ["L", n2, c], ["Z"]] : this.scrollablePixelsY ? [
          ["M", f3, 0],
          ["L", f3, this.plotTop - 1],
          ["L", g, this.plotTop - 1],
          ["L", g, 0],
          ["Z"],
          ["M", f3, q2],
          ["L", f3, this.chartHeight],
          ["L", g, this.chartHeight],
          ["L", g, q2],
          ["Z"]
        ] : [["M", 0, 0]];
        this.redrawTrigger !== "adjustHeight" && this.scrollableMask.attr({ d: a2 });
      };
      A(f2, "afterInit", function() {
        this.chart.scrollableDirty = true;
      });
      A(H2, "show", function() {
        this.chart.scrollableDirty = true;
      });
    });
    K2(f, "Core/Axis/StackingAxis.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Axis/Axis.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = a.getDeferredAnimation, w = B2.addEvent, E2 = B2.destroyObjectProperties, I2 = B2.fireEvent, A = B2.isNumber, u = B2.objectEach, n;
      (function(a2) {
        function e() {
          var a3 = this.stacking;
          if (a3) {
            var c2 = a3.stacks;
            u(c2, function(a4, e2) {
              E2(a4);
              c2[e2] = null;
            });
            a3 && a3.stackTotalGroup && a3.stackTotalGroup.destroy();
          }
        }
        function c() {
          this.stacking || (this.stacking = new g(this));
        }
        var f3 = [];
        a2.compose = function(a3) {
          f3.indexOf(a3) === -1 && (f3.push(a3), w(a3, "init", c), w(a3, "destroy", e));
          return a3;
        };
        var g = function() {
          function a3(a4) {
            this.oldStacks = {};
            this.stacks = {};
            this.stacksTouched = 0;
            this.axis = a4;
          }
          a3.prototype.buildStacks = function() {
            var a4 = this.axis, c2 = a4.series, e2 = a4.options.reversedStacks, g2 = c2.length, f4;
            if (!a4.isXAxis) {
              this.usePercentage = false;
              for (f4 = g2; f4--; ) {
                var k = c2[e2 ? f4 : g2 - f4 - 1];
                k.setStackedPoints();
                k.setGroupedPoints();
              }
              for (f4 = 0; f4 < g2; f4++)
                c2[f4].modifyStacks();
              I2(a4, "afterBuildStacks");
            }
          };
          a3.prototype.cleanStacks = function() {
            if (!this.axis.isXAxis) {
              if (this.oldStacks)
                var a4 = this.stacks = this.oldStacks;
              u(a4, function(a5) {
                u(a5, function(a6) {
                  a6.cumulative = a6.total;
                });
              });
            }
          };
          a3.prototype.resetStacks = function() {
            var a4 = this, c2 = a4.stacks;
            a4.axis.isXAxis || u(c2, function(c3) {
              u(c3, function(e2, g2) {
                A(e2.touched) && e2.touched < a4.stacksTouched ? (e2.destroy(), delete c3[g2]) : (e2.total = null, e2.cumulative = null);
              });
            });
          };
          a3.prototype.renderStackTotals = function() {
            var a4 = this.axis, c2 = a4.chart, e2 = c2.renderer, g2 = this.stacks;
            a4 = C2(c2, a4.options.stackLabels && a4.options.stackLabels.animation || false);
            var f4 = this.stackTotalGroup = this.stackTotalGroup || e2.g("stack-labels").attr({ zIndex: 6, opacity: 0 }).add();
            f4.translate(c2.plotLeft, c2.plotTop);
            u(g2, function(a5) {
              u(a5, function(a6) {
                a6.render(f4);
              });
            });
            f4.animate({ opacity: 1 }, a4);
          };
          return a3;
        }();
        a2.Additions = g;
      })(n || (n = {}));
      return n;
    });
    K2(f, "Extensions/Stacking.js", [
      f["Core/Axis/Axis.js"],
      f["Core/Chart/Chart.js"],
      f["Core/FormatUtilities.js"],
      f["Core/Globals.js"],
      f["Core/Series/Series.js"],
      f["Core/Axis/StackingAxis.js"],
      f["Core/Utilities.js"]
    ], function(a, f2, B2, H2, w, E2, I2) {
      var A = B2.format, u = I2.correctFloat, n = I2.defined, k = I2.destroyObjectProperties, e = I2.isArray, c = I2.isNumber, p2 = I2.objectEach, g = I2.pick, t = function() {
        function a2(a3, c2, e2, g2, f3) {
          var h2 = a3.chart.inverted;
          this.axis = a3;
          this.isNegative = e2;
          this.options = c2 = c2 || {};
          this.x = g2;
          this.total = null;
          this.points = {};
          this.hasValidPoints = false;
          this.stack = f3;
          this.rightCliff = this.leftCliff = 0;
          this.alignOptions = { align: c2.align || (h2 ? e2 ? "left" : "right" : "center"), verticalAlign: c2.verticalAlign || (h2 ? "middle" : e2 ? "bottom" : "top"), y: c2.y, x: c2.x };
          this.textAlign = c2.textAlign || (h2 ? e2 ? "right" : "left" : "center");
        }
        a2.prototype.destroy = function() {
          k(this, this.axis);
        };
        a2.prototype.render = function(a3) {
          var c2 = this.axis.chart, e2 = this.options, f3 = e2.format;
          f3 = f3 ? A(f3, this, c2) : e2.formatter.call(this);
          this.label ? this.label.attr({ text: f3, visibility: "hidden" }) : (this.label = c2.renderer.label(f3, null, null, e2.shape, null, null, e2.useHTML, false, "stack-labels"), f3 = { r: e2.borderRadius || 0, text: f3, rotation: e2.rotation, padding: g(e2.padding, 5), visibility: "hidden" }, c2.styledMode || (f3.fill = e2.backgroundColor, f3.stroke = e2.borderColor, f3["stroke-width"] = e2.borderWidth, this.label.css(e2.style)), this.label.attr(f3), this.label.added || this.label.add(a3));
          this.label.labelrank = c2.plotSizeY;
        };
        a2.prototype.setOffset = function(a3, e2, f3, k2, m) {
          var h2 = this.axis, b = h2.chart;
          k2 = h2.translate(h2.stacking.usePercentage ? 100 : k2 ? k2 : this.total, 0, 0, 0, 1);
          f3 = h2.translate(f3 ? f3 : 0);
          f3 = n(k2) && Math.abs(k2 - f3);
          a3 = g(m, b.xAxis[0].translate(this.x)) + a3;
          h2 = n(k2) && this.getStackBox(b, this, a3, k2, e2, f3, h2);
          e2 = this.label;
          f3 = this.isNegative;
          a3 = g(this.options.overflow, "justify") === "justify";
          var l = this.textAlign;
          e2 && h2 && (m = e2.getBBox(), k2 = e2.padding, l = l === "left" ? b.inverted ? -k2 : k2 : l === "right" ? m.width : b.inverted && l === "center" ? m.width / 2 : b.inverted ? f3 ? m.width + k2 : -k2 : m.width / 2, f3 = b.inverted ? m.height / 2 : f3 ? -k2 : m.height, this.alignOptions.x = g(this.options.x, 0), this.alignOptions.y = g(this.options.y, 0), h2.x -= l, h2.y -= f3, e2.align(this.alignOptions, null, h2), b.isInsidePlot(e2.alignAttr.x + l - this.alignOptions.x, e2.alignAttr.y + f3 - this.alignOptions.y) ? e2.show() : (e2.hide(), a3 = false), a3 && w.prototype.justifyDataLabel.call(this.axis, e2, this.alignOptions, e2.alignAttr, m, h2), e2.attr({ x: e2.alignAttr.x, y: e2.alignAttr.y }), g(!a3 && this.options.crop, true) && ((b = c(e2.x) && c(e2.y) && b.isInsidePlot(e2.x - k2 + e2.width, e2.y) && b.isInsidePlot(e2.x + k2, e2.y)) || e2.hide()));
        };
        a2.prototype.getStackBox = function(a3, c2, e2, g2, f3, h2, b) {
          var l = c2.axis.reversed, d = a3.inverted, k2 = b.height + b.pos - (d ? a3.plotLeft : a3.plotTop);
          c2 = c2.isNegative && !l || !c2.isNegative && l;
          return { x: d ? c2 ? g2 - b.right : g2 - h2 + b.pos - a3.plotLeft : e2 + a3.xAxis[0].transB - a3.plotLeft, y: d ? b.height - e2 - f3 : c2 ? k2 - g2 - h2 : k2 - g2, width: d ? h2 : f3, height: d ? f3 : h2 };
        };
        return a2;
      }();
      f2.prototype.getStacks = function() {
        var a2 = this, c2 = a2.inverted;
        a2.yAxis.forEach(function(a3) {
          a3.stacking && a3.stacking.stacks && a3.hasVisibleSeries && (a3.stacking.oldStacks = a3.stacking.stacks);
        });
        a2.series.forEach(function(e2) {
          var f3 = e2.xAxis && e2.xAxis.options || {};
          !e2.options.stacking || e2.visible !== true && a2.options.chart.ignoreHiddenSeries !== false || (e2.stackKey = [e2.type, g(e2.options.stack, ""), c2 ? f3.top : f3.left, c2 ? f3.height : f3.width].join());
        });
      };
      E2.compose(a);
      w.prototype.setGroupedPoints = function() {
        var a2 = this.yAxis.stacking;
        this.options.centerInCategory && (this.is("column") || this.is("columnrange")) && !this.options.stacking && 1 < this.chart.series.length ? w.prototype.setStackedPoints.call(this, "group") : a2 && p2(a2.stacks, function(c2, e2) {
          e2.slice(-5) === "group" && (p2(c2, function(a3) {
            return a3.destroy();
          }), delete a2.stacks[e2]);
        });
      };
      w.prototype.setStackedPoints = function(a2) {
        var c2 = a2 || this.options.stacking;
        if (c2 && (this.visible === true || this.chart.options.chart.ignoreHiddenSeries === false)) {
          var f3 = this.processedXData, k2 = this.processedYData, p3 = [], m = k2.length, h2 = this.options, b = h2.threshold, l = g(h2.startFromThreshold && b, 0);
          h2 = h2.stack;
          a2 = a2 ? this.type + "," + c2 : this.stackKey;
          var d = "-" + a2, q2 = this.negStacks, v = this.yAxis, r = v.stacking.stacks, w2 = v.stacking.oldStacks, A2, C2;
          v.stacking.stacksTouched += 1;
          for (C2 = 0; C2 < m; C2++) {
            var B3 = f3[C2];
            var H3 = k2[C2];
            var I3 = this.getStackIndicator(I3, B3, this.index);
            var J2 = I3.key;
            var E3 = (A2 = q2 && H3 < (l ? 0 : b)) ? d : a2;
            r[E3] || (r[E3] = {});
            r[E3][B3] || (w2[E3] && w2[E3][B3] ? (r[E3][B3] = w2[E3][B3], r[E3][B3].total = null) : r[E3][B3] = new t(v, v.options.stackLabels, A2, B3, h2));
            E3 = r[E3][B3];
            H3 !== null ? (E3.points[J2] = E3.points[this.index] = [g(E3.cumulative, l)], n(E3.cumulative) || (E3.base = J2), E3.touched = v.stacking.stacksTouched, 0 < I3.index && this.singleStacks === false && (E3.points[J2][0] = E3.points[this.index + "," + B3 + ",0"][0])) : E3.points[J2] = E3.points[this.index] = null;
            c2 === "percent" ? (A2 = A2 ? a2 : d, q2 && r[A2] && r[A2][B3] ? (A2 = r[A2][B3], E3.total = A2.total = Math.max(A2.total, E3.total) + Math.abs(H3) || 0) : E3.total = u(E3.total + (Math.abs(H3) || 0))) : c2 === "group" ? (e(H3) && (H3 = H3[0]), H3 !== null && (E3.total = (E3.total || 0) + 1)) : E3.total = u(E3.total + (H3 || 0));
            E3.cumulative = c2 === "group" ? (E3.total || 1) - 1 : g(E3.cumulative, l) + (H3 || 0);
            H3 !== null && (E3.points[J2].push(E3.cumulative), p3[C2] = E3.cumulative, E3.hasValidPoints = true);
          }
          c2 === "percent" && (v.stacking.usePercentage = true);
          c2 !== "group" && (this.stackedYData = p3);
          v.stacking.oldStacks = {};
        }
      };
      w.prototype.modifyStacks = function() {
        var a2 = this, c2 = a2.stackKey, e2 = a2.yAxis.stacking.stacks, g2 = a2.processedXData, f3, k2 = a2.options.stacking;
        a2[k2 + "Stacker"] && [c2, "-" + c2].forEach(function(c3) {
          for (var b = g2.length, h2, d; b--; )
            if (h2 = g2[b], f3 = a2.getStackIndicator(f3, h2, a2.index, c3), d = (h2 = e2[c3] && e2[c3][h2]) && h2.points[f3.key])
              a2[k2 + "Stacker"](d, h2, b);
        });
      };
      w.prototype.percentStacker = function(a2, c2, e2) {
        c2 = c2.total ? 100 / c2.total : 0;
        a2[0] = u(a2[0] * c2);
        a2[1] = u(a2[1] * c2);
        this.stackedYData[e2] = a2[1];
      };
      w.prototype.getStackIndicator = function(a2, c2, e2, g2) {
        !n(a2) || a2.x !== c2 || g2 && a2.stackKey !== g2 ? a2 = { x: c2, index: 0, key: g2, stackKey: g2 } : a2.index++;
        a2.key = [e2, c2, a2.index].join();
        return a2;
      };
      H2.StackItem = t;
      return H2.StackItem;
    });
    K2(f, "Series/Line/LineSeries.js", [f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = this && this.__extends || function() {
        var a2 = function(f3, u) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, f4) {
            a3.__proto__ = f4;
          } || function(a3, f4) {
            for (var e in f4)
              f4.hasOwnProperty(e) && (a3[e] = f4[e]);
          };
          return a2(f3, u);
        };
        return function(f3, u) {
          function n() {
            this.constructor = f3;
          }
          a2(f3, u);
          f3.prototype = u === null ? Object.create(u) : (n.prototype = u.prototype, new n());
        };
      }(), w = B2.defined, E2 = B2.merge;
      B2 = function(f3) {
        function A() {
          var a2 = f3 !== null && f3.apply(this, arguments) || this;
          a2.data = void 0;
          a2.options = void 0;
          a2.points = void 0;
          return a2;
        }
        C2(A, f3);
        A.prototype.drawGraph = function() {
          var a2 = this, f4 = this.options, k = (this.gappedPath || this.getGraphPath).call(this), e = this.chart.styledMode, c = [["graph", "highcharts-graph"]];
          e || c[0].push(f4.lineColor || this.color || "#cccccc", f4.dashStyle);
          c = a2.getZonesGraphs(c);
          c.forEach(function(c2, g) {
            var p2 = c2[0], n = a2[p2], u = n ? "animate" : "attr";
            n ? (n.endX = a2.preventGraphAnimation ? null : k.xMap, n.animate({ d: k })) : k.length && (a2[p2] = n = a2.chart.renderer.path(k).addClass(c2[1]).attr({ zIndex: 1 }).add(a2.group));
            n && !e && (p2 = {
              stroke: c2[2],
              "stroke-width": f4.lineWidth,
              fill: a2.fillGraph && a2.color || "none"
            }, c2[3] ? p2.dashstyle = c2[3] : f4.linecap !== "square" && (p2["stroke-linecap"] = p2["stroke-linejoin"] = "round"), n[u](p2).shadow(2 > g && f4.shadow));
            n && (n.startX = k.xMap, n.isArea = k.isArea);
          });
        };
        A.prototype.getGraphPath = function(a2, f4, k) {
          var e = this, c = e.options, p2 = [], g = [], n, q2 = c.step;
          a2 = a2 || e.points;
          var u = a2.reversed;
          u && a2.reverse();
          (q2 = { right: 1, center: 2 }[q2] || q2 && 3) && u && (q2 = 4 - q2);
          a2 = this.getValidPoints(a2, false, !(c.connectNulls && !f4 && !k));
          a2.forEach(function(t, x) {
            var z = t.plotX, m = t.plotY, h2 = a2[x - 1];
            (t.leftCliff || h2 && h2.rightCliff) && !k && (n = true);
            t.isNull && !w(f4) && 0 < x ? n = !c.connectNulls : t.isNull && !f4 ? n = true : (x === 0 || n ? x = [["M", t.plotX, t.plotY]] : e.getPointSpline ? x = [e.getPointSpline(a2, t, x)] : q2 ? (x = q2 === 1 ? [["L", h2.plotX, m]] : q2 === 2 ? [["L", (h2.plotX + z) / 2, h2.plotY], ["L", (h2.plotX + z) / 2, m]] : [["L", z, h2.plotY]], x.push(["L", z, m])) : x = [["L", z, m]], g.push(t.x), q2 && (g.push(t.x), q2 === 2 && g.push(t.x)), p2.push.apply(p2, x), n = false);
          });
          p2.xMap = g;
          return e.graphPath = p2;
        };
        A.prototype.getZonesGraphs = function(a2) {
          this.zones.forEach(function(f4, k) {
            k = ["zone-graph-" + k, "highcharts-graph highcharts-zone-graph-" + k + " " + (f4.className || "")];
            this.chart.styledMode || k.push(f4.color || this.color, f4.dashStyle || this.options.dashStyle);
            a2.push(k);
          }, this);
          return a2;
        };
        A.defaultOptions = E2(a.defaultOptions, {});
        return A;
      }(a);
      f2.registerSeriesType("line", B2);
      return B2;
    });
    K2(f, "Series/Area/AreaSeries.js", [f["Core/Color/Color.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2) {
      var w = this && this.__extends || function() {
        var a2 = function(e, c) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, c2) {
            a3.__proto__ = c2;
          } || function(a3, c2) {
            for (var e2 in c2)
              c2.hasOwnProperty(e2) && (a3[e2] = c2[e2]);
          };
          return a2(e, c);
        };
        return function(e, c) {
          function f3() {
            this.constructor = e;
          }
          a2(e, c);
          e.prototype = c === null ? Object.create(c) : (f3.prototype = c.prototype, new f3());
        };
      }(), C2 = a.parse, I2 = B2.seriesTypes.line;
      a = H2.extend;
      var A = H2.merge, u = H2.objectEach, n = H2.pick;
      H2 = function(a2) {
        function e() {
          var c = a2 !== null && a2.apply(this, arguments) || this;
          c.data = void 0;
          c.options = void 0;
          c.points = void 0;
          return c;
        }
        w(e, a2);
        e.prototype.drawGraph = function() {
          this.areaPath = [];
          a2.prototype.drawGraph.apply(this);
          var c = this, e2 = this.areaPath, f3 = this.options, k = [["area", "highcharts-area", this.color, f3.fillColor]];
          this.zones.forEach(function(a3, e3) {
            k.push(["zone-area-" + e3, "highcharts-area highcharts-zone-area-" + e3 + " " + a3.className, a3.color || c.color, a3.fillColor || f3.fillColor]);
          });
          k.forEach(function(a3) {
            var g = a3[0], k2 = c[g], p2 = k2 ? "animate" : "attr", q2 = {};
            k2 ? (k2.endX = c.preventGraphAnimation ? null : e2.xMap, k2.animate({ d: e2 })) : (q2.zIndex = 0, k2 = c[g] = c.chart.renderer.path(e2).addClass(a3[1]).add(c.group), k2.isArea = true);
            c.chart.styledMode || (q2.fill = n(a3[3], C2(a3[2]).setOpacity(n(f3.fillOpacity, 0.75)).get()));
            k2[p2](q2);
            k2.startX = e2.xMap;
            k2.shiftUnit = f3.step ? 2 : 1;
          });
        };
        e.prototype.getGraphPath = function(a3) {
          var c = I2.prototype.getGraphPath, e2 = this.options, f3 = e2.stacking, k = this.yAxis, u2, y = [], x = [], z = this.index, m = k.stacking.stacks[this.stackKey], h2 = e2.threshold, b = Math.round(k.getThreshold(e2.threshold));
          e2 = n(e2.connectNulls, f3 === "percent");
          var l = function(c2, d2, e3) {
            var g = a3[c2];
            c2 = f3 && m[g.x].points[z];
            var l2 = g[e3 + "Null"] || 0;
            e3 = g[e3 + "Cliff"] || 0;
            g = true;
            if (e3 || l2) {
              var p2 = (l2 ? c2[0] : c2[1]) + e3;
              var n2 = c2[0] + e3;
              g = !!l2;
            } else
              !f3 && a3[d2] && a3[d2].isNull && (p2 = n2 = h2);
            typeof p2 !== "undefined" && (x.push({ plotX: D, plotY: p2 === null ? b : k.getThreshold(p2), isNull: g, isCliff: true }), y.push({ plotX: D, plotY: n2 === null ? b : k.getThreshold(n2), doCurve: false }));
          };
          a3 = a3 || this.points;
          f3 && (a3 = this.getStackPoints(a3));
          for (u2 = 0; u2 < a3.length; u2++) {
            f3 || (a3[u2].leftCliff = a3[u2].rightCliff = a3[u2].leftNull = a3[u2].rightNull = void 0);
            var d = a3[u2].isNull;
            var D = n(a3[u2].rectPlotX, a3[u2].plotX);
            var v = f3 ? n(a3[u2].yBottom, b) : b;
            if (!d || e2)
              e2 || l(u2, u2 - 1, "left"), d && !f3 && e2 || (x.push(a3[u2]), y.push({ x: u2, plotX: D, plotY: v })), e2 || l(u2, u2 + 1, "right");
          }
          u2 = c.call(this, x, true, true);
          y.reversed = true;
          d = c.call(this, y, true, true);
          (v = d[0]) && v[0] === "M" && (d[0] = ["L", v[1], v[2]]);
          d = u2.concat(d);
          d.length && d.push(["Z"]);
          c = c.call(this, x, false, e2);
          d.xMap = u2.xMap;
          this.areaPath = d;
          return c;
        };
        e.prototype.getStackPoints = function(a3) {
          var c = this, e2 = [], f3 = [], k = this.xAxis, w2 = this.yAxis, y = w2.stacking.stacks[this.stackKey], x = {}, z = w2.series, m = z.length, h2 = w2.options.reversedStacks ? 1 : -1, b = z.indexOf(c);
          a3 = a3 || this.points;
          if (this.options.stacking) {
            for (var l = 0; l < a3.length; l++)
              a3[l].leftNull = a3[l].rightNull = void 0, x[a3[l].x] = a3[l];
            u(y, function(b2, a4) {
              b2.total !== null && f3.push(a4);
            });
            f3.sort(function(b2, a4) {
              return b2 - a4;
            });
            var d = z.map(function(b2) {
              return b2.visible;
            });
            f3.forEach(function(a4, g) {
              var l2 = 0, p2, q2;
              if (x[a4] && !x[a4].isNull)
                e2.push(x[a4]), [-1, 1].forEach(function(e3) {
                  var l3 = e3 === 1 ? "rightNull" : "leftNull", k2 = 0, n2 = y[f3[g + e3]];
                  if (n2)
                    for (var r = b; 0 <= r && r < m; ) {
                      var t2 = z[r].index;
                      p2 = n2.points[t2];
                      p2 || (t2 === c.index ? x[a4][l3] = true : d[r] && (q2 = y[a4].points[t2]) && (k2 -= q2[1] - q2[0]));
                      r += h2;
                    }
                  x[a4][e3 === 1 ? "rightCliff" : "leftCliff"] = k2;
                });
              else {
                for (var t = b; 0 <= t && t < m; ) {
                  if (p2 = y[a4].points[z[t].index]) {
                    l2 = p2[1];
                    break;
                  }
                  t += h2;
                }
                l2 = n(l2, 0);
                l2 = w2.translate(l2, 0, 1, 0, 1);
                e2.push({ isNull: true, plotX: k.translate(a4, 0, 0, 0, 1), x: a4, plotY: l2, yBottom: l2 });
              }
            });
          }
          return e2;
        };
        e.defaultOptions = A(I2.defaultOptions, { threshold: 0 });
        return e;
      }(I2);
      a(H2.prototype, { singleStacks: false, drawLegendSymbol: f2.drawRectangle });
      B2.registerSeriesType("area", H2);
      return H2;
    });
    K2(f, "Series/Spline/SplineSeries.js", [
      f["Core/Series/SeriesRegistry.js"],
      f["Core/Utilities.js"]
    ], function(a, f2) {
      var C2 = this && this.__extends || function() {
        var a2 = function(f3, u) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, f4) {
            a3.__proto__ = f4;
          } || function(a3, f4) {
            for (var e in f4)
              f4.hasOwnProperty(e) && (a3[e] = f4[e]);
          };
          return a2(f3, u);
        };
        return function(f3, u) {
          function n() {
            this.constructor = f3;
          }
          a2(f3, u);
          f3.prototype = u === null ? Object.create(u) : (n.prototype = u.prototype, new n());
        };
      }(), H2 = a.seriesTypes.line, w = f2.merge, E2 = f2.pick;
      f2 = function(a2) {
        function f3() {
          var f4 = a2 !== null && a2.apply(this, arguments) || this;
          f4.data = void 0;
          f4.options = void 0;
          f4.points = void 0;
          return f4;
        }
        C2(f3, a2);
        f3.prototype.getPointSpline = function(a3, f4, k) {
          var e = f4.plotX || 0, c = f4.plotY || 0, p2 = a3[k - 1];
          k = a3[k + 1];
          if (p2 && !p2.isNull && p2.doCurve !== false && !f4.isCliff && k && !k.isNull && k.doCurve !== false && !f4.isCliff) {
            a3 = p2.plotY || 0;
            var g = k.plotX || 0;
            k = k.plotY || 0;
            var n = 0;
            var q2 = (1.5 * e + (p2.plotX || 0)) / 2.5;
            var u = (1.5 * c + a3) / 2.5;
            g = (1.5 * e + g) / 2.5;
            var y = (1.5 * c + k) / 2.5;
            g !== q2 && (n = (y - u) * (g - e) / (g - q2) + c - y);
            u += n;
            y += n;
            u > a3 && u > c ? (u = Math.max(a3, c), y = 2 * c - u) : u < a3 && u < c && (u = Math.min(a3, c), y = 2 * c - u);
            y > k && y > c ? (y = Math.max(k, c), u = 2 * c - y) : y < k && y < c && (y = Math.min(k, c), u = 2 * c - y);
            f4.rightContX = g;
            f4.rightContY = y;
          }
          f4 = ["C", E2(p2.rightContX, p2.plotX, 0), E2(p2.rightContY, p2.plotY, 0), E2(q2, e, 0), E2(u, c, 0), e, c];
          p2.rightContX = p2.rightContY = void 0;
          return f4;
        };
        f3.defaultOptions = w(H2.defaultOptions);
        return f3;
      }(H2);
      a.registerSeriesType("spline", f2);
      return f2;
    });
    K2(f, "Series/AreaSpline/AreaSplineSeries.js", [f["Series/Area/AreaSeries.js"], f["Series/Spline/SplineSeries.js"], f["Core/Legend/LegendSymbol.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2, w) {
      var C2 = this && this.__extends || function() {
        var a2 = function(f3, e) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, e2) {
            a3.__proto__ = e2;
          } || function(a3, e2) {
            for (var c in e2)
              e2.hasOwnProperty(c) && (a3[c] = e2[c]);
          };
          return a2(f3, e);
        };
        return function(f3, e) {
          function c() {
            this.constructor = f3;
          }
          a2(f3, e);
          f3.prototype = e === null ? Object.create(e) : (c.prototype = e.prototype, new c());
        };
      }(), I2 = a.prototype, A = w.extend, u = w.merge;
      w = function(n) {
        function k() {
          var a2 = n !== null && n.apply(this, arguments) || this;
          a2.data = void 0;
          a2.points = void 0;
          a2.options = void 0;
          return a2;
        }
        C2(k, n);
        k.defaultOptions = u(f2.defaultOptions, a.defaultOptions);
        return k;
      }(f2);
      A(w.prototype, { getGraphPath: I2.getGraphPath, getStackPoints: I2.getStackPoints, drawGraph: I2.drawGraph, drawLegendSymbol: B2.drawRectangle });
      H2.registerSeriesType("areaspline", w);
      return w;
    });
    K2(f, "Series/Column/ColumnSeries.js", [
      f["Core/Animation/AnimationUtilities.js"],
      f["Core/Color/Color.js"],
      f["Core/Globals.js"],
      f["Core/Legend/LegendSymbol.js"],
      f["Core/Series/Series.js"],
      f["Core/Series/SeriesRegistry.js"],
      f["Core/Utilities.js"]
    ], function(a, f2, B2, H2, w, E2, I2) {
      var C2 = this && this.__extends || function() {
        var a2 = function(c2, b) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(b2, a3) {
            b2.__proto__ = a3;
          } || function(b2, a3) {
            for (var c3 in a3)
              a3.hasOwnProperty(c3) && (b2[c3] = a3[c3]);
          };
          return a2(c2, b);
        };
        return function(c2, b) {
          function e2() {
            this.constructor = c2;
          }
          a2(c2, b);
          c2.prototype = b === null ? Object.create(b) : (e2.prototype = b.prototype, new e2());
        };
      }(), u = a.animObject, n = f2.parse, k = B2.hasTouch;
      a = B2.noop;
      var e = I2.clamp, c = I2.css, p2 = I2.defined, g = I2.extend, t = I2.fireEvent, q2 = I2.isArray, F = I2.isNumber, y = I2.merge, x = I2.pick, z = I2.objectEach;
      I2 = function(a2) {
        function f3() {
          var b = a2 !== null && a2.apply(this, arguments) || this;
          b.borderWidth = void 0;
          b.data = void 0;
          b.group = void 0;
          b.options = void 0;
          b.points = void 0;
          return b;
        }
        C2(f3, a2);
        f3.prototype.animate = function(b) {
          var a3 = this, c2 = this.yAxis, f4 = a3.options, h2 = this.chart.inverted, k2 = {}, m = h2 ? "translateX" : "translateY";
          if (b)
            k2.scaleY = 1e-3, b = e(c2.toPixels(f4.threshold), c2.pos, c2.pos + c2.len), h2 ? k2.translateX = b - c2.len : k2.translateY = b, a3.clipBox && a3.setClip(), a3.group.attr(k2);
          else {
            var p3 = Number(a3.group.attr(m));
            a3.group.animate({ scaleY: 1 }, g(u(a3.options.animation), { step: function(b2, d) {
              a3.group && (k2[m] = p3 + d.pos * (c2.pos - p3), a3.group.attr(k2));
            } }));
          }
        };
        f3.prototype.init = function(b, c2) {
          a2.prototype.init.apply(this, arguments);
          var d = this;
          b = d.chart;
          b.hasRendered && b.series.forEach(function(b2) {
            b2.type === d.type && (b2.isDirty = true);
          });
        };
        f3.prototype.getColumnMetrics = function() {
          var b = this, a3 = b.options, c2 = b.xAxis, e2 = b.yAxis, f4 = c2.options.reversedStacks;
          f4 = c2.reversed && !f4 || !c2.reversed && f4;
          var h2 = {}, g2, k2 = 0;
          a3.grouping === false ? k2 = 1 : b.chart.series.forEach(function(a4) {
            var c3 = a4.yAxis, d = a4.options;
            if (a4.type === b.type && (a4.visible || !b.chart.options.chart.ignoreHiddenSeries) && e2.len === c3.len && e2.pos === c3.pos) {
              if (d.stacking && d.stacking !== "group") {
                g2 = a4.stackKey;
                typeof h2[g2] === "undefined" && (h2[g2] = k2++);
                var f5 = h2[g2];
              } else
                d.grouping !== false && (f5 = k2++);
              a4.columnIndex = f5;
            }
          });
          var m = Math.min(Math.abs(c2.transA) * (c2.ordinal && c2.ordinal.slope || a3.pointRange || c2.closestPointRange || c2.tickInterval || 1), c2.len), p3 = m * a3.groupPadding, n2 = (m - 2 * p3) / (k2 || 1);
          a3 = Math.min(a3.maxPointWidth || c2.len, x(a3.pointWidth, n2 * (1 - 2 * a3.pointPadding)));
          b.columnMetrics = { width: a3, offset: (n2 - a3) / 2 + (p3 + ((b.columnIndex || 0) + (f4 ? 1 : 0)) * n2 - m / 2) * (f4 ? -1 : 1), paddedWidth: n2, columnCount: k2 };
          return b.columnMetrics;
        };
        f3.prototype.crispCol = function(b, a3, c2, e2) {
          var d = this.chart, f4 = this.borderWidth, h2 = -(f4 % 2 ? 0.5 : 0);
          f4 = f4 % 2 ? 0.5 : 1;
          d.inverted && d.renderer.isVML && (f4 += 1);
          this.options.crisp && (c2 = Math.round(b + c2) + h2, b = Math.round(b) + h2, c2 -= b);
          e2 = Math.round(a3 + e2) + f4;
          h2 = 0.5 >= Math.abs(a3) && 0.5 < e2;
          a3 = Math.round(a3) + f4;
          e2 -= a3;
          h2 && e2 && (--a3, e2 += 1);
          return { x: b, y: a3, width: c2, height: e2 };
        };
        f3.prototype.adjustForMissingColumns = function(b, a3, c2, e2) {
          var d = this, f4 = this.options.stacking;
          if (!c2.isNull && 1 < e2.columnCount) {
            var h2 = this.yAxis.options.reversedStacks, g2 = 0, l = h2 ? 0 : -e2.columnCount;
            z(this.yAxis.stacking && this.yAxis.stacking.stacks, function(b2) {
              if (typeof c2.x === "number" && (b2 = b2[c2.x.toString()])) {
                var a4 = b2.points[d.index], e3 = b2.total;
                f4 ? (a4 && (g2 = l), b2.hasValidPoints && (h2 ? l++ : l--)) : q2(a4) && (g2 = a4[1], l = e3 || 0);
              }
            });
            b = (c2.plotX || 0) + ((l - 1) * e2.paddedWidth + a3) / 2 - a3 - g2 * e2.paddedWidth;
          }
          return b;
        };
        f3.prototype.translate = function() {
          var b = this, a3 = b.chart, c2 = b.options, f4 = b.dense = 2 > b.closestPointRange * b.xAxis.transA;
          f4 = b.borderWidth = x(c2.borderWidth, f4 ? 0 : 1);
          var h2 = b.xAxis, g2 = b.yAxis, k2 = c2.threshold, m = b.translatedThreshold = g2.getThreshold(k2), n2 = x(c2.minPointLength, 5), q3 = b.getColumnMetrics(), t2 = q3.width, z2 = b.pointXOffset = q3.offset, u2 = b.dataMin, y2 = b.dataMax, C3 = b.barW = Math.max(t2, 1 + 2 * f4);
          a3.inverted && (m -= 0.5);
          c2.pointPadding && (C3 = Math.ceil(C3));
          w.prototype.translate.apply(b);
          b.points.forEach(function(d) {
            var f5 = x(d.yBottom, m), l = 999 + Math.abs(f5), r = d.plotX || 0;
            l = e(d.plotY, -l, g2.len + l);
            var v = Math.min(l, f5), w2 = Math.max(l, f5) - v, D = t2, A = r + z2, B3 = C3;
            n2 && Math.abs(w2) < n2 && (w2 = n2, r = !g2.reversed && !d.negative || g2.reversed && d.negative, F(k2) && F(y2) && d.y === k2 && y2 <= k2 && (g2.min || 0) < k2 && (u2 !== y2 || (g2.max || 0) <= k2) && (r = !r), v = Math.abs(v - m) > n2 ? f5 - n2 : m - (r ? n2 : 0));
            p2(d.options.pointWidth) && (D = B3 = Math.ceil(d.options.pointWidth), A -= Math.round((D - t2) / 2));
            c2.centerInCategory && (A = b.adjustForMissingColumns(A, D, d, q3));
            d.barX = A;
            d.pointWidth = D;
            d.tooltipPos = a3.inverted ? [e(g2.len + g2.pos - a3.plotLeft - l, g2.pos - a3.plotLeft, g2.len + g2.pos - a3.plotLeft), h2.len + h2.pos - a3.plotTop - A - B3 / 2, w2] : [h2.left - a3.plotLeft + A + B3 / 2, e(l + g2.pos - a3.plotTop, g2.pos - a3.plotTop, g2.len + g2.pos - a3.plotTop), w2];
            d.shapeType = b.pointClass.prototype.shapeType || "rect";
            d.shapeArgs = b.crispCol.apply(b, d.isNull ? [A, m, B3, 0] : [A, v, B3, w2]);
          });
        };
        f3.prototype.drawGraph = function() {
          this.group[this.dense ? "addClass" : "removeClass"]("highcharts-dense-data");
        };
        f3.prototype.pointAttribs = function(b, a3) {
          var c2 = this.options, e2 = this.pointAttrToOptions || {}, f4 = e2.stroke || "borderColor", h2 = e2["stroke-width"] || "borderWidth", g2 = b && b.color || this.color, l = b && b[f4] || c2[f4] || g2;
          e2 = b && b.options.dashStyle || c2.dashStyle;
          var k2 = b && b[h2] || c2[h2] || this[h2] || 0, m = x(b && b.opacity, c2.opacity, 1);
          if (b && this.zones.length) {
            var p3 = b.getZone();
            g2 = b.options.color || p3 && (p3.color || b.nonZonedColor) || this.color;
            p3 && (l = p3.borderColor || l, e2 = p3.dashStyle || e2, k2 = p3.borderWidth || k2);
          }
          a3 && b && (b = y(c2.states[a3], b.options.states && b.options.states[a3] || {}), a3 = b.brightness, g2 = b.color || typeof a3 !== "undefined" && n(g2).brighten(b.brightness).get() || g2, l = b[f4] || l, k2 = b[h2] || k2, e2 = b.dashStyle || e2, m = x(b.opacity, m));
          f4 = { fill: g2, stroke: l, "stroke-width": k2, opacity: m };
          e2 && (f4.dashstyle = e2);
          return f4;
        };
        f3.prototype.drawPoints = function() {
          var b = this, a3 = this.chart, c2 = b.options, e2 = a3.renderer, f4 = c2.animationLimit || 250, h2;
          b.points.forEach(function(d) {
            var g2 = d.graphic, l = !!g2, k2 = g2 && a3.pointCount < f4 ? "animate" : "attr";
            if (F(d.plotY) && d.y !== null) {
              h2 = d.shapeArgs;
              g2 && d.hasNewShapeType() && (g2 = g2.destroy());
              b.enabledDataSorting && (d.startXPos = b.xAxis.reversed ? -(h2 ? h2.width || 0 : 0) : b.xAxis.width);
              g2 || (d.graphic = g2 = e2[d.shapeType](h2).add(d.group || b.group)) && b.enabledDataSorting && a3.hasRendered && a3.pointCount < f4 && (g2.attr({ x: d.startXPos }), l = true, k2 = "animate");
              if (g2 && l)
                g2[k2](y(h2));
              if (c2.borderRadius)
                g2[k2]({ r: c2.borderRadius });
              a3.styledMode || g2[k2](b.pointAttribs(d, d.selected && "select")).shadow(d.allowShadow !== false && c2.shadow, null, c2.stacking && !c2.borderRadius);
              g2 && (g2.addClass(d.getClassName(), true), g2.attr({ visibility: d.visible ? "inherit" : "hidden" }));
            } else
              g2 && (d.graphic = g2.destroy());
          });
        };
        f3.prototype.drawTracker = function() {
          var b = this, a3 = b.chart, d = a3.pointer, e2 = function(b2) {
            var a4 = d.getPointFromEvent(b2);
            typeof a4 !== "undefined" && (d.isDirectTouch = true, a4.onMouseOver(b2));
          }, f4;
          b.points.forEach(function(b2) {
            f4 = q2(b2.dataLabels) ? b2.dataLabels : b2.dataLabel ? [b2.dataLabel] : [];
            b2.graphic && (b2.graphic.element.point = b2);
            f4.forEach(function(a4) {
              a4.div ? a4.div.point = b2 : a4.element.point = b2;
            });
          });
          b._hasTracking || (b.trackerGroups.forEach(function(f5) {
            if (b[f5]) {
              b[f5].addClass("highcharts-tracker").on("mouseover", e2).on("mouseout", function(b2) {
                d.onTrackerMouseOut(b2);
              });
              if (k)
                b[f5].on("touchstart", e2);
              !a3.styledMode && b.options.cursor && b[f5].css(c).css({ cursor: b.options.cursor });
            }
          }), b._hasTracking = true);
          t(this, "afterDrawTracker");
        };
        f3.prototype.remove = function() {
          var b = this, a3 = b.chart;
          a3.hasRendered && a3.series.forEach(function(a4) {
            a4.type === b.type && (a4.isDirty = true);
          });
          w.prototype.remove.apply(b, arguments);
        };
        f3.defaultOptions = y(w.defaultOptions, {
          borderRadius: 0,
          centerInCategory: false,
          groupPadding: 0.2,
          marker: null,
          pointPadding: 0.1,
          minPointLength: 0,
          cropThreshold: 50,
          pointRange: null,
          states: { hover: { halo: false, brightness: 0.1 }, select: { color: "#cccccc", borderColor: "#000000" } },
          dataLabels: { align: void 0, verticalAlign: void 0, y: void 0 },
          startFromThreshold: true,
          stickyTracking: false,
          tooltip: { distance: 6 },
          threshold: 0,
          borderColor: "#ffffff"
        });
        return f3;
      }(w);
      g(I2.prototype, { cropShoulder: 0, directTouch: true, drawLegendSymbol: H2.drawRectangle, getSymbol: a, negStacks: true, trackerGroups: ["group", "dataLabelsGroup"] });
      E2.registerSeriesType("column", I2);
      return I2;
    });
    K2(f, "Core/Series/DataLabel.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/FormatUtilities.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = a.getDeferredAnimation, w = f2.format, E2 = B2.defined, I2 = B2.extend, A = B2.fireEvent, u = B2.isArray, n = B2.merge, k = B2.objectEach, e = B2.pick, c = B2.splat, p2;
      (function(a2) {
        function f3(a3, b, c2, d, f4) {
          var h2 = this, g2 = this.chart, l = this.isCartesian && g2.inverted, k2 = this.enabledDataSorting, m2 = e(a3.dlBox && a3.dlBox.centerX, a3.plotX), p4 = a3.plotY, n2 = c2.rotation, q2 = c2.align, t = E2(m2) && E2(p4) && g2.isInsidePlot(m2, Math.round(p4), { inverted: l, paneCoordinates: true, series: h2 }), z2 = function(c3) {
            k2 && h2.xAxis && !u2 && h2.setDataLabelStartPos(a3, b, f4, t, c3);
          }, u2 = e(c2.overflow, k2 ? "none" : "justify") === "justify", x2 = this.visible && a3.visible !== false && (a3.series.forceDL || k2 && !u2 || t || e(c2.inside, !!this.options.stacking) && d && g2.isInsidePlot(m2, l ? d.x + 1 : d.y + d.height - 1, { inverted: l, paneCoordinates: true, series: h2 }));
          if (x2 && E2(m2) && E2(p4)) {
            n2 && b.attr({ align: q2 });
            q2 = b.getBBox(true);
            var y2 = [0, 0];
            var w2 = g2.renderer.fontMetrics(g2.styledMode ? void 0 : c2.style.fontSize, b).b;
            d = I2({ x: l ? this.yAxis.len - p4 : m2, y: Math.round(l ? this.xAxis.len - m2 : p4), width: 0, height: 0 }, d);
            I2(c2, { width: q2.width, height: q2.height });
            n2 ? (u2 = false, y2 = g2.renderer.rotCorr(w2, n2), m2 = { x: d.x + (c2.x || 0) + d.width / 2 + y2.x, y: d.y + (c2.y || 0) + { top: 0, middle: 0.5, bottom: 1 }[c2.verticalAlign] * d.height }, y2 = [q2.x - Number(b.attr("x")), q2.y - Number(b.attr("y"))], z2(m2), b[f4 ? "attr" : "animate"](m2)) : (z2(d), b.align(c2, void 0, d), m2 = b.alignAttr);
            u2 && 0 <= d.height ? this.justifyDataLabel(b, c2, m2, q2, d, f4) : e(c2.crop, true) && (d = m2.x, z2 = m2.y, d += y2[0], z2 += y2[1], x2 = g2.isInsidePlot(d, z2, { paneCoordinates: true, series: h2 }) && g2.isInsidePlot(d + q2.width, z2 + q2.height, { paneCoordinates: true, series: h2 }));
            if (c2.shape && !n2)
              b[f4 ? "attr" : "animate"]({ anchorX: l ? g2.plotWidth - a3.plotY : a3.plotX, anchorY: l ? g2.plotHeight - a3.plotX : a3.plotY });
          }
          f4 && k2 && (b.placed = false);
          x2 || k2 && !u2 ? b.show() : (b.hide(), b.placed = false);
        }
        function g(a3, b) {
          var c2 = b.filter;
          return c2 ? (b = c2.operator, a3 = a3[c2.property], c2 = c2.value, b === ">" && a3 > c2 || b === "<" && a3 < c2 || b === ">=" && a3 >= c2 || b === "<=" && a3 <= c2 || b === "==" && a3 == c2 || b === "===" && a3 === c2 ? true : false) : true;
        }
        function p3() {
          var a3 = this, b = a3.chart, f4 = a3.options, d = a3.points, m2 = a3.hasRendered || 0, p4 = b.renderer, n2 = f4.dataLabels, q2, t = n2.animation;
          t = n2.defer ? C2(b, t, a3) : { defer: 0, duration: 0 };
          n2 = x(x(b.options.plotOptions && b.options.plotOptions.series && b.options.plotOptions.series.dataLabels, b.options.plotOptions && b.options.plotOptions[a3.type] && b.options.plotOptions[a3.type].dataLabels), n2);
          A(this, "drawDataLabels");
          if (u(n2) || n2.enabled || a3._hasPointLabels) {
            var z2 = a3.plotGroup("dataLabelsGroup", "data-labels", m2 ? "inherit" : "hidden", n2.zIndex || 6);
            z2.attr({ opacity: +m2 });
            !m2 && (m2 = a3.dataLabelsGroup) && (a3.visible && z2.show(), m2[f4.animation ? "animate" : "attr"]({ opacity: 1 }, t));
            d.forEach(function(d2) {
              q2 = c(x(n2, d2.dlOptions || d2.options && d2.options.dataLabels));
              q2.forEach(function(c2, h2) {
                var l = c2.enabled && (!d2.isNull || d2.dataLabelOnNull) && g(d2, c2), m3 = d2.connectors ? d2.connectors[h2] : d2.connector, n3 = d2.dataLabels ? d2.dataLabels[h2] : d2.dataLabel, q3 = !n3, r = e(c2.distance, d2.labelDistance);
                if (l) {
                  var t2 = d2.getLabelConfig();
                  var v = e(c2[d2.formatPrefix + "Format"], c2.format);
                  t2 = E2(v) ? w(v, t2, b) : (c2[d2.formatPrefix + "Formatter"] || c2.formatter).call(t2, c2);
                  v = c2.style;
                  var u2 = c2.rotation;
                  b.styledMode || (v.color = e(c2.color, v.color, a3.color, "#000000"), v.color === "contrast" ? (d2.contrastColor = p4.getContrast(d2.color || a3.color), v.color = !E2(r) && c2.inside || 0 > r || f4.stacking ? d2.contrastColor : "#000000") : delete d2.contrastColor, f4.cursor && (v.cursor = f4.cursor));
                  var x2 = { r: c2.borderRadius || 0, rotation: u2, padding: c2.padding, zIndex: 1 };
                  b.styledMode || (x2.fill = c2.backgroundColor, x2.stroke = c2.borderColor, x2["stroke-width"] = c2.borderWidth);
                  k(x2, function(b2, a4) {
                    typeof b2 === "undefined" && delete x2[a4];
                  });
                }
                !n3 || l && E2(t2) && !!n3.div === !!c2.useHTML && (n3.rotation && c2.rotation || n3.rotation === c2.rotation) || (q3 = true, d2.dataLabel = n3 = d2.dataLabel && d2.dataLabel.destroy(), d2.dataLabels && (d2.dataLabels.length === 1 ? delete d2.dataLabels : delete d2.dataLabels[h2]), h2 || delete d2.dataLabel, m3 && (d2.connector = d2.connector.destroy(), d2.connectors && (d2.connectors.length === 1 ? delete d2.connectors : delete d2.connectors[h2])));
                l && E2(t2) ? (n3 ? x2.text = t2 : (d2.dataLabels = d2.dataLabels || [], n3 = d2.dataLabels[h2] = u2 ? p4.text(t2, 0, 0, c2.useHTML).addClass("highcharts-data-label") : p4.label(t2, 0, 0, c2.shape, null, null, c2.useHTML, null, "data-label"), h2 || (d2.dataLabel = n3), n3.addClass(" highcharts-data-label-color-" + d2.colorIndex + " " + (c2.className || "") + (c2.useHTML ? " highcharts-tracker" : ""))), n3.options = c2, n3.attr(x2), b.styledMode || n3.css(v).shadow(c2.shadow), n3.added || n3.add(z2), c2.textPath && !c2.useHTML && (n3.setTextPath(d2.getDataLabelPath && d2.getDataLabelPath(n3) || d2.graphic, c2.textPath), d2.dataLabelPath && !c2.textPath.enabled && (d2.dataLabelPath = d2.dataLabelPath.destroy())), a3.alignDataLabel(d2, n3, c2, null, q3)) : n3 && n3.hide();
              });
            });
          }
          A(this, "afterDrawDataLabels");
        }
        function y(a3, b, c2, d, e2, f4) {
          var h2 = this.chart, g2 = b.align, k2 = b.verticalAlign, l = a3.box ? 0 : a3.padding || 0, m2 = b.x;
          m2 = m2 === void 0 ? 0 : m2;
          var p4 = b.y;
          p4 = p4 === void 0 ? 0 : p4;
          var n2 = (c2.x || 0) + l;
          if (0 > n2) {
            g2 === "right" && 0 <= m2 ? (b.align = "left", b.inside = true) : m2 -= n2;
            var q2 = true;
          }
          n2 = (c2.x || 0) + d.width - l;
          n2 > h2.plotWidth && (g2 === "left" && 0 >= m2 ? (b.align = "right", b.inside = true) : m2 += h2.plotWidth - n2, q2 = true);
          n2 = c2.y + l;
          0 > n2 && (k2 === "bottom" && 0 <= p4 ? (b.verticalAlign = "top", b.inside = true) : p4 -= n2, q2 = true);
          n2 = (c2.y || 0) + d.height - l;
          n2 > h2.plotHeight && (k2 === "top" && 0 >= p4 ? (b.verticalAlign = "bottom", b.inside = true) : p4 += h2.plotHeight - n2, q2 = true);
          q2 && (b.x = m2, b.y = p4, a3.placed = !f4, a3.align(b, void 0, e2));
          return q2;
        }
        function x(a3, b) {
          var c2 = [], d;
          if (u(a3) && !u(b))
            c2 = a3.map(function(a4) {
              return n(a4, b);
            });
          else if (u(b) && !u(a3))
            c2 = b.map(function(b2) {
              return n(a3, b2);
            });
          else if (u(a3) || u(b))
            for (d = Math.max(a3.length, b.length); d--; )
              c2[d] = n(a3[d], b[d]);
          else
            c2 = n(a3, b);
          return c2;
        }
        function z(a3, b, c2, d, e2) {
          var f4 = this.chart, g2 = f4.inverted, h2 = this.xAxis, k2 = h2.reversed, l = g2 ? b.height / 2 : b.width / 2;
          a3 = (a3 = a3.pointWidth) ? a3 / 2 : 0;
          b.startXPos = g2 ? e2.x : k2 ? -l - a3 : h2.width - l + a3;
          b.startYPos = g2 ? k2 ? this.yAxis.height - l + a3 : -l - a3 : e2.y;
          d ? b.visibility === "hidden" && (b.show(), b.attr({ opacity: 0 }).animate({ opacity: 1 })) : b.attr({ opacity: 1 }).animate({ opacity: 0 }, void 0, b.hide);
          f4.hasRendered && (c2 && b.attr({ x: b.startXPos, y: b.startYPos }), b.placed = true);
        }
        var m = [];
        a2.compose = function(a3) {
          if (m.indexOf(a3) === -1) {
            var b = a3.prototype;
            m.push(a3);
            b.alignDataLabel = f3;
            b.drawDataLabels = p3;
            b.justifyDataLabel = y;
            b.setDataLabelStartPos = z;
          }
        };
      })(p2 || (p2 = {}));
      return p2;
    });
    K2(f, "Series/Column/ColumnDataLabel.js", [f["Core/Series/DataLabel.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = f2.series, w = B2.merge, E2 = B2.pick, I2;
      (function(f3) {
        function u(a2, e, c, f4, g) {
          var k = this.chart.inverted, n2 = a2.series, p2 = (n2.xAxis ? n2.xAxis.len : this.chart.plotSizeX) || 0;
          n2 = (n2.yAxis ? n2.yAxis.len : this.chart.plotSizeY) || 0;
          var u2 = a2.dlBox || a2.shapeArgs, x = E2(a2.below, a2.plotY > E2(this.translatedThreshold, n2)), z = E2(c.inside, !!this.options.stacking);
          u2 && (f4 = w(u2), 0 > f4.y && (f4.height += f4.y, f4.y = 0), u2 = f4.y + f4.height - n2, 0 < u2 && u2 < f4.height && (f4.height -= u2), k && (f4 = { x: n2 - f4.y - f4.height, y: p2 - f4.x - f4.width, width: f4.height, height: f4.width }), z || (k ? (f4.x += x ? 0 : f4.width, f4.width = 0) : (f4.y += x ? f4.height : 0, f4.height = 0)));
          c.align = E2(c.align, !k || z ? "center" : x ? "right" : "left");
          c.verticalAlign = E2(c.verticalAlign, k || z ? "middle" : x ? "top" : "bottom");
          C2.prototype.alignDataLabel.call(this, a2, e, c, f4, g);
          c.inside && a2.contrastColor && e.css({ color: a2.contrastColor });
        }
        var n = [];
        f3.compose = function(f4) {
          a.compose(C2);
          n.indexOf(f4) === -1 && (n.push(f4), f4.prototype.alignDataLabel = u);
        };
      })(I2 || (I2 = {}));
      return I2;
    });
    K2(f, "Series/Bar/BarSeries.js", [f["Series/Column/ColumnSeries.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = this && this.__extends || function() {
        var a2 = function(f3, u) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, f4) {
            a3.__proto__ = f4;
          } || function(a3, f4) {
            for (var e in f4)
              f4.hasOwnProperty(e) && (a3[e] = f4[e]);
          };
          return a2(f3, u);
        };
        return function(f3, u) {
          function n() {
            this.constructor = f3;
          }
          a2(f3, u);
          f3.prototype = u === null ? Object.create(u) : (n.prototype = u.prototype, new n());
        };
      }(), w = B2.extend, E2 = B2.merge;
      B2 = function(f3) {
        function w2() {
          var a2 = f3 !== null && f3.apply(this, arguments) || this;
          a2.data = void 0;
          a2.options = void 0;
          a2.points = void 0;
          return a2;
        }
        C2(w2, f3);
        w2.defaultOptions = E2(a.defaultOptions, {});
        return w2;
      }(a);
      w(B2.prototype, { inverted: true });
      f2.registerSeriesType("bar", B2);
      return B2;
    });
    K2(f, "Series/Scatter/ScatterSeries.js", [
      f["Series/Column/ColumnSeries.js"],
      f["Series/Line/LineSeries.js"],
      f["Core/Series/SeriesRegistry.js"],
      f["Core/Utilities.js"]
    ], function(a, f2, B2, H2) {
      var w = this && this.__extends || function() {
        var a2 = function(f3, k) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, c) {
            a3.__proto__ = c;
          } || function(a3, c) {
            for (var e in c)
              c.hasOwnProperty(e) && (a3[e] = c[e]);
          };
          return a2(f3, k);
        };
        return function(f3, k) {
          function e() {
            this.constructor = f3;
          }
          a2(f3, k);
          f3.prototype = k === null ? Object.create(k) : (e.prototype = k.prototype, new e());
        };
      }(), C2 = H2.addEvent, I2 = H2.extend, A = H2.merge;
      H2 = function(a2) {
        function n() {
          var f3 = a2 !== null && a2.apply(this, arguments) || this;
          f3.data = void 0;
          f3.options = void 0;
          f3.points = void 0;
          return f3;
        }
        w(n, a2);
        n.prototype.applyJitter = function() {
          var a3 = this, e = this.options.jitter, c = this.points.length;
          e && this.points.forEach(function(f3, g) {
            ["x", "y"].forEach(function(k, n2) {
              var p2 = "plot" + k.toUpperCase();
              if (e[k] && !f3.isNull) {
                var q2 = a3[k + "Axis"];
                var t = e[k] * q2.transA;
                if (q2 && !q2.isLog) {
                  var z = Math.max(0, f3[p2] - t);
                  q2 = Math.min(q2.len, f3[p2] + t);
                  n2 = 1e4 * Math.sin(g + n2 * c);
                  f3[p2] = z + (q2 - z) * (n2 - Math.floor(n2));
                  k === "x" && (f3.clientX = f3.plotX);
                }
              }
            });
          });
        };
        n.prototype.drawGraph = function() {
          this.options.lineWidth ? a2.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());
        };
        n.defaultOptions = A(f2.defaultOptions, { lineWidth: 0, findNearestPointBy: "xy", jitter: { x: 0, y: 0 }, marker: { enabled: true }, tooltip: { headerFormat: '<span style="color:{point.color}">\u25CF</span> <span style="font-size: 10px"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" } });
        return n;
      }(f2);
      I2(H2.prototype, {
        drawTracker: a.prototype.drawTracker,
        sorted: false,
        requireSorting: false,
        noSharedTooltip: true,
        trackerGroups: ["group", "markerGroup", "dataLabelsGroup"],
        takeOrdinalPosition: false
      });
      C2(H2, "afterTranslate", function() {
        this.applyJitter();
      });
      B2.registerSeriesType("scatter", H2);
      return H2;
    });
    K2(f, "Series/CenteredUtilities.js", [f["Core/Globals.js"], f["Core/Series/Series.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = a.deg2rad, w = B2.isNumber, E2 = B2.pick, I2 = B2.relativeLength, A;
      (function(a2) {
        a2.getCenter = function() {
          var a3 = this.options, k = this.chart, e = 2 * (a3.slicedOffset || 0), c = k.plotWidth - 2 * e, p2 = k.plotHeight - 2 * e, g = a3.center, t = Math.min(c, p2), q2 = a3.thickness, u = a3.size, y = a3.innerSize || 0;
          typeof u === "string" && (u = parseFloat(u));
          typeof y === "string" && (y = parseFloat(y));
          a3 = [E2(g[0], "50%"), E2(g[1], "50%"), E2(u && 0 > u ? void 0 : a3.size, "100%"), E2(y && 0 > y ? void 0 : a3.innerSize || 0, "0%")];
          !k.angular || this instanceof f2 || (a3[3] = 0);
          for (g = 0; 4 > g; ++g)
            u = a3[g], k = 2 > g || g === 2 && /%$/.test(u), a3[g] = I2(u, [c, p2, t, a3[2]][g]) + (k ? e : 0);
          a3[3] > a3[2] && (a3[3] = a3[2]);
          w(q2) && 2 * q2 < a3[2] && 0 < q2 && (a3[3] = a3[2] - 2 * q2);
          return a3;
        };
        a2.getStartAndEndRadians = function(a3, f3) {
          a3 = w(a3) ? a3 : 0;
          f3 = w(f3) && f3 > a3 && 360 > f3 - a3 ? f3 : a3 + 360;
          return { start: C2 * (a3 + -90), end: C2 * (f3 + -90) };
        };
      })(A || (A = {}));
      return A;
    });
    K2(f, "Series/Pie/PiePoint.js", [f["Core/Animation/AnimationUtilities.js"], f["Core/Series/Point.js"], f["Core/Utilities.js"]], function(a, f2, B2) {
      var C2 = this && this.__extends || function() {
        var a2 = function(e, c) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, c2) {
            a3.__proto__ = c2;
          } || function(a3, c2) {
            for (var e2 in c2)
              c2.hasOwnProperty(e2) && (a3[e2] = c2[e2]);
          };
          return a2(e, c);
        };
        return function(e, c) {
          function f3() {
            this.constructor = e;
          }
          a2(e, c);
          e.prototype = c === null ? Object.create(c) : (f3.prototype = c.prototype, new f3());
        };
      }(), w = a.setAnimation, E2 = B2.addEvent, I2 = B2.defined;
      a = B2.extend;
      var A = B2.isNumber, u = B2.pick, n = B2.relativeLength;
      f2 = function(a2) {
        function e() {
          var c = a2 !== null && a2.apply(this, arguments) || this;
          c.labelDistance = void 0;
          c.options = void 0;
          c.series = void 0;
          return c;
        }
        C2(e, a2);
        e.prototype.getConnectorPath = function() {
          var a3 = this.labelPosition, e2 = this.series.options.dataLabels, f3 = this.connectorShapes, k = e2.connectorShape;
          f3[k] && (k = f3[k]);
          return k.call(this, {
            x: a3.final.x,
            y: a3.final.y,
            alignment: a3.alignment
          }, a3.connectorPosition, e2);
        };
        e.prototype.getTranslate = function() {
          return this.sliced ? this.slicedTranslation : { translateX: 0, translateY: 0 };
        };
        e.prototype.haloPath = function(a3) {
          var c = this.shapeArgs;
          return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.x, c.y, c.r + a3, c.r + a3, { innerR: c.r - 1, start: c.start, end: c.end });
        };
        e.prototype.init = function() {
          var c = this;
          a2.prototype.init.apply(this, arguments);
          this.name = u(this.name, "Slice");
          var e2 = function(a3) {
            c.slice(a3.type === "select");
          };
          E2(this, "select", e2);
          E2(this, "unselect", e2);
          return this;
        };
        e.prototype.isValid = function() {
          return A(this.y) && 0 <= this.y;
        };
        e.prototype.setVisible = function(a3, e2) {
          var c = this, f3 = this.series, k = f3.chart, n2 = f3.options.ignoreHiddenPoint;
          e2 = u(e2, n2);
          a3 !== this.visible && (this.visible = this.options.visible = a3 = typeof a3 === "undefined" ? !this.visible : a3, f3.options.data[f3.data.indexOf(this)] = this.options, ["graphic", "dataLabel", "connector", "shadowGroup"].forEach(function(e3) {
            if (c[e3])
              c[e3][a3 ? "show" : "hide"](a3);
          }), this.legendItem && k.legend.colorizeItem(this, a3), a3 || this.state !== "hover" || this.setState(""), n2 && (f3.isDirty = true), e2 && k.redraw());
        };
        e.prototype.slice = function(a3, e2, f3) {
          var c = this.series;
          w(f3, c.chart);
          u(e2, true);
          this.sliced = this.options.sliced = I2(a3) ? a3 : !this.sliced;
          c.options.data[c.data.indexOf(this)] = this.options;
          this.graphic && this.graphic.animate(this.getTranslate());
          this.shadowGroup && this.shadowGroup.animate(this.getTranslate());
        };
        return e;
      }(f2);
      a(f2.prototype, { connectorShapes: { fixedOffset: function(a2, e, c) {
        var f3 = e.breakAt;
        e = e.touchingSliceAt;
        return [[
          "M",
          a2.x,
          a2.y
        ], c.softConnector ? ["C", a2.x + (a2.alignment === "left" ? -5 : 5), a2.y, 2 * f3.x - e.x, 2 * f3.y - e.y, f3.x, f3.y] : ["L", f3.x, f3.y], ["L", e.x, e.y]];
      }, straight: function(a2, e) {
        e = e.touchingSliceAt;
        return [["M", a2.x, a2.y], ["L", e.x, e.y]];
      }, crookedLine: function(a2, e, c) {
        e = e.touchingSliceAt;
        var f3 = this.series, g = f3.center[0], k = f3.chart.plotWidth, q2 = f3.chart.plotLeft;
        f3 = a2.alignment;
        var u2 = this.shapeArgs.r;
        c = n(c.crookDistance, 1);
        k = f3 === "left" ? g + u2 + (k + q2 - g - u2) * (1 - c) : q2 + (g - u2) * c;
        c = ["L", k, a2.y];
        g = true;
        if (f3 === "left" ? k > a2.x || k < e.x : k < a2.x || k > e.x)
          g = false;
        a2 = [["M", a2.x, a2.y]];
        g && a2.push(c);
        a2.push(["L", e.x, e.y]);
        return a2;
      } } });
      return f2;
    });
    K2(f, "Series/Pie/PieSeries.js", [f["Series/CenteredUtilities.js"], f["Series/Column/ColumnSeries.js"], f["Core/Globals.js"], f["Core/Legend/LegendSymbol.js"], f["Series/Pie/PiePoint.js"], f["Core/Series/Series.js"], f["Core/Series/SeriesRegistry.js"], f["Core/Renderer/SVG/Symbols.js"], f["Core/Utilities.js"]], function(a, f2, B2, H2, w, E2, I2, A, u) {
      var n = this && this.__extends || function() {
        var a2 = function(c2, e2) {
          a2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a3, c3) {
            a3.__proto__ = c3;
          } || function(a3, c3) {
            for (var e3 in c3)
              c3.hasOwnProperty(e3) && (a3[e3] = c3[e3]);
          };
          return a2(c2, e2);
        };
        return function(c2, e2) {
          function f3() {
            this.constructor = c2;
          }
          a2(c2, e2);
          c2.prototype = e2 === null ? Object.create(e2) : (f3.prototype = e2.prototype, new f3());
        };
      }(), k = a.getStartAndEndRadians;
      B2 = B2.noop;
      var e = u.clamp, c = u.extend, p2 = u.fireEvent, g = u.merge, t = u.pick, q2 = u.relativeLength;
      u = function(a2) {
        function c2() {
          var c3 = a2 !== null && a2.apply(this, arguments) || this;
          c3.center = void 0;
          c3.data = void 0;
          c3.maxLabelDistance = void 0;
          c3.options = void 0;
          c3.points = void 0;
          return c3;
        }
        n(c2, a2);
        c2.prototype.animate = function(a3) {
          var c3 = this, e2 = c3.points, f3 = c3.startAngleRad;
          a3 || e2.forEach(function(a4) {
            var b = a4.graphic, d = a4.shapeArgs;
            b && d && (b.attr({ r: t(a4.startR, c3.center && c3.center[3] / 2), start: f3, end: f3 }), b.animate({ r: d.r, start: d.start, end: d.end }, c3.options.animation));
          });
        };
        c2.prototype.drawEmpty = function() {
          var a3 = this.startAngleRad, c3 = this.endAngleRad, e2 = this.options;
          if (this.total === 0 && this.center) {
            var f3 = this.center[0];
            var b = this.center[1];
            this.graph || (this.graph = this.chart.renderer.arc(f3, b, this.center[1] / 2, 0, a3, c3).addClass("highcharts-empty-series").add(this.group));
            this.graph.attr({ d: A.arc(f3, b, this.center[2] / 2, 0, { start: a3, end: c3, innerR: this.center[3] / 2 }) });
            this.chart.styledMode || this.graph.attr({ "stroke-width": e2.borderWidth, fill: e2.fillColor || "none", stroke: e2.color || "#cccccc" });
          } else
            this.graph && (this.graph = this.graph.destroy());
        };
        c2.prototype.drawPoints = function() {
          var a3 = this.chart.renderer;
          this.points.forEach(function(c3) {
            c3.graphic && c3.hasNewShapeType() && (c3.graphic = c3.graphic.destroy());
            c3.graphic || (c3.graphic = a3[c3.shapeType](c3.shapeArgs).add(c3.series.group), c3.delayedRendering = true);
          });
        };
        c2.prototype.generatePoints = function() {
          a2.prototype.generatePoints.call(this);
          this.updateTotals();
        };
        c2.prototype.getX = function(a3, c3, f3) {
          var g2 = this.center, b = this.radii ? this.radii[f3.index] || 0 : g2[2] / 2;
          a3 = Math.asin(e((a3 - g2[1]) / (b + f3.labelDistance), -1, 1));
          return g2[0] + (c3 ? -1 : 1) * Math.cos(a3) * (b + f3.labelDistance) + (0 < f3.labelDistance ? (c3 ? -1 : 1) * this.options.dataLabels.padding : 0);
        };
        c2.prototype.hasData = function() {
          return !!this.processedXData.length;
        };
        c2.prototype.redrawPoints = function() {
          var a3 = this, c3 = a3.chart, e2 = c3.renderer, f3 = a3.options.shadow, b, l, d, k2;
          this.drawEmpty();
          !f3 || a3.shadowGroup || c3.styledMode || (a3.shadowGroup = e2.g("shadow").attr({ zIndex: -1 }).add(a3.group));
          a3.points.forEach(function(h2) {
            var m = {};
            l = h2.graphic;
            if (!h2.isNull && l) {
              var n2 = void 0;
              k2 = h2.shapeArgs;
              b = h2.getTranslate();
              c3.styledMode || (n2 = h2.shadowGroup, f3 && !n2 && (n2 = h2.shadowGroup = e2.g("shadow").add(a3.shadowGroup)), n2 && n2.attr(b), d = a3.pointAttribs(h2, h2.selected && "select"));
              h2.delayedRendering ? (l.setRadialReference(a3.center).attr(k2).attr(b), c3.styledMode || l.attr(d).attr({ "stroke-linejoin": "round" }).shadow(f3, n2), h2.delayedRendering = false) : (l.setRadialReference(a3.center), c3.styledMode || g(true, m, d), g(true, m, k2, b), l.animate(m));
              l.attr({ visibility: h2.visible ? "inherit" : "hidden" });
              l.addClass(h2.getClassName(), true);
            } else
              l && (h2.graphic = l.destroy());
          });
        };
        c2.prototype.sortByAngle = function(a3, c3) {
          a3.sort(function(a4, e2) {
            return typeof a4.angle !== "undefined" && (e2.angle - a4.angle) * c3;
          });
        };
        c2.prototype.translate = function(a3) {
          this.generatePoints();
          var c3 = this.options, e2 = c3.slicedOffset, f3 = e2 + (c3.borderWidth || 0), b = k(c3.startAngle, c3.endAngle), g2 = this.startAngleRad = b.start;
          b = (this.endAngleRad = b.end) - g2;
          var d = this.points, n2 = c3.dataLabels.distance;
          c3 = c3.ignoreHiddenPoint;
          var v = d.length, r, u2 = 0;
          a3 || (this.center = a3 = this.getCenter());
          for (r = 0; r < v; r++) {
            var w2 = d[r];
            var y = g2 + u2 * b;
            !w2.isValid() || c3 && !w2.visible || (u2 += w2.percentage / 100);
            var x = g2 + u2 * b;
            var C2 = { x: a3[0], y: a3[1], r: a3[2] / 2, innerR: a3[3] / 2, start: Math.round(1e3 * y) / 1e3, end: Math.round(1e3 * x) / 1e3 };
            w2.shapeType = "arc";
            w2.shapeArgs = C2;
            w2.labelDistance = t(w2.options.dataLabels && w2.options.dataLabels.distance, n2);
            w2.labelDistance = q2(w2.labelDistance, C2.r);
            this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, w2.labelDistance);
            x = (x + y) / 2;
            x > 1.5 * Math.PI ? x -= 2 * Math.PI : x < -Math.PI / 2 && (x += 2 * Math.PI);
            w2.slicedTranslation = { translateX: Math.round(Math.cos(x) * e2), translateY: Math.round(Math.sin(x) * e2) };
            C2 = Math.cos(x) * a3[2] / 2;
            var A2 = Math.sin(x) * a3[2] / 2;
            w2.tooltipPos = [a3[0] + 0.7 * C2, a3[1] + 0.7 * A2];
            w2.half = x < -Math.PI / 2 || x > Math.PI / 2 ? 1 : 0;
            w2.angle = x;
            y = Math.min(f3, w2.labelDistance / 5);
            w2.labelPosition = { natural: { x: a3[0] + C2 + Math.cos(x) * w2.labelDistance, y: a3[1] + A2 + Math.sin(x) * w2.labelDistance }, "final": {}, alignment: 0 > w2.labelDistance ? "center" : w2.half ? "right" : "left", connectorPosition: { breakAt: { x: a3[0] + C2 + Math.cos(x) * y, y: a3[1] + A2 + Math.sin(x) * y }, touchingSliceAt: { x: a3[0] + C2, y: a3[1] + A2 } } };
          }
          p2(this, "afterTranslate");
        };
        c2.prototype.updateTotals = function() {
          var a3 = this.points, c3 = a3.length, e2 = this.options.ignoreHiddenPoint, f3, b = 0;
          for (f3 = 0; f3 < c3; f3++) {
            var g2 = a3[f3];
            !g2.isValid() || e2 && !g2.visible || (b += g2.y);
          }
          this.total = b;
          for (f3 = 0; f3 < c3; f3++)
            g2 = a3[f3], g2.percentage = 0 < b && (g2.visible || !e2) ? g2.y / b * 100 : 0, g2.total = b;
        };
        c2.defaultOptions = g(E2.defaultOptions, {
          center: [null, null],
          clip: false,
          colorByPoint: true,
          dataLabels: { allowOverlap: true, connectorPadding: 5, connectorShape: "fixedOffset", crookDistance: "70%", distance: 30, enabled: true, formatter: function() {
            return this.point.isNull ? void 0 : this.point.name;
          }, softConnector: true, x: 0 },
          fillColor: void 0,
          ignoreHiddenPoint: true,
          inactiveOtherPoints: true,
          legendType: "point",
          marker: null,
          size: null,
          showInLegend: false,
          slicedOffset: 10,
          stickyTracking: false,
          tooltip: { followPointer: true },
          borderColor: "#ffffff",
          borderWidth: 1,
          lineWidth: void 0,
          states: { hover: { brightness: 0.1 } }
        });
        return c2;
      }(E2);
      c(u.prototype, { axisTypes: [], directTouch: true, drawGraph: void 0, drawLegendSymbol: H2.drawRectangle, drawTracker: f2.prototype.drawTracker, getCenter: a.getCenter, getSymbol: B2, isCartesian: false, noSharedTooltip: true, pointAttribs: f2.prototype.pointAttribs, pointClass: w, requireSorting: false, searchPoint: B2, trackerGroups: ["group", "dataLabelsGroup"] });
      I2.registerSeriesType("pie", u);
      return u;
    });
    K2(f, "Series/Pie/PieDataLabel.js", [
      f["Core/Series/DataLabel.js"],
      f["Core/Globals.js"],
      f["Core/Renderer/RendererUtilities.js"],
      f["Core/Series/SeriesRegistry.js"],
      f["Core/Utilities.js"]
    ], function(a, f2, B2, H2, w) {
      var C2 = f2.noop, I2 = B2.distribute, A = H2.series, u = w.arrayMax, n = w.clamp, k = w.defined, e = w.merge, c = w.pick, p2 = w.relativeLength, g;
      (function(f3) {
        function g2() {
          var a2 = this, f4 = a2.data, b = a2.chart, g3 = a2.options.dataLabels || {}, d = g3.connectorPadding, n2 = b.plotWidth, p3 = b.plotHeight, q2 = b.plotLeft, t2 = Math.round(b.chartWidth / 3), w3 = a2.center, z2 = w3[2] / 2, x2 = w3[1], y = [[], []], C3 = [0, 0, 0, 0], B3 = a2.dataLabelPositioners, F, E2, H3, K3, U3, G2, T, M, V, W2, Z2, R2;
          a2.visible && (g3.enabled || a2._hasPointLabels) && (f4.forEach(function(a3) {
            a3.dataLabel && a3.visible && a3.dataLabel.shortened && (a3.dataLabel.attr({ width: "auto" }).css({ width: "auto", textOverflow: "clip" }), a3.dataLabel.shortened = false);
          }), A.prototype.drawDataLabels.apply(a2), f4.forEach(function(a3) {
            a3.dataLabel && (a3.visible ? (y[a3.half].push(a3), a3.dataLabel._pos = null, !k(g3.style.width) && !k(a3.options.dataLabels && a3.options.dataLabels.style && a3.options.dataLabels.style.width) && a3.dataLabel.getBBox().width > t2 && (a3.dataLabel.css({ width: Math.round(0.7 * t2) + "px" }), a3.dataLabel.shortened = true)) : (a3.dataLabel = a3.dataLabel.destroy(), a3.dataLabels && a3.dataLabels.length === 1 && delete a3.dataLabels));
          }), y.forEach(function(e2, f5) {
            var h2 = e2.length, l = [], m;
            if (h2) {
              a2.sortByAngle(e2, f5 - 0.5);
              if (0 < a2.maxLabelDistance) {
                var r = Math.max(0, x2 - z2 - a2.maxLabelDistance);
                var t3 = Math.min(x2 + z2 + a2.maxLabelDistance, b.plotHeight);
                e2.forEach(function(a3) {
                  0 < a3.labelDistance && a3.dataLabel && (a3.top = Math.max(0, x2 - z2 - a3.labelDistance), a3.bottom = Math.min(x2 + z2 + a3.labelDistance, b.plotHeight), m = a3.dataLabel.getBBox().height || 21, a3.distributeBox = { target: a3.labelPosition.natural.y - a3.top + m / 2, size: m, rank: a3.y }, l.push(a3.distributeBox));
                });
                r = t3 + m - r;
                I2(l, r, r / 5);
              }
              for (Z2 = 0; Z2 < h2; Z2++) {
                F = e2[Z2];
                G2 = F.labelPosition;
                K3 = F.dataLabel;
                W2 = F.visible === false ? "hidden" : "inherit";
                V = r = G2.natural.y;
                l && k(F.distributeBox) && (typeof F.distributeBox.pos === "undefined" ? W2 = "hidden" : (T = F.distributeBox.size, V = B3.radialDistributionY(F)));
                delete F.positionIndex;
                if (g3.justify)
                  M = B3.justify(F, z2, w3);
                else
                  switch (g3.alignTo) {
                    case "connectors":
                      M = B3.alignToConnectors(e2, f5, n2, q2);
                      break;
                    case "plotEdges":
                      M = B3.alignToPlotEdges(K3, f5, n2, q2);
                      break;
                    default:
                      M = B3.radialDistributionX(a2, F, V, r);
                  }
                K3._attr = { visibility: W2, align: G2.alignment };
                R2 = F.options.dataLabels || {};
                K3._pos = { x: M + c(R2.x, g3.x) + ({ left: d, right: -d }[G2.alignment] || 0), y: V + c(R2.y, g3.y) - 10 };
                G2.final.x = M;
                G2.final.y = V;
                c(g3.crop, true) && (U3 = K3.getBBox().width, r = null, M - U3 < d && f5 === 1 ? (r = Math.round(U3 - M + d), C3[3] = Math.max(r, C3[3])) : M + U3 > n2 - d && f5 === 0 && (r = Math.round(M + U3 - n2 + d), C3[1] = Math.max(r, C3[1])), 0 > V - T / 2 ? C3[0] = Math.max(Math.round(-V + T / 2), C3[0]) : V + T / 2 > p3 && (C3[2] = Math.max(Math.round(V + T / 2 - p3), C3[2])), K3.sideOverflow = r);
              }
            }
          }), u(C3) === 0 || this.verifyDataLabelOverflow(C3)) && (this.placeDataLabels(), this.points.forEach(function(d2) {
            R2 = e(g3, d2.options.dataLabels);
            if (E2 = c(R2.connectorWidth, 1)) {
              var f5;
              H3 = d2.connector;
              if ((K3 = d2.dataLabel) && K3._pos && d2.visible && 0 < d2.labelDistance) {
                W2 = K3._attr.visibility;
                if (f5 = !H3)
                  d2.connector = H3 = b.renderer.path().addClass("highcharts-data-label-connector  highcharts-color-" + d2.colorIndex + (d2.className ? " " + d2.className : "")).add(a2.dataLabelsGroup), b.styledMode || H3.attr({ "stroke-width": E2, stroke: R2.connectorColor || d2.color || "#666666" });
                H3[f5 ? "attr" : "animate"]({ d: d2.getConnectorPath() });
                H3.attr("visibility", W2);
              } else
                H3 && (d2.connector = H3.destroy());
            }
          }));
        }
        function t() {
          this.points.forEach(function(a2) {
            var c2 = a2.dataLabel, b;
            c2 && a2.visible && ((b = c2._pos) ? (c2.sideOverflow && (c2._attr.width = Math.max(c2.getBBox().width - c2.sideOverflow, 0), c2.css({ width: c2._attr.width + "px", textOverflow: (this.options.dataLabels.style || {}).textOverflow || "ellipsis" }), c2.shortened = true), c2.attr(c2._attr), c2[c2.moved ? "animate" : "attr"](b), c2.moved = true) : c2 && c2.attr({ y: -9999 }));
            delete a2.distributeBox;
          }, this);
        }
        function w2(a2) {
          var c2 = this.center, b = this.options, e2 = b.center, d = b.minSize || 80, f4 = b.size !== null;
          if (!f4) {
            if (e2[0] !== null)
              var g3 = Math.max(c2[2] - Math.max(a2[1], a2[3]), d);
            else
              g3 = Math.max(c2[2] - a2[1] - a2[3], d), c2[0] += (a2[3] - a2[1]) / 2;
            e2[1] !== null ? g3 = n(g3, d, c2[2] - Math.max(a2[0], a2[2])) : (g3 = n(g3, d, c2[2] - a2[0] - a2[2]), c2[1] += (a2[0] - a2[2]) / 2);
            g3 < c2[2] ? (c2[2] = g3, c2[3] = Math.min(b.thickness ? Math.max(0, g3 - 2 * b.thickness) : Math.max(0, p2(b.innerSize || 0, g3)), g3), this.translate(c2), this.drawDataLabels && this.drawDataLabels()) : f4 = true;
          }
          return f4;
        }
        var x = [], z = { radialDistributionY: function(a2) {
          return a2.top + a2.distributeBox.pos;
        }, radialDistributionX: function(a2, c2, b, e2) {
          return a2.getX(b < c2.top + 2 || b > c2.bottom - 2 ? e2 : b, c2.half, c2);
        }, justify: function(a2, c2, b) {
          return b[0] + (a2.half ? -1 : 1) * (c2 + a2.labelDistance);
        }, alignToPlotEdges: function(a2, c2, b, e2) {
          a2 = a2.getBBox().width;
          return c2 ? a2 + e2 : b - a2 - e2;
        }, alignToConnectors: function(a2, c2, b, e2) {
          var d = 0, f4;
          a2.forEach(function(a3) {
            f4 = a3.dataLabel.getBBox().width;
            f4 > d && (d = f4);
          });
          return c2 ? d + e2 : b - d - e2;
        } };
        f3.compose = function(c2) {
          a.compose(A);
          x.indexOf(c2) === -1 && (x.push(c2), c2 = c2.prototype, c2.dataLabelPositioners = z, c2.alignDataLabel = C2, c2.drawDataLabels = g2, c2.placeDataLabels = t, c2.verifyDataLabelOverflow = w2);
        };
      })(g || (g = {}));
      return g;
    });
    K2(f, "Extensions/OverlappingDataLabels.js", [f["Core/Chart/Chart.js"], f["Core/Utilities.js"]], function(a, f2) {
      function C2(a2, f3) {
        var e = false;
        if (a2) {
          var c = a2.newOpacity;
          a2.oldOpacity !== c && (a2.alignAttr && a2.placed ? (a2[c ? "removeClass" : "addClass"]("highcharts-data-label-hidden"), e = true, a2.alignAttr.opacity = c, a2[a2.isOld ? "animate" : "attr"](a2.alignAttr, null, function() {
            f3.styledMode || a2.css({ pointerEvents: c ? "auto" : "none" });
          }), w(f3, "afterHideOverlappingLabel")) : a2.attr({ opacity: c }));
          a2.isOld = true;
        }
        return e;
      }
      var H2 = f2.addEvent, w = f2.fireEvent, E2 = f2.isArray, I2 = f2.isNumber, A = f2.objectEach, u = f2.pick;
      H2(a, "render", function() {
        var a2 = this, f3 = [];
        (this.labelCollectors || []).forEach(function(a3) {
          f3 = f3.concat(a3());
        });
        (this.yAxis || []).forEach(function(a3) {
          a3.stacking && a3.options.stackLabels && !a3.options.stackLabels.allowOverlap && A(a3.stacking.stacks, function(a4) {
            A(a4, function(a5) {
              a5.label && f3.push(a5.label);
            });
          });
        });
        (this.series || []).forEach(function(e) {
          var c = e.options.dataLabels;
          e.visible && (c.enabled !== false || e._hasPointLabels) && (c = function(c2) {
            return c2.forEach(function(c3) {
              c3.visible && (E2(c3.dataLabels) ? c3.dataLabels : c3.dataLabel ? [c3.dataLabel] : []).forEach(function(e2) {
                var g = e2.options;
                e2.labelrank = u(g.labelrank, c3.labelrank, c3.shapeArgs && c3.shapeArgs.height);
                g.allowOverlap ? (e2.oldOpacity = e2.opacity, e2.newOpacity = 1, C2(e2, a2)) : f3.push(e2);
              });
            });
          }, c(e.nodes || []), c(e.points));
        });
        this.hideOverlappingLabels(f3);
      });
      a.prototype.hideOverlappingLabels = function(a2) {
        var f3 = this, e = a2.length, c = f3.renderer, n, g, t, q2 = false;
        var u2 = function(a3) {
          var e2, f4 = a3.box ? 0 : a3.padding || 0, b = e2 = 0, g2;
          if (a3 && (!a3.alignAttr || a3.placed)) {
            var d = a3.alignAttr || { x: a3.attr("x"), y: a3.attr("y") };
            var k = a3.parentGroup;
            a3.width || (e2 = a3.getBBox(), a3.width = e2.width, a3.height = e2.height, e2 = c.fontMetrics(null, a3.element).h);
            var n2 = a3.width - 2 * f4;
            (g2 = { left: "0", center: "0.5", right: "1" }[a3.alignValue]) ? b = +g2 * n2 : I2(a3.x) && Math.round(a3.x) !== a3.translateX && (b = a3.x - a3.translateX);
            return { x: d.x + (k.translateX || 0) + f4 - (b || 0), y: d.y + (k.translateY || 0) + f4 - e2, width: a3.width - 2 * f4, height: a3.height - 2 * f4 };
          }
        };
        for (g = 0; g < e; g++)
          if (n = a2[g])
            n.oldOpacity = n.opacity, n.newOpacity = 1, n.absoluteBox = u2(n);
        a2.sort(function(a3, c2) {
          return (c2.labelrank || 0) - (a3.labelrank || 0);
        });
        for (g = 0; g < e; g++) {
          var y = (u2 = a2[g]) && u2.absoluteBox;
          for (n = g + 1; n < e; ++n) {
            var x = (t = a2[n]) && t.absoluteBox;
            !y || !x || u2 === t || u2.newOpacity === 0 || t.newOpacity === 0 || u2.visibility === "hidden" || t.visibility === "hidden" || x.x >= y.x + y.width || x.x + x.width <= y.x || x.y >= y.y + y.height || x.y + x.height <= y.y || ((u2.labelrank < t.labelrank ? u2 : t).newOpacity = 0);
          }
        }
        a2.forEach(function(a3) {
          C2(a3, f3) && (q2 = true);
        });
        q2 && w(f3, "afterHideAllOverlappingLabels");
      };
    });
    K2(f, "Core/Responsive.js", [f["Core/Utilities.js"]], function(a) {
      var f2 = a.extend, B2 = a.find, H2 = a.isArray, w = a.isObject, E2 = a.merge, I2 = a.objectEach, A = a.pick, u = a.splat, n = a.uniqueKey, k;
      (function(a2) {
        var c = [];
        a2.compose = function(a3) {
          c.indexOf(a3) === -1 && (c.push(a3), f2(a3.prototype, e.prototype));
          return a3;
        };
        var e = function() {
          function a3() {
          }
          a3.prototype.currentOptions = function(a4) {
            function c2(a5, f4, g, h2) {
              var b;
              I2(a5, function(a6, d) {
                if (!h2 && -1 < e2.collectionsWithUpdate.indexOf(d) && f4[d])
                  for (a6 = u(a6), g[d] = [], b = 0; b < Math.max(a6.length, f4[d].length); b++)
                    f4[d][b] && (a6[b] === void 0 ? g[d][b] = f4[d][b] : (g[d][b] = {}, c2(a6[b], f4[d][b], g[d][b], h2 + 1)));
                else
                  w(a6) ? (g[d] = H2(a6) ? [] : {}, c2(a6, f4[d] || {}, g[d], h2 + 1)) : g[d] = typeof f4[d] === "undefined" ? null : f4[d];
              });
            }
            var e2 = this, f3 = {};
            c2(a4, this.options, f3, 0);
            return f3;
          };
          a3.prototype.matchResponsiveRule = function(a4, c2) {
            var e2 = a4.condition;
            (e2.callback || function() {
              return this.chartWidth <= A(e2.maxWidth, Number.MAX_VALUE) && this.chartHeight <= A(e2.maxHeight, Number.MAX_VALUE) && this.chartWidth >= A(e2.minWidth, 0) && this.chartHeight >= A(e2.minHeight, 0);
            }).call(this) && c2.push(a4._id);
          };
          a3.prototype.setResponsive = function(a4, c2) {
            var e2 = this, f3 = this.options.responsive, g = this.currentResponsive, k2 = [];
            !c2 && f3 && f3.rules && f3.rules.forEach(function(a5) {
              typeof a5._id === "undefined" && (a5._id = n());
              e2.matchResponsiveRule(a5, k2);
            }, this);
            c2 = E2.apply(void 0, k2.map(function(a5) {
              return B2((f3 || {}).rules || [], function(c3) {
                return c3._id === a5;
              });
            }).map(function(a5) {
              return a5 && a5.chartOptions;
            }));
            c2.isResponsiveOptions = true;
            k2 = k2.toString() || void 0;
            k2 !== (g && g.ruleIds) && (g && this.update(g.undoOptions, a4, true), k2 ? (g = this.currentOptions(c2), g.isResponsiveOptions = true, this.currentResponsive = { ruleIds: k2, mergedOptions: c2, undoOptions: g }, this.update(c2, a4, true)) : this.currentResponsive = void 0);
          };
          return a3;
        }();
      })(k || (k = {}));
      return k;
    });
    K2(f, "masters/highcharts.src.js", [
      f["Core/Globals.js"],
      f["Core/Utilities.js"],
      f["Core/DefaultOptions.js"],
      f["Core/Animation/Fx.js"],
      f["Core/Animation/AnimationUtilities.js"],
      f["Core/Renderer/HTML/AST.js"],
      f["Core/FormatUtilities.js"],
      f["Core/Renderer/RendererUtilities.js"],
      f["Core/Renderer/SVG/SVGElement.js"],
      f["Core/Renderer/SVG/SVGRenderer.js"],
      f["Core/Renderer/HTML/HTMLElement.js"],
      f["Core/Renderer/HTML/HTMLRenderer.js"],
      f["Core/Axis/Axis.js"],
      f["Core/Axis/DateTimeAxis.js"],
      f["Core/Axis/LogarithmicAxis.js"],
      f["Core/Axis/PlotLineOrBand/PlotLineOrBand.js"],
      f["Core/Axis/Tick.js"],
      f["Core/Tooltip.js"],
      f["Core/Series/Point.js"],
      f["Core/Pointer.js"],
      f["Core/MSPointer.js"],
      f["Core/Legend/Legend.js"],
      f["Core/Chart/Chart.js"],
      f["Core/Series/Series.js"],
      f["Core/Series/SeriesRegistry.js"],
      f["Series/Column/ColumnSeries.js"],
      f["Series/Column/ColumnDataLabel.js"],
      f["Series/Pie/PieSeries.js"],
      f["Series/Pie/PieDataLabel.js"],
      f["Core/Series/DataLabel.js"],
      f["Core/Responsive.js"],
      f["Core/Color/Color.js"],
      f["Core/Time.js"]
    ], function(a, f2, B2, H2, w, E2, I2, A, u, n, k, e, c, p2, g, t, q2, F, y, x, z, m, h2, b, l, d, D, v, r, K3, P2, S, N2) {
      a.animate = w.animate;
      a.animObject = w.animObject;
      a.getDeferredAnimation = w.getDeferredAnimation;
      a.setAnimation = w.setAnimation;
      a.stop = w.stop;
      a.timers = H2.timers;
      a.AST = E2;
      a.Axis = c;
      a.Chart = h2;
      a.chart = h2.chart;
      a.Fx = H2;
      a.Legend = m;
      a.PlotLineOrBand = t;
      a.Point = y;
      a.Pointer = z.isRequired() ? z : x;
      a.Series = b;
      a.SVGElement = u;
      a.SVGRenderer = n;
      a.Tick = q2;
      a.Time = N2;
      a.Tooltip = F;
      a.Color = S;
      a.color = S.parse;
      e.compose(n);
      k.compose(u);
      a.defaultOptions = B2.defaultOptions;
      a.getOptions = B2.getOptions;
      a.time = B2.defaultTime;
      a.setOptions = B2.setOptions;
      a.dateFormat = I2.dateFormat;
      a.format = I2.format;
      a.numberFormat = I2.numberFormat;
      a.addEvent = f2.addEvent;
      a.arrayMax = f2.arrayMax;
      a.arrayMin = f2.arrayMin;
      a.attr = f2.attr;
      a.clearTimeout = f2.clearTimeout;
      a.correctFloat = f2.correctFloat;
      a.createElement = f2.createElement;
      a.css = f2.css;
      a.defined = f2.defined;
      a.destroyObjectProperties = f2.destroyObjectProperties;
      a.discardElement = f2.discardElement;
      a.distribute = A.distribute;
      a.erase = f2.erase;
      a.error = f2.error;
      a.extend = f2.extend;
      a.extendClass = f2.extendClass;
      a.find = f2.find;
      a.fireEvent = f2.fireEvent;
      a.getMagnitude = f2.getMagnitude;
      a.getStyle = f2.getStyle;
      a.inArray = f2.inArray;
      a.isArray = f2.isArray;
      a.isClass = f2.isClass;
      a.isDOMElement = f2.isDOMElement;
      a.isFunction = f2.isFunction;
      a.isNumber = f2.isNumber;
      a.isObject = f2.isObject;
      a.isString = f2.isString;
      a.keys = f2.keys;
      a.merge = f2.merge;
      a.normalizeTickInterval = f2.normalizeTickInterval;
      a.objectEach = f2.objectEach;
      a.offset = f2.offset;
      a.pad = f2.pad;
      a.pick = f2.pick;
      a.pInt = f2.pInt;
      a.relativeLength = f2.relativeLength;
      a.removeEvent = f2.removeEvent;
      a.seriesType = l.seriesType;
      a.splat = f2.splat;
      a.stableSort = f2.stableSort;
      a.syncTimeout = f2.syncTimeout;
      a.timeUnits = f2.timeUnits;
      a.uniqueKey = f2.uniqueKey;
      a.useSerialIds = f2.useSerialIds;
      a.wrap = f2.wrap;
      D.compose(d);
      K3.compose(b);
      p2.compose(c);
      g.compose(c);
      r.compose(v);
      t.compose(c);
      P2.compose(h2);
      return a;
    });
    f["masters/highcharts.src.js"]._modules = f;
    return f["masters/highcharts.src.js"];
  });
})(highcharts);
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esmBundler);
(function(module2, exports2) {
  !function(t, e) {
    module2.exports = e(highcharts.exports, require$$1);
  }(window, function(r, n) {
    return c = {}, o.m = i = [function(t, e) {
      t.exports = r;
    }, function(t, e) {
      t.exports = n;
    }, function(t, e, r2) {
      r2.r(e), r2.d(e, "Chart", function() {
        return l;
      }), r2.d(e, "default", function() {
        return h2;
      });
      var e = r2(0), c2 = r2.n(e);
      function n2(t2, e2) {
        return function r3(n3, o3, i3) {
          function t3(t4, e3) {
            !c2.a.isObject(t4, !i3) || c2.a.isClass(t4) || c2.a.isDOMElement(t4) ? n3[e3] = o3[e3] : n3[e3] = r3(n3[e3] || c2.a.isArray(t4) ? [] : {}, t4, i3);
          }
          return c2.a.isArray(o3) ? o3.forEach(t3) : c2.a.objectEach(o3, t3), n3;
        }({}, t2, e2);
      }
      var o2 = r2(1);
      function i2(t2) {
        return function(t3) {
          if (Array.isArray(t3))
            return a(t3);
        }(t2) || function(t3) {
          if (typeof Symbol != "undefined" && t3[Symbol.iterator] != null || t3["@@iterator"] != null)
            return Array.from(t3);
        }(t2) || function(t3, e2) {
          if (t3) {
            if (typeof t3 == "string")
              return a(t3, e2);
            var r3 = Object.prototype.toString.call(t3).slice(8, -1);
            return (r3 = r3 === "Object" && t3.constructor ? t3.constructor.name : r3) === "Map" || r3 === "Set" ? Array.from(t3) : r3 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3) ? a(t3, e2) : void 0;
          }
        }(t2) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function a(t2, e2) {
        (e2 == null || e2 > t2.length) && (e2 = t2.length);
        for (var r3 = 0, n3 = new Array(e2); r3 < e2; r3++)
          n3[r3] = t2[r3];
        return n3;
      }
      function u(e2, t2) {
        var r3, n3 = Object.keys(e2);
        return Object.getOwnPropertySymbols && (r3 = Object.getOwnPropertySymbols(e2), t2 && (r3 = r3.filter(function(t3) {
          return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
        })), n3.push.apply(n3, r3)), n3;
      }
      function s(n3) {
        for (var t2 = 1; t2 < arguments.length; t2++) {
          var o3 = arguments[t2] != null ? arguments[t2] : {};
          t2 % 2 ? u(Object(o3), true).forEach(function(t3) {
            var e2, r3;
            e2 = n3, t3 = o3[r3 = t3], r3 in e2 ? Object.defineProperty(e2, r3, { value: t3, enumerable: true, configurable: true, writable: true }) : e2[r3] = t3;
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n3, Object.getOwnPropertyDescriptors(o3)) : u(Object(o3)).forEach(function(t3) {
            Object.defineProperty(n3, t3, Object.getOwnPropertyDescriptor(o3, t3));
          });
        }
        return n3;
      }
      function f() {
        this.chart && this.chart.destroy();
      }
      var p2 = function(e2, t2) {
        t2 = t2.split(".")[0] < 3 ? { render: function(t3) {
          return t3("div", { ref: "chart" });
        }, beforeDestroy: f } : { render: function() {
          return Object(o2.h)("div", { ref: "chart" });
        }, beforeUnmount: f };
        return s({ template: '<div ref="chart"></div>', props: { constructorType: { type: String, default: "chart" }, options: { type: Object, required: true }, callback: Function, updateArgs: { type: Array, default: function() {
          return [true, true];
        } }, highcharts: { type: Object }, deepCopyOnUpdate: { type: Boolean, default: true } }, watch: { options: { handler: function(t3) {
          var e3;
          (e3 = this.chart).update.apply(e3, [n2(t3, this.deepCopyOnUpdate)].concat(i2(this.updateArgs)));
        }, deep: true } }, mounted: function() {
          var t3 = this.highcharts || e2;
          this.options && t3[this.constructorType] ? this.chart = t3[this.constructorType](this.$refs.chart, n2(this.options, true), this.callback || null) : this.options ? console.warn("'".concat(this.constructorType, "' constructor-type is incorrect. Sometimes this error is caused by the fact, that the corresponding module wasn't imported.")) : console.warn('The "options" parameter was not passed.');
        } }, t2);
      }, l = p2(c2.a, o2.version || r2.n(o2).a.version);
      function h2(t2) {
        var e2 = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {};
        t2.component(e2.tagName || "highcharts", p2(e2.highcharts || c2.a, t2.version));
      }
    }], o.c = c, o.d = function(t, e, r2) {
      o.o(t, e) || Object.defineProperty(t, e, { enumerable: true, get: r2 });
    }, o.r = function(t) {
      typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: true });
    }, o.t = function(e, t) {
      if (1 & t && (e = o(e)), 8 & t)
        return e;
      if (4 & t && typeof e == "object" && e && e.__esModule)
        return e;
      var r2 = /* @__PURE__ */ Object.create(null);
      if (o.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e }), 2 & t && typeof e != "string")
        for (var n2 in e)
          o.d(r2, n2, function(t2) {
            return e[t2];
          }.bind(null, n2));
      return r2;
    }, o.n = function(t) {
      var e = t && t.__esModule ? function() {
        return t.default;
      } : function() {
        return t;
      };
      return o.d(e, "a", e), e;
    }, o.o = function(t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }, o.p = "", o(o.s = 2);
    function o(t) {
      if (c[t])
        return c[t].exports;
      var e = c[t] = { i: t, l: false, exports: {} };
      return i[t].call(e.exports, e, e.exports, o), e.l = true, e.exports;
    }
    var i, c;
  });
})(highchartsVue_min);
var HelloThere_vue_vue_type_style_index_0_lang = /* @__PURE__ */ (() => ".ep-button{margin:4px}\n")();
const _hoisted_1$1 = /* @__PURE__ */ createBaseVNode("link", {
  rel: "stylesheet",
  href: "https://cdn.jsdelivr.net/npm/element-plus/dist/index.css"
}, null, -1);
const _hoisted_2$1 = /* @__PURE__ */ createBaseVNode("br", null, null, -1);
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "HelloThere",
  props: {
    msg: null
  },
  setup(__props) {
    const count = ref(0);
    return (_ctx, _cache) => {
      const _component_el_button = ElButton;
      return openBlock(), createElementBlock(Fragment, null, [
        _hoisted_1$1,
        createBaseVNode("h3", null, toDisplayString(__props.msg), 1),
        createBaseVNode("button", {
          bg: "blue-200 hover:blue-500 dark:blue-200 dark:hover:blue-600",
          text: "sm blue-900",
          font: "",
          p: "y-2 x-4",
          m: "2",
          border: "2 rounded blue-900",
          onClick: _cache[0] || (_cache[0] = ($event) => count.value++)
        }, "COUNT: " + toDisplayString(count.value), 1),
        createVNode(_component_el_button, {
          type: "success",
          onClick: _cache[1] || (_cache[1] = ($event) => count.value++)
        }, {
          default: withCtx(() => [
            createTextVNode("count is...: " + toDisplayString(count.value), 1)
          ]),
          _: 1
        }),
        createVNode(_component_el_button, {
          type: "warning",
          onClick: _cache[2] || (_cache[2] = ($event) => count.value++)
        }, {
          default: withCtx(() => [
            createTextVNode("count is: " + toDisplayString(count.value), 1)
          ]),
          _: 1
        }),
        createVNode(_component_el_button, {
          type: "danger",
          onClick: _cache[3] || (_cache[3] = ($event) => count.value++)
        }, {
          default: withCtx(() => [
            createTextVNode("count is: " + toDisplayString(count.value), 1)
          ]),
          _: 1
        }),
        createVNode(_component_el_button, {
          type: "info",
          onClick: _cache[4] || (_cache[4] = ($event) => count.value++)
        }, {
          default: withCtx(() => [
            createTextVNode("count is: " + toDisplayString(count.value), 1)
          ]),
          _: 1
        }),
        _hoisted_2$1
      ], 64);
    };
  }
});
var HiBarChart_vue_vue_type_style_index_0_scoped_true_lang = /* @__PURE__ */ (() => "#highcharts-container[data-v-1cea5cb5]{height:100%}#chart[data-v-1cea5cb5]{height:600px}\n")();
const _hoisted_1 = { style: { "height": "600px" } };
const _hoisted_2 = { style: { "height": "100%" } };
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "HiBarChart",
  setup(__props) {
    const chart = ref(null);
    function click() {
      chartOptions.title.text = "Barchart updated";
    }
    const chartOptions = reactive({
      chart: {
        type: "bar"
      },
      title: {
        text: "A Barchar",
        subtitle: "A Subtitle"
      },
      plotOptions: {
        series: {
          opacity: 0.5,
          shadow: false,
          borderRadius: 5,
          dataLabels: {
            enabled: true,
            borderRadius: 5,
            backgroundColor: "rgba(252, 255, 197, 0.3)",
            color: "rgba(1, 1, 1, 0.5)",
            borderWidth: 1,
            borderColor: "#AAA",
            y: -15,
            x: 0,
            style: {
              textOutline: "none"
            }
          },
          groupPadding: 0
        }
      },
      series: [{
        data: [
          2556,
          125,
          47,
          0,
          889,
          5,
          1017,
          190,
          23,
          18,
          994,
          1
        ]
      }],
      yAxis: {
        labels: {
          align: "left",
          x: 0,
          y: -2
        },
        offset: 20
      },
      xAxis: {
        labels: {
          align: "left",
          x: 2,
          y: 6,
          style: {
            fontSize: "13px",
            fontFamily: "sans-serif"
          }
        },
        categories: [
          "Pass",
          "Pass (Sensitive)",
          "Pass with Eat Safe",
          "Pass with Eat Safe (Sensitive)",
          "Improvement Required",
          "Improvement Required (Sensitive)",
          "Awaiting Inspection",
          "Awaiting Inspection (Sensitive)",
          "Exempt",
          "Exempt (Sensitive)",
          "Out of Scope",
          "Value not recognised"
        ]
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          createVNode(_sfc_main$1, { msg: "A Message" }),
          createVNode(unref(highchartsVue_min.exports.Chart), {
            style: { "height": "100%" },
            ref_key: "chart",
            ref: chart,
            options: chartOptions,
            updateArgs: [true, false]
          }, null, 8, ["options"])
        ]),
        createBaseVNode("button", { onClick: click }, "Add")
      ]);
    };
  }
});
var HiBarChart = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-1cea5cb5"]]);
function registerApp(tag2) {
  console.log("Registering from main.js", tag2);
  createApp(App).mount(tag2);
}
function registerHiBarChart(tag2) {
  console.log("Registering Hi Chart...");
  createApp(HiBarChart).mount(tag2);
}
export { registerApp, registerHiBarChart };
